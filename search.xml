<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode_Day25</title>
      <link href="/2021/03/30/leetcode-day25/"/>
      <url>/2021/03/30/leetcode-day25/</url>
      
        <content type="html"><![CDATA[<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="[4] 寻找两个正序数组的中位数"></a>[4] 寻找两个正序数组的中位数</h2><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/</a></p><ul><li>algorithms</li><li>Hard (39.83%)</li><li>Likes:    3903</li><li>Dislikes: -</li><li>Total Accepted:    371.4K</li><li>Total Submissions: 932.4K</li><li>Testcase Example:  ‘[1,3]\n[2]’</li></ul><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums1 = [1,3], nums2 = [2]<strong>输出：</strong>2.00000<strong>解释：</strong>合并数组 = [1,2,3] ，中位数 2</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums1 = [1,2], nums2 = [3,4]<strong>输出：</strong>2.50000<strong>解释：</strong>合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>nums1 = [0,0], nums2 = [0,0]<strong>输出：</strong>0.00000</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>nums1 = [], nums2 = [1]<strong>输出：</strong>1.00000</pre><p><strong>示例 5：</strong></p><pre><strong>输入：</strong>nums1 = [2], nums2 = []<strong>输出：</strong>2.00000</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>nums1.length == m</code></li>    <li><code>nums2.length == n</code></li>    <li><code>0 <= m <= 1000</code></li>    <li><code>0 <= n <= 1000</code></li>    <li><code>1 <= m + n <= 2000</code></li>    <li><code>-10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup></code></li></ul><p> </p><p><strong>进阶：</strong>你能设计一个时间复杂度为 <code>O(log (m+n))</code> 的算法解决此问题吗？</p><h3 id="方法1-合并数组"><a href="#方法1-合并数组" class="headerlink" title="方法1: 合并数组"></a>方法1: 合并数组</h3><p>思路: 将两个数组合并, 排序(sort函数), 再取中位数</p><h4 id="1-不使用-sort-函数"><a href="#1-不使用-sort-函数" class="headerlink" title="1. 不使用 sort 函数"></a>1. 不使用 <code>sort</code> 函数</h4><p>思路: 使用双指针, 按顺序合并两数组, 再取中位数.</p><p>步骤: </p><ul><li>设置双指针, 分别指向两个数组, 对比两个指针对应位置的大小, 将较小的数添加到合并后的数组里, 移动指针, 继续对比</li><li>取中位数</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;            int pos1 = 0, pos2 = 0, index = 0;            int size = nums1.size() + nums2.size();            vector &lt;int&gt; added_nums(size, 0);            while(pos1&lt;nums1.size() &amp;&amp; pos2&lt;nums2.size())&#123;                if(nums1[pos1] &lt;= nums2[pos2])&#123;                    added_nums[index] = nums1[pos1];                    ++pos1;                &#125;else&#123;                    added_nums[index] = nums2[pos2];                    ++pos2;                &#125;                ++index;            &#125;            if(pos1 &gt;= nums1.size() &amp;&amp; pos2 &lt; nums2.size())&#123;                while(pos2&lt;nums2.size())&#123;                    added_nums[index] = nums2[pos2];                    ++pos2;                    ++index;                &#125;            &#125;            if(pos2 &gt;= nums2.size() &amp;&amp; pos1 &lt; nums1.size())&#123;                while(pos1 &lt; nums1.size())&#123;                    added_nums[index] = nums1[pos1];                    ++pos1;                    ++index;                &#125;            &#125;            // for(int i=0; i&lt;added_nums.size(); ++i) cout &lt;&lt; added_nums[i] &lt;&lt; endl;            int mid = added_nums.size() &gt;&gt; 1;            return added_nums.size() % 2 == 0 ? (double) (added_nums[mid] + added_nums[mid - 1]) / 2 : added_nums[mid];    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210331100716.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(m+n)</code></li><li>空间复杂度: <code>O(m+n)</code></li></ul><h4 id="2-降低空间复杂度"><a href="#2-降低空间复杂度" class="headerlink" title="2. 降低空间复杂度"></a>2. 降低空间复杂度</h4><p>思路: 由于两数组的大小已知, 只是要找到中位数的位置, 只需设置两个指针, 分别指向数组首位, 每次将较小数的指针向后移动一位, 若其中一个数组遍历完成, 则只需在另一个数组中移动即可. 直至指针移动到中位数项</p><h4 id="3-使用-sort-函数-小伙子不讲武德"><a href="#3-使用-sort-函数-小伙子不讲武德" class="headerlink" title="3. 使用 sort 函数, 小伙子不讲武德"></a>3. 使用 <code>sort</code> 函数, 小伙子不讲武德</h4><p>步骤: </p><ul><li>先将两数组合并到一个数组里</li><li>利用 <code>sort</code> 函数排序</li><li>取中位数</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;            int size = nums1.size() + nums2.size();            int i, j;            vector &lt;int&gt; added_nums(size, 0);            for(i=0; i&lt;nums1.size(); ++i)&#123;                added_nums[i] = nums1[i];            &#125;            for(j=0; j&lt;nums2.size();++j)&#123;                added_nums[i+j] = nums2[j];            &#125;            sort(added_nums.begin(), added_nums.end());            int mid = added_nums.size() &gt;&gt; 1;            return added_nums.size() % 2 == 0 ? (double)(added_nums[mid] + added_nums[mid-1]) / 2 : added_nums[mid];    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210330223006.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(m+n+log(m+n)) = O(log(m+n))</code>, m为<code>nums1</code>长度, n为<code>nums2</code> 长度</li><li>空间复杂度: <code>O(m+n)</code></li></ul><h3 id="方法2-二分法"><a href="#方法2-二分法" class="headerlink" title="方法2: 二分法"></a>方法2: 二分法</h3><p>思路: k取两数组长度和的一半, 将本题转化为求第k小的数, 两数组长度之和为奇数, 第k小的数即为其中位数, 长度和为偶数, 中位数就是第k小数和第k+1小数和的一半</p><ul><li>对于求第k小的数, 可分别对两数组取第 $\dfrac{k}{2}$ 个数, 即数组中索引为 $\dfrac{k}{2}-1$ 的数, 因为数组是排好序的, 假如 <code>nums1[k/2-1]</code> 小于    <code>nums2[k/2-1]</code> , 那么在 <code>nums1</code> 中, <code>nums[k/2-1]</code> 之前的数都是比它小的数, 这样就可以排除这些数, 即排除    $\dfrac{k}{2}$ 项, 将这些数丢弃, 此时问题转化为求第 $\dfrac{k}{2}$ 小的数. </li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210331123356.png"> </p><ul><li>更新k的值, 令 <code>k = k - 1</code>, 问题又转化为求第k小的数, 不过要注意此时两数组是舍弃更新后的数组.</li><li>k经过迭代更新, 当<code>k = 1</code>时, 问题变成了求最小的值, 取此时的两数组(舍弃掉较小的值后的数组)的首项, 取其最小值即可</li></ul><p>下面用一个具体的例子来说明</p><pre><code>nums1 = [1, ]</code></pre><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int get_kth_element(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt; nums2, int k)&#123;        // 分别设置指针        int index1 = 0, index2 = 0;        int size1 = nums1.size(), size2 = nums2.size();        while(true)&#123;            // 处理边界情况            // nums1数组空            if(index1 &gt;= size1)&#123;                return nums2[index2 + k - 1];            &#125;            // nums2数组空            if(index2 &gt;= size2)&#123;                return nums1[index1 + k - 1];            &#125;            // k = 1            if(k == 1)&#123;                return min(nums1[index1], nums2[index2]);            &#125;            //处理一般情况            //            int newindex1 = min(index1 + k / 2 - 1, size1 - 1);            int newindex2 = min(index2 + k / 2 - 1, size2 - 1);            int value1 = nums1[newindex1];            int value2 = nums2[newindex2];            if(value1&lt;=value2)&#123;                k = k - (newindex1 - index1 + 1);                index1 = newindex1 + 1;            &#125;else&#123;                k = k - (newindex2 - index2 + 1);                index2 = newindex2 + 1;            &#125;        &#125;    &#125;    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;            int length = nums1.size() + nums2.size();            //奇数长            if(length % 2 == 1)&#123;                return (double)get_kth_element(nums1, nums2, (length + 1) / 2);            &#125;else&#123;                return (get_kth_element(nums1, nums2, length / 2) + get_kth_element(nums1, nums2, length / 2 + 1)) / 2.0;            &#125;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210331123507.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_每日一题3</title>
      <link href="/2021/03/30/leetcode-mei-ri-yi-ti-3/"/>
      <url>/2021/03/30/leetcode-mei-ri-yi-ti-3/</url>
      
        <content type="html"><![CDATA[<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="[74] 搜索二维矩阵"></a>[74] 搜索二维矩阵</h2><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/description/">https://leetcode-cn.com/problems/search-a-2d-matrix/description/</a></p><ul><li>algorithms</li><li>Medium (41.11%)</li><li>Likes:    372</li><li>Dislikes: -</li><li>Total Accepted:    104.3K</li><li>Total Submissions: 243.2K</li><li>Testcase Example:  ‘[[1,3,5,7],[10,11,16,20],[23,30,34,60]]\n3’</li></ul><p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul>    <li>每行中的整数从左到右按升序排列。</li>    <li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p> </p><p><strong>示例 1：</strong></p><img loading="lazy" alt="" src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" style="width: 322px; height: 242px;" /><pre><strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3<strong>输出：</strong>true</pre><p><strong>示例 2：</strong></p><img loading="lazy" alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" style="width: 322px; height: 242px;" /><pre><strong>输入：</strong>matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13<strong>输出：</strong>false</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>m == matrix.length</code></li>    <li><code>n == matrix[i].length</code></li>    <li><code>1 <= m, n <= 100</code></li>    <li><code>-10<sup>4</sup> <= matrix[i][j], target <= 10<sup>4</sup></code></li></ul><h3 id="方法1-两次二分查找"><a href="#方法1-两次二分查找" class="headerlink" title="方法1: 两次二分查找"></a>方法1: 两次二分查找</h3><p>思路: 看到有序, 直接二分整起来, 两次二分, 第一次查找是否存在满足条件的行, 第二次查找是否存在 <code>target</code></p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;            if(matrix.empty()) return false;            int left = 0, right = matrix.size() - 1, mid, i;             while(left &lt;= right)&#123;                mid = right + left &gt;&gt; 1;                if(matrix[mid][0] == target)&#123;                    return true;                &#125; else if(matrix[mid][matrix[mid].size() - 1] &lt; target)&#123;                    left = mid + 1;                &#125;else&#123;                    right = mid - 1;                &#125;            &#125;            i = left;            if(i &gt;= matrix.size()) return false;            left = 0;            right = matrix[i].size() - 1;            while(left &lt;= right)&#123;                mid = left + right &gt;&gt; 1;                if(matrix[i][mid] == target)&#123;                    return true;                &#125;else if(matrix[i][mid] &lt; target)&#123;                    left = mid + 1;                &#125;else&#123;                    right = mid - 1;                &#125;            &#125;            return false;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210330124735.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(logm + logn = logmn)</code>, m是行数, n是列数</li><li>空间复杂度: <code>O(1)</code></li></ul><h3 id="方法2-一次二分"><a href="#方法2-一次二分" class="headerlink" title="方法2: 一次二分"></a>方法2: 一次二分</h3><p>思路: 将矩阵看作是一个有序数组, 一次二分即可</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;            if(matrix.empty()) return false;            int m = matrix.size(), n = matrix[0].size();            int left = 0, right = m * n - 1, mid;            while(left &lt;= right)&#123;                mid = right + left &gt;&gt; 1;                int x = matrix[mid / n][mid % n];                if(x == target)&#123;                    return true;                &#125;else if(x &lt; target)&#123;                    left = mid + 1;                &#125;else&#123;                    right = mid - 1;                &#125;            &#125;            return false;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210330131450.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(logmn)</code></li><li>空间复杂度: <code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day24</title>
      <link href="/2021/03/29/leetcode-day24/"/>
      <url>/2021/03/29/leetcode-day24/</url>
      
        <content type="html"><![CDATA[<h2 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="[540] 有序数组中的单一元素"></a>[540] 有序数组中的单一元素</h2><p><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/</a></p><ul><li>algorithms</li><li>Medium (58.50%)</li><li>Likes:    214</li><li>Dislikes: -</li><li>Total Accepted:    26.1K</li><li>Total Submissions: 44.7K</li><li>Testcase Example:  ‘[1,1,2,3,3,4,4,8,8]’</li></ul><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [1,1,2,3,3,4,4,8,8]<strong>输出:</strong> 2</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> [3,3,7,7,10,11,11]<strong>输出:</strong> 10</pre><p><strong>注意:</strong> 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</p><h3 id="方法1-暴力搜索"><a href="#方法1-暴力搜索" class="headerlink" title="方法1: 暴力搜索"></a>方法1: 暴力搜索</h3><p>思路: 遍历数组, 比较第 <code>nums[i]</code> 与 <code>nums[i+1]</code>, 相等则往后跳两格继续比较</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;            int i = 0;            while(i&lt;nums.size() - 1)&#123;                if(nums[i] == nums[i+1])&#123;                    i+=2;                &#125;else&#123;                    return nums[i];                &#125;            &#125;            return nums[i];    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210330210930.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h3 id="方法2-二分查找"><a href="#方法2-二分查找" class="headerlink" title="方法2: 二分查找"></a>方法2: 二分查找</h3><p>思路: 在出现单一元素之前, 数字是重复出现的, 若此时在中间去掉一组数, 其左右两侧仍然是偶数, 在出现单一元素后, 若在中间去掉一组数, 那么必然一侧偶数, 一侧单数, 分开讨论即可</p><p>步骤: 关于 <code>mid</code> 的情况, 总共有三种</p><ul><li>首先判断一侧是否为偶数: <code>are_even = (right - mid) % 2 == 0</code></li><li><code>nums[mid] == nums[mid+1]</code> 如果 <code>are_even</code> 为真, 则证明去掉 <code>mid</code> 和 <code>mid+1</code> 项, 右侧共有奇数项, 则左侧一定为偶数项, 此时将        <code>left</code> 移到 <code>mid+2</code> 位置继续探索; 反之将 <code>right</code> 移到 <code>mid-1</code></li></ul><table><thead><tr><th>1</th><th>1</th><th>2</th><th>2</th><th>3</th><th>3</th><th>4</th><th>···</th><th>8</th><th>8</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>mid</td><td>mid+1</td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li><code>nums[mid] == nums[mid-1]</code> 如果    <code>are_even</code> 为真, 则证明去掉 <code>mid</code> 和 <code>mid-1</code> 项, 右侧为共有偶数项, 则左侧一定为奇数项, 单一元素在左侧, 此时将 <code>right</code> 移到 <code>mid-2</code> 位置继续探索; 反之将 <code>lfet</code> 移到 <code>mid+2</code> </li></ul><table><thead><tr><th>1</th><th>1</th><th>2</th><th>2</th><th>3</th><th>3</th><th>4</th><th>···</th><th>8</th><th>8</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>mid-1</td><td>mid</td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>若以上条件都不满足, 则 <code>mid</code> 所在位置即为单一元素</li></ul><table><thead><tr><th>1</th><th>1</th><th>2</th><th>2</th><th>3</th><th>4</th><th>4</th><th>···</th><th>8</th><th>8</th></tr></thead><tbody><tr><td></td><td></td><td></td><td>mid-1</td><td>mid</td><td>mid+1</td><td></td><td></td><td></td><td></td></tr></tbody></table><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;            int left=0, right = nums.size() -1, mid;            while(left &lt; right)&#123;                mid = left + right &gt;&gt; 1;                bool are_even = (right - mid) % 2 == 0;                 if(nums[mid] == nums[mid + 1])&#123;                    if(are_even)&#123;                        left = mid + 2;                    &#125; else &#123;                        right = mid - 1;                    &#125;                &#125;else if(nums[mid] == nums[mid - 1])&#123;                    if(are_even)&#123;                        right = right - 2;                    &#125; else&#123;                        left = left + 1;                    &#125;                &#125;else&#123;                    return nums[mid];                &#125;            &#125;            return nums[right];    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210330221349.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(logn)</code></li><li>空间复杂度: <code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_第234场周赛</title>
      <link href="/2021/03/28/leetcode-di-234-chang-zhou-sai/"/>
      <url>/2021/03/28/leetcode-di-234-chang-zhou-sai/</url>
      
        <content type="html"><![CDATA[<h3 id="5713-字符串中不同整数的数目"><a href="#5713-字符串中不同整数的数目" class="headerlink" title="5713. 字符串中不同整数的数目"></a>5713. 字符串中不同整数的数目</h3><p><a href="https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/">https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/</a> </p><p>思路: 双指针问题, 匹配数字, 保持字符串, 去除多余的0, 存入hash表, hash表的大小即为不同整数的数目</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int numDifferentIntegers(string word) &#123;        unordered_set &lt;string&gt; nums;        for(int i = 0; i &lt; word.size(); ++i)&#123;            if(!isdigit(word[i])) continue;            string s;            int j = i;            while(j &lt; word.size() &amp;&amp; isdigit(word[j])) s += word[j++];            int k = 0;            while(k&lt;s.size() &amp;&amp; s[k] == &#39;0&#39;) ++k;            nums.insert(s.substr(k));            i = j;        &#125;        return nums.size();    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210328213952.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day23</title>
      <link href="/2021/03/28/leetcode-day23/"/>
      <url>/2021/03/28/leetcode-day23/</url>
      
        <content type="html"><![CDATA[<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="[34] 在排序数组中查找元素的第一个和最后一个位置"></a>[34] 在排序数组中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/</a></p><ul><li>algorithms</li><li>Medium (42.33%)</li><li>Likes:    917</li><li>Dislikes: -</li><li>Total Accepted:    227.9K</li><li>Total Submissions: 538.3K</li><li>Testcase Example:  ‘[5,7,7,8,8,10]\n8’</li><li>Source Code:       34.find-first-and-last-position-of-element-in-sorted-array.cpp</li></ul><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p><strong>进阶：</strong></p><ul>    <li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li></ul><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 8<strong>输出：</strong>[3,4]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums = [<code>5,7,7,8,8,10]</code>, target = 6<strong>输出：</strong>[-1,-1]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>nums = [], target = 0<strong>输出：</strong>[-1,-1]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>0 <= nums.length <= 10<sup>5</sup></code></li>    <li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>    <li><code>nums</code> 是一个非递减数组</li>    <li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li></ul><h3 id="方法1-二分法查找"><a href="#方法1-二分法查找" class="headerlink" title="方法1: 二分法查找"></a>方法1: 二分法查找</h3><p>思路: 通过二分法查找到 <code>nums</code> 数组中是否存在等于 <code>target</code> 元素. 若存在, 向前查找可推出第一次出现的位置, 向后查找可推出最后一次出现的位置</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;            if(nums.empty()) return vector&lt;int&gt; &#123;-1, -1&#125;;            int l = 0, r = nums.size() - 1, mid;            int first_pos = -1, last_pos = -1;            bool is_exist = false;            while(l &lt;= r)&#123;                mid = l + (r - l) / 2;                if(target == nums[mid])&#123;                    first_pos = last_pos = mid;                    is_exist = true;                    break;                &#125; else if(target &gt; nums[mid])&#123;                    l = mid + 1;                &#125; else&#123;                    r = mid - 1;                &#125;            &#125;            if(is_exist)&#123;                while(first_pos &gt;= 1 &amp;&amp; nums[first_pos - 1] == nums[first_pos]) --first_pos;                 while(last_pos &lt; nums.size() - 1 &amp;&amp; nums[last_pos + 1] == nums[last_pos]) ++last_pos;            &#125;            return vector&lt;int&gt; &#123;first_pos, last_pos&#125;;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210328182500.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(logn)</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h3 id="方法2-构建c-中-lower-bound-和-upper-bound-函数"><a href="#方法2-构建c-中-lower-bound-和-upper-bound-函数" class="headerlink" title="方法2: 构建c++中 lower_bound 和 upper_bound 函数"></a>方法2: 构建c++中 <code>lower_bound</code> 和 <code>upper_bound</code> 函数</h3><p>此方法原理仍是二分法, 仅做练习</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;            if(nums.empty()) return vector&lt;int&gt; &#123;-1, -1&#125;;            int lower = lower_bound(nums, target);            int upper = upper_bound(nums, target) - 1; // 左闭右开            if(lower == nums.size() || nums[lower] != target) return vector&lt;int&gt; &#123;-1, -1&#125;;            return vector &lt;int&gt; &#123;lower, upper&#125;;    &#125;        int lower_bound(vector&lt;int&gt;&amp; nums, int target)&#123;            int l = 0, r = nums.size(), mid;            while(l &lt; r)&#123;                mid = l + (r - l) / 2;                if(nums[mid] &gt;= target)&#123;                    r = mid;                &#125; else&#123;                    l = mid + 1;                &#125;            &#125;            return l;        &#125;        int upper_bound(vector&lt;int&gt;&amp; nums, int target)&#123;            int l = 0, r = nums.size(), mid;            while(l &lt; r)&#123;                mid = l + (r - l) / 2;                if(nums[mid] &gt; target)&#123;                    r = mid;                &#125; else&#123;                    l = mid + 1;                &#125;            &#125;            return l;        &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210328184732.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(logn)</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h2 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="[81] 搜索旋转排序数组 II"></a>[81] 搜索旋转排序数组 II</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/description/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/description/</a></p><ul><li>algorithms</li><li>Medium (37.28%)</li><li>Likes:    308</li><li>Dislikes: -</li><li>Total Accepted:    59.6K</li><li>Total Submissions: 159.7K</li><li>Testcase Example:  ‘[2,5,6,0,0,1,2]\n0’</li><li>Source Code:       81.search-in-rotated-sorted-array-ii.cpp</li></ul><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p><p>( 例如，数组&nbsp;<code>[0,0,1,2,2,5,6]</code>&nbsp;可能变为&nbsp;<code>[2,5,6,0,0,1,2]</code>&nbsp;)。</p><p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code>。</p><p><strong>示例&nbsp;1:</strong></p><pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 0<strong>输出:</strong> true</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 3<strong>输出:</strong> false</pre><p><strong>进阶:</strong></p><ul>    <li>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a>&nbsp;的延伸题目，本题中的&nbsp;<code>nums</code>&nbsp; 可能包含重复元素。</li>    <li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li></ul><h3 id="方法1-二分查找"><a href="#方法1-二分查找" class="headerlink" title="方法1: 二分查找"></a>方法1: 二分查找</h3><p>思路: 虽然数组经过旋转, 但这不会影响二分查找在有序数组中使用, 只需先判断是否有序, 再进行二分查找即可</p><p>步骤: </p><ul><li><p>仅对出现的情况作说明</p></li><li><p>注意我使用的二分查找范围为 <strong>左闭右闭</strong></p></li><li><p>若 <code>nums[left] == nums[mid]</code> , 由于有重复元素的存在, 此时无法判断 <code>mid</code> 左右的有序性, 如: </p><pre><code>[1, 1, 1, 2, 1] mid = 3</code></pre><p>  此时只需将 <code>left</code> 往右移一位, 根据下一位的情况再来判断</p></li><li><p>若 <code>nums[left]</code> 与 <code>nums[mid]</code> 不等, 如果 <code>nums[mid] &lt;= nums[right]</code>, 则 <code>mid</code> 右侧一定是单调递增的, 这时根据 <code>target</code> 的值再进行二分查找即可</p></li><li><p>若以上条件都不满足, 则左侧单调递增</p></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool search(vector&lt;int&gt;&amp; nums, int target) &#123;            int left = 0, right = nums.size() - 1;            while(left &lt;= right)&#123;                int mid = left + right &gt;&gt; 1;                if(nums[mid] == target) return true;                if(nums[left] == nums[mid])                &#123;                    ++left;                &#125;else if(nums[mid] &lt;= nums[right])                &#123;                    if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])&#123;                        left = mid + 1;                    &#125; else &#123;                        right = mid - 1;                    &#125;                &#125; else &#123;                    if(target &lt; nums[mid] &amp;&amp; target &gt;= nums[left])&#123;                        right = mid - 1;                    &#125; else &#123;                        left = mid + 1;                    &#125;                &#125;            &#125;            return false;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210328223315.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(logn)</code></li><li>空间复杂度:    <code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day22</title>
      <link href="/2021/03/27/leetcode-day22/"/>
      <url>/2021/03/27/leetcode-day22/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul><li>二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取 一部分继续查找，将查找的复杂度大大减少。对于一个长度为 $O(n)$ 的数组，二分查找的时间复 杂度为 $O(log n)$ </li><li>数学定义: 给定一个在 <code>[a, b]</code> 区间内的单调函数 $f(x)$ ，若<br>$f(a)$ 和 $f(b)$ 正负性相反，那么必定存在一个解 $c$ ，使得 $f(c) = 0$</li></ul><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="[69] x 的平方根"></a>[69] x 的平方根</h2><p><a href="https://leetcode-cn.com/problems/sqrtx/description/">https://leetcode-cn.com/problems/sqrtx/description/</a></p><ul><li>algorithms</li><li>Easy (39.23%)</li><li>Likes:    632</li><li>Dislikes: -</li><li>Total Accepted:    280.6K</li><li>Total Submissions: 715.3K</li><li>Testcase Example:  ‘4’</li><li>Source Code:       69.sqrtx.cpp</li></ul><p>实现&nbsp;<code>int sqrt(int x)</code>&nbsp;函数。</p><p>计算并返回&nbsp;<em>x</em>&nbsp;的平方根，其中&nbsp;<em>x </em>是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> 4<strong>输出:</strong> 2</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> 8<strong>输出:</strong> 2<strong>说明:</strong> 8 的平方根是 2.82842...,&nbsp;    由于返回类型是整数，小数部分将被舍去。</pre><h3 id="方法1-二分查找"><a href="#方法1-二分查找" class="headerlink" title="方法1: 二分查找"></a>方法1: 二分查找</h3><p>思路: 设置两个指针, 代表区间 <code>[a, b]</code> 的首尾(注意这里双指针算法不太同, 双指针是一次移动一位, 这里一次移动半个区间) , 取中位数 <code>mid</code> 与 <code>x/mid</code> 进行计算对比, 若 <code>mid</code> 大, 则取 <code>mid</code> 左边区间继续计算, 反之则取右边区间</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int mySqrt(int x) &#123;            if(x==0) return x;            int left=1, right=x, mid=0, sqrt=0;            while(left &lt;= right)&#123;                mid = (right - left) / 2 + left;                // cout &lt;&lt; mid &lt;&lt; endl;                sqrt = x / mid;                if(sqrt == mid)&#123;                    return mid;                &#125;else if(sqrt &gt; mid)&#123;                    left = mid + 1;                &#125;else&#123;                    right = mid - 1;                &#125;            &#125;            return right;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210328171929.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(logn)</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h3 id="方法2-牛顿迭代法"><a href="#方法2-牛顿迭代法" class="headerlink" title="方法2: 牛顿迭代法"></a>方法2: 牛顿迭代法</h3><p>也就比第一种方法快 <strong>亿</strong> 点点</p><h4 id="牛顿迭代-原理"><a href="#牛顿迭代-原理" class="headerlink" title="牛顿迭代 原理"></a>牛顿迭代 原理</h4><p>待完善</p><p>迭代公式: $x_{n+1} = x_n - f(x_n) / f’(x_n)$<br>求平方根, 等价于给定 $f(x) = x^2 - a = 0$, 代入上式, 可🉐️迭代公式: $x_{n+1} = (x_n + a / x_n) / 2$</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int mySqrt(int x) &#123;            long n = x;            while( n * n &gt; x )&#123;                n = (n + x / n) / 2;            &#125;            return n;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210328172546.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_每日一题2</title>
      <link href="/2021/03/27/leetcode-mei-ri-yi-ti-2/"/>
      <url>/2021/03/27/leetcode-mei-ri-yi-ti-2/</url>
      
        <content type="html"><![CDATA[<h2 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="[61] 旋转链表"></a>[61] 旋转链表</h2><p><a href="https://leetcode-cn.com/problems/rotate-list/description/">https://leetcode-cn.com/problems/rotate-list/description/</a></p><ul><li>algorithms</li><li>Medium (40.61%)</li><li>Likes:    496</li><li>Dislikes: -</li><li>Total Accepted:    139.3K</li><li>Total Submissions: 337K</li><li>Testcase Example:  ‘[1,2,3,4,5]\n2’</li><li>Source Code:       61.rotate-list.cpp</li></ul><p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code><em> </em>个位置。</p><p> </p><p><strong>示例 1：</strong></p><img loading="lazy" alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" style="width: 600px; height: 254px;" /><pre><strong>输入：</strong>head = [1,2,3,4,5], k = 2<strong>输出：</strong>[4,5,1,2,3]</pre><p><strong>示例 2：</strong></p><img loading="lazy" alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" style="width: 472px; height: 542px;" /><pre><strong>输入：</strong>head = [0,1,2], k = 4<strong>输出：</strong>[2,0,1]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>    <li><code>-100 <= Node.val <= 100</code></li>    <li><code>0 <= k <= 2 * 10<sup>9</sup></code></li></ul><h3 id="方法1-快慢指针-首尾相连"><a href="#方法1-快慢指针-首尾相连" class="headerlink" title="方法1: 快慢指针, 首尾相连"></a>方法1: 快慢指针, 首尾相连</h3><p>思路: 旋转链表, 使节点移动, 可以将原链表转化为循环链表, 找到符合题意的头节点的位置即可</p><p>步骤: </p><ul><li>设置两指针 <code>fast</code> 和 <code>slow</code> , <code>fast</code> 指针用于探索链表尾部, 构建循环链表, <code>slow</code> 指针用于确定头节点的位置</li><li>遍历链表, 记录链表长度(<code>count</code>),  找到链表尾部, 将尾部指向 <code>head</code> , 构建循环链表</li><li>移动 <code>slow</code> 指针, 题目要求将节点向右移动 <code>k</code> 个位置, 等价于将头指针向左移动 <code>count - k</code> 个位置, 为了避免 <code>k &gt; count</code> 时多余的移动, 所以应向左移动 <code>count - k % count</code> 个位置</li></ul><h4 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h4><ul><li><p>遇到链表不要吝啬变量的使用, 比如本题, 使用双指针比使用单指针要快上不少</p><ul><li><p>单指针<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210327154953.png"></p></li><li><p>双指针<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210327155034.png"></p></li></ul></li><li><p>链表旋转, 移动 <code>k</code> 个位置, 向左移动等价于 <strong>头指针向右移动 <code>k % count</code> 个位置</strong> , 向右移动等价于 <strong>头指针向右移动 <code>count - k % count</code> 个位置</strong>. <code>count</code> 为链表长度</p></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    ListNode* rotateRight(ListNode* head, int k) &#123;            if(!head || k == 0) return head;            ListNode* fast = head;            ListNode* slow = head;            int count = 1;            while(fast-&gt;next)&#123;                fast = fast-&gt;next;                ++count;            &#125;            fast-&gt;next = head;            k = count - k % count;            while(k-- &gt; 1) slow = slow-&gt;next;            head = slow-&gt;next;            slow-&gt;next = nullptr;            return head;        &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210327155034.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code> , 最多需要两次遍历</li><li>空间复杂度: <code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day21</title>
      <link href="/2021/03/26/leetcode-day21/"/>
      <url>/2021/03/26/leetcode-day21/</url>
      
        <content type="html"><![CDATA[<h2 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="[524] 通过删除字母匹配到字典里最长单词"></a>[524] 通过删除字母匹配到字典里最长单词</h2><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/">https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/</a></p><ul><li>algorithms</li><li>Medium (47.15%)</li><li>Likes:    136</li><li>Dislikes: -</li><li>Total Accepted:    28.6K</li><li>Total Submissions: 60.7K</li><li>Testcase Example:  ‘“abpcplea”\n[“ale”,”apple”,”monkey”,”plea”]’</li></ul><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong>s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]<strong>输出:</strong>&quot;apple&quot;</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong>s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]<strong>输出:</strong>&quot;a&quot;</pre><p><strong>说明:</strong></p><ol>    <li>所有输入的字符串只包含小写字母。</li>    <li>字典的大小不会超过 1000。</li>    <li>所有输入的字符串长度不会超过 1000。</li></ol><h3 id="方法1-双指针-hashtable"><a href="#方法1-双指针-hashtable" class="headerlink" title="方法1: 双指针 + hashtable"></a>方法1: 双指针 + hashtable</h3><p>这道题看着不复杂, 实际上真的不复杂!    </p><p>思路:   用双指针可以轻松对比出来符合条件的子串, 再将子串的长度存入hashtable中, 再按照要求返回长度最长, 字典序最小的子串即可. </p><p>步骤: </p><ul><li>遍历字典 <code>dictionary</code> , 分别在字符串s和字典 <code>dictionary</code> 中字符串设置指针, 若当前指针下两字母相同, 则两指针分别向后移动一位, 继续进行对比, 若出现不同, 则仅将s中的指针后移一位, 继续进行对比. </li><li>仅当s中指针在最后一位之前(包含最后一位), 且d中指针超过字符串长度时, 改字符串是满足条件的子串, 将子串长度记录在 <code>hashtable</code> 中</li><li>遍历完字典, 遍历 <code>hashtable</code> , 得到子串最长的字符串, 若长度相同, 则取字典序最小的一个. </li></ul><p><strong>注意字典序的概念, 我就是把他当成在字典中的顺序, 结果错都不知道咋错的</strong></p><ul><li>字典序: 字典序（dictionary order），又称 字母序（alphabetical order），原意是表示英文单词在字典中的先后顺序，在计算机领域中扩展成两个任意字符串的大小关系。    </li><li>对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。若第一字母相同, 这往后移一位再进行比较</li><li>c++中, 使用例如 <code>&#39;a&#39; &lt; &#39;b&#39;</code> 就可进行比较</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) &#123;            int s_size = s.size(), d_size = dictionary.size();            int s_index = 0, index = 0, longest_index = 0;            bool isexit = false;            vector&lt;int&gt; word_count(d_size, 0);            for(int d_index = 0; d_index &lt; d_size; ++d_index)&#123;                string d_word = dictionary[d_index];                while(index &lt; d_word.size() &amp;&amp; s_index &lt; s_size)&#123;                    if(s[s_index] == d_word[index])&#123;                        ++s_index;                        ++index;                    &#125;else&#123;                        ++s_index;                    &#125;                &#125;                if(s_index &lt;= s_size &amp;&amp; index &gt;= d_word.size())&#123;                    word_count[d_index] = dictionary[d_index].size();                    isexit = true;                &#125;                s_index = 0;                index = 0;            &#125;            for(int i=0; i&lt;word_count.size();++i)&#123;                if(word_count[longest_index] &lt; word_count[i] || (word_count[longest_index] == word_count[i] &amp;&amp; dictionary[longest_index] &gt; dictionary[i]))&#123;                        longest_index = i;                &#125;            &#125;            return isexit ? dictionary[longest_index] : &quot;&quot;;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210326195612.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n*s+nx)</code> , n 代表字典中子串个数, x代表子串平均长度, s代表字符串s长度</li><li>空间复杂度: <code>O(n)</code> , 需要额外hashtable</li></ul><h2 id="340-至多包含-K-个不同字符的最长子串"><a href="#340-至多包含-K-个不同字符的最长子串" class="headerlink" title="[340] 至多包含 K 个不同字符的最长子串"></a>[340] 至多包含 K 个不同字符的最长子串</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/">https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/</a></p><p>给定一个字符串 s ，找出 至多 包含 k 个不同字符的最长子串 T。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong>s = "eceba", k = 2<strong>输出:</strong>3<strong>解释:</strong> 则 T 为 "ece"，所以长度为 3。</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong>s = "aa", k = 1<strong>输出:</strong>2<strong>解释:</strong> 则 T 为 "aa"，所以长度为 2。</pre><h3 id="方法1-双指针-滑动窗口-hashtable"><a href="#方法1-双指针-滑动窗口-hashtable" class="headerlink" title="方法1: 双指针(滑动窗口) + hashtable"></a>方法1: 双指针(滑动窗口) + hashtable</h3><p>思路: 使用双指针设置一个窗口, 保证窗口内的字符串满足题意即可</p><p>步骤: </p><ul><li>创建 <code>hashtable</code> 来存储字母出现的次数, <code>hashtable</code> 的长度为k, 创建 <code>count</code> 变量来统计窗口中不同字母的个数, 用于跟 <code>k</code> 做对比</li><li>设置 <code>left</code> 和 <code>right</code> 指针, 遍历字符串, 如果 <code>hashtable</code> 中没有该字母, 则将其加入 <code>hashtable</code>, 如果存在, 则次数 +1.</li><li>每次加入新字母时, <code>count</code> 要 +1.</li><li>如果 <code>count &gt; k</code> 时, 要将滑动窗口最左侧的字母删掉, 即将 <code>left</code> 指针右移一位, 在移动指针之前, 要先判断如果将该字母移除, <code>hashtable</code> 中还是否存在该字母</li><li>若存在,    可直接执行 <code>left</code> 指针右移, 若不存在, 则将 <code>count</code> -1, 表示可以接受新字母</li><li>遍历过程中, 取滑动窗口的最大值, 即 <code>right - left + 1</code> 的最大值</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int lengthOfLongestSubstringKDistinct(string s, int k) &#123;        map&lt;char, int&gt; window;        int left=0, count=0, res=0;        for(int right=0;right&lt;s.size(); ++right)&#123;            if(window.count(s[right]) == 0) count += 1;            window[s[right]] += 1;            while(count &gt; k)&#123;                if(--window[s[left]] == 0)&#123;                    window.erase(s[left]);                    --count;                &#125;                ++left;            &#125;            res = max(res, right - left + 1);        &#125;        return  res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210326233359.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 仅需遍历一次</li><li>空间复杂度: <code>O(k)</code>, hashtable</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_每日一题1</title>
      <link href="/2021/03/25/leetcode-mei-ri-yi-ti-1/"/>
      <url>/2021/03/25/leetcode-mei-ri-yi-ti-1/</url>
      
        <content type="html"><![CDATA[<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="[82] 删除排序链表中的重复元素 II"></a>[82] 删除排序链表中的重复元素 II</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/description/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/description/</a></p><ul><li>algorithms</li><li>Medium (50.18%)</li><li>Likes:    535</li><li>Dislikes: -</li><li>Total Accepted:    106.5K</li><li>Total Submissions: 206.7K</li><li>Testcase Example:  ‘[1,2,3,3,4,4,5]’</li></ul><p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong><em> </em>的数字。</p><p>返回同样按升序排列的结果链表。</p><p> </p><p><strong>示例 1：</strong></p><img loading="lazy" alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" style="width: 500px; height: 142px;" /><pre><strong>输入：</strong>head = [1,2,3,3,4,4,5]<strong>输出：</strong>[1,2,5]</pre><p><strong>示例 2：</strong></p><img loading="lazy" alt="" src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" style="width: 500px; height: 205px;" /><pre><strong>输入：</strong>head = [1,1,1,2,3]<strong>输出：</strong>[2,3]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>    <li><code>-100 <= Node.val <= 100</code></li>    <li>题目数据保证链表已经按升序排列</li></ul><h3 id="方法1-迭代-一次遍历"><a href="#方法1-迭代-一次遍历" class="headerlink" title="方法1:  迭代(一次遍历)"></a>方法1:  迭代(一次遍历)</h3><p>因为链表是排好序的, 所以重复的元素一定是连续的. 所以一次遍历即可删除重复元素. 在处理链表问题时, <code>head</code> 节点有可能被删除, 所以需要设置一个哑节点(dummy node) 使得    <code>dummy-&gt;next = head</code> ,这是重点.</p><p>具体迭代如下: </p><ul><li>设置 <code>pos</code> 节点指向链表的哑节点, 遍历链表, 遍历需要保证 <code>pos-&gt;next</code> 和 <code>pos-&gt;next-&gt;next</code> 存在, 若 <code>pos-&gt;next-&gt;val</code> 与 <code>pos-&gt;next-&gt;next-&gt;val</code> 相等, 代表该数字重复, 用一个变量 <code>x</code> 来记录这个重复的数字</li><li>继续遍历, 当 <code>pos-&gt;next</code> 存在 且 <code>pos-&gt;next-&gt;val</code> 与 <code>x</code> 相等, 则将指针继续后移, 忽略掉这个相等的数字, 重复此操作, 直到 <code>pos-&gt;next-&gt;val</code> 与 <code>x</code> 不等, 或 <code>pos-&gt;next</code> 不存在</li><li>返回值是 <code>dummy-&gt;next</code></li><li>未将 <code>dummy node</code> 和被删除节点释放<pre><code class="line-numbers language-cpp">class Solution &#123;public:  ListNode* deleteDuplicates(ListNode* head) &#123;          if(!head) return head;          // 创建 dummy node , dummy-&gt;next = head          ListNode* dummy = new ListNode(0, head);          ListNode* pos = dummy;          while(pos-&gt;next &amp;&amp; pos-&gt;next-&gt;next)&#123;              if(pos-&gt;next-&gt;val == pos-&gt;next-&gt;next-&gt;val)&#123;                  int x = pos-&gt;next-&gt;val;                  while(pos-&gt;next &amp;&amp; pos-&gt;next-&gt;val == x)&#123;                      pos-&gt;next = pos-&gt;next-&gt;next;                  &#125;              &#125;else&#123;                  pos = pos-&gt;next;              &#125;          &#125;          return dummy-&gt;next;  &#125;&#125;;</code></pre></li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210325163437.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code> , 仅需一次遍历</li><li>空间复杂度:  <code>O(1)</code></li></ul><h3 id="方法2-递归"><a href="#方法2-递归" class="headerlink" title="方法2: 递归"></a>方法2: 递归</h3><p>待完善</p>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day20</title>
      <link href="/2021/03/25/leetcode-day20/"/>
      <url>/2021/03/25/leetcode-day20/</url>
      
        <content type="html"><![CDATA[<h2 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="[633] 平方数之和"></a>[633] 平方数之和</h2><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/">https://leetcode-cn.com/problems/sum-of-square-numbers/description/</a></p><ul><li>algorithms</li><li>Medium (34.98%)</li><li>Likes:    169</li><li>Dislikes: -</li><li>Total Accepted:    40.4K</li><li>Total Submissions: 114.8K</li><li>Testcase Example:  ‘5’</li><li>Source Code:       633.sum-of-square-numbers.cpp</li></ul><p>给定一个非负整数&nbsp;<code>c</code>&nbsp;，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得&nbsp;<code>a<sup>2</sup> + b<sup>2</sup> = c</code> 。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>c = 5<strong>输出：</strong>true<strong>解释：</strong>1 * 1 + 2 * 2 = 5</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>c = 3<strong>输出：</strong>false</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>c = 4<strong>输出：</strong>true</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>c = 2<strong>输出：</strong>true</pre><p><strong>示例 5：</strong></p><pre><strong>输入：</strong>c = 1<strong>输出：</strong>true</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= c &lt;= 2<sup>31</sup> - 1</code></li></ul><h3 id="方法1-双指针"><a href="#方法1-双指针" class="headerlink" title="方法1: 双指针"></a>方法1: 双指针</h3><p>本题可以使用双指针快速找到答案, 思想还是等同于遇到有序数组, 只不过数组范围为 <code>0, sqrt(c)</code><br>唯一需要注意的是 <code>c</code> 的取值范围 , 最好用 <code>long</code> 来创建双指针</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool judgeSquareSum(int c) &#123;            if(c&lt;=2)&#123;                return true;            &#125;            long a = 0, b = sqrt(c);            while(a&lt;=b)&#123;                if(b*b == c - a*a)&#123;                    return true;                &#125;else if(b*b &lt; c - a*a)&#123;                    ++a;                &#125;else&#123;                    --b;                &#125;            &#125;            return false;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210325100329.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(sqrt(n))</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h3 id="方法2-二分查找"><a href="#方法2-二分查找" class="headerlink" title="方法2: 二分查找"></a>方法2: 二分查找</h3><p>待完善</p><h2 id="680-验证回文字符串-Ⅱ"><a href="#680-验证回文字符串-Ⅱ" class="headerlink" title="[680] 验证回文字符串 Ⅱ"></a>[680] 验证回文字符串 Ⅱ</h2><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/description/">https://leetcode-cn.com/problems/valid-palindrome-ii/description/</a></p><ul><li>algorithms</li><li>Easy (39.95%)</li><li>Likes:    336</li><li>Dislikes: -</li><li>Total Accepted:    67.2K</li><li>Total Submissions: 167.6K</li><li>Testcase Example:  ‘“aba”‘</li></ul><p>给定一个非空字符串&nbsp;<code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> &quot;aba&quot;<strong>输出:</strong> True</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> &quot;abca&quot;<strong>输出:</strong> True<strong>解释:</strong> 你可以删除c字符。</pre><p><strong>注意:</strong></p><ol>    <li>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</li></ol><h3 id="方法1-双指针-1"><a href="#方法1-双指针-1" class="headerlink" title="方法1: 双指针"></a>方法1: 双指针</h3><p>在数组首尾分别设置左右指针, 两指针朝中间靠拢, 两指针对应元素相等则继续靠拢, 需要注意的是, 当元素不等, 只要 区间为 <code>[left+1, right)</code> 或 <code>[left, right-1)</code> 的子数组满足回文即可</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool validPalindrome(string s) &#123;            int count=1, left = 0, right = s.size() - 1;            while(left &lt; right)&#123;                if(s[left] == s[right])&#123;                    ++left;                    --right;                &#125; else return (isvailed(s, left + 1, right) || isvailed(s, left, right - 1));            &#125;            return true;        &#125;        bool isvailed(string s, int left, int right)&#123;            while(left &lt; right)&#123;                if(s[left] == s[right])&#123;                    ++left;                    --right;                &#125;else return false;                return true;            &#125;        &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210325121718.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code> , 判断s与判断s的子字符都是 <code>O(n)</code></li><li>空间复杂度:  <code>O(1)</code>, 常量空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day19</title>
      <link href="/2021/03/24/leetcode-day19/"/>
      <url>/2021/03/24/leetcode-day19/</url>
      
        <content type="html"><![CDATA[<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="[76] 最小覆盖子串"></a>[76] 最小覆盖子串</h3><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/description/">https://leetcode-cn.com/problems/minimum-window-substring/description/</a></p><ul><li>algorithms</li><li>Hard (40.57%)</li><li>Likes:    1042</li><li>Dislikes: -</li><li>Total Accepted:    120.1K</li><li>Total Submissions: 293.1K</li><li>Testcase Example:  ‘“ADOBECODEBANC”\n”ABC”‘</li></ul><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>""</code> 。</p><p><strong>注意：</strong>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>s = "ADOBECODEBANC", t = "ABC"<strong>输出：</strong>"BANC"</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>s = "a", t = "a"<strong>输出：</strong>"a"</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 <= s.length, t.length <= 10<sup>5</sup></code></li>    <li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p> </p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？<h3 id="方法1-双指针-滑动窗口"><a href="#方法1-双指针-滑动窗口" class="headerlink" title="方法1: 双指针(滑动窗口)"></a>方法1: 双指针(滑动窗口)</h3><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/76_fig.gif"></p><p>思路:</p><ul><li>通过设置左右两个指针(left&lt;=right), 在两指针之间形成一个窗口, 每次仅仅移动一侧的指针.</li><li>当前窗口未包含t中所需的所有字符串, 则右侧指针右移, 左侧指针不动, 直至满足条件; </li><li>此时右侧指针保持不动, 左侧指针移动来获得能满足条件的最小滑动窗口</li></ul><p>知道原理后, 需要解决的问题如下:</p><ul><li><p>如何判断滑动窗口中是否包含t中全部字符</p><ol><li>设置 <code>flag</code> 数组用来记录t中出现的字母</li><li>设置 <code>chars</code> 数组用来记录t中字母出现的次数, 也可当作滑动窗口中还需要相应字母的个数.  <strong>(当个数为负值则代表该字母有多余)</strong></li><li>设置 <code>count</code> 变量来表示滑动窗口已包含t中字母的个数, 当 <code>count == t.size()</code> 时表示当前窗口已包含t中所有字母, 这也是滑动窗口左侧下标右移的条件</li><li><code>flag</code> , <code>chars</code> 也可用 <code>hashtable</code></li><li>因为字母 <code>z</code> 对应的ASCII码是 <code>123</code> , 所以将数组长度设为123即可, 不过将其设置为2的整数幂128更好</li></ol></li><li><p>如何设置滑动窗口的移动</p><ol><li>具体设置见代码注释</li><li>注意: 这里设置的滑动窗口的区间为 <code>[left, right)</code> , 左闭右开, 所以区间长度为 <code>right - left + 1</code></li></ol></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    string minWindow(string s, string t) &#123;            // chars 存储t中对应字母出现的次数            // flag 记录t中出现的字母            vector&lt;int&gt; chars(128, 0);            vector&lt;bool&gt; flag(128, false);            for(int i=0; i&lt;t.size(); ++i)&#123;                flag[t[i]] = true;                ++chars[t[i]];            &#125;            int count=0, left=0, min_left = 0, min_size = s.size() + 1;            // count 代表滑动窗口中已包含t中字符的个数            // min_left用于记录最小滑动窗口的左侧下标            // min_size 用于记录最小滑动窗口大小            for(int right=0; right&lt;s.size(); ++right )&#123;                if(flag[s[right]])&#123;                    if(--chars[s[right]]&gt;=0)&#123;                        ++count;                    &#125;                    while(count==t.size())&#123;                        // 更新最小滑动窗口                        if(right - left + 1 &lt; min_size)&#123;                            min_left = left;                            min_size = right -left + 1;                        &#125;                        // 若左边待滑动元素是t中元素,并且若滑动, 当前滑动窗口不再包含t中所有字符                        // 待滑动                        if(flag[s[left]] &amp;&amp; ++chars[s[left]] &gt; 0)&#123;                            --count;                        &#125;                        // 执行滑动                         //左侧向右滑动                        ++left;                    &#125;                &#125;            &#125;            return min_size &gt; s.size() ? &quot;&quot; : s.substr(min_left, min_size);    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324234551.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code> , 注意这里虽然 <code>for</code> 循环里面有一个 <code>while</code> ,但 <code>while</code> 循环只负责 <code>left</code> 指针的移动, 且 <code>left</code> 指针只会从左向右移动1次, 故总的时间复杂度还是 <code>O(n)</code></li><li>空间复杂度:  <code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day18</title>
      <link href="/2021/03/23/leetcode-day18/"/>
      <url>/2021/03/23/leetcode-day18/</url>
      
        <content type="html"><![CDATA[<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="[142] 环形链表 II"></a>[142] 环形链表 II</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/description/">https://leetcode-cn.com/problems/linked-list-cycle-ii/description/</a></p><ul><li>algorithms</li><li>Medium (54.35%)</li><li>Likes:    923</li><li>Dislikes: -</li><li>Total Accepted:    201.4K</li><li>Total Submissions: 369.7K</li><li>Testcase Example:  ‘[3,2,0,-4]\n1’</li></ul><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>进阶：</strong></p><ul>    <li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li></ul><p> </p><p><strong>示例 1：</strong></p><p><img loading="lazy" alt="" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324201825.png" style="height: 97px; width: 300px;" /></p><pre><strong>输入：</strong>head = [3,2,0,-4], pos = 1<strong>输出：</strong>返回索引为 1 的链表节点<strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</pre><p><strong>示例 2：</strong></p><p><img loading="lazy" alt="" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324201857.png" style="height: 74px; width: 141px;" /></p><pre><strong>输入：</strong>head = [1,2], pos = 0<strong>输出：</strong>返回索引为 0 的链表节点<strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</pre><p><strong>示例 3：</strong></p><p><img loading="lazy" alt="" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324201929.png" style="height: 45px; width: 45px;" /></p><pre><strong>输入：</strong>head = [1], pos = -1<strong>输出：</strong>返回 null<strong>解释：</strong>链表中没有环。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li>链表中节点的数目范围在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>    <li><code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code></li>    <li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><h3 id="方法1-双指针-快慢指针"><a href="#方法1-双指针-快慢指针" class="headerlink" title="方法1: 双指针(快慢指针)"></a>方法1: 双指针(快慢指针)</h3><p>对于链表找环路的问题, 有一种通用解法–快慢指针(Floyd判圈法).</p><p>给定两个指针， 分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步。如果 fast 可以走到尽头，那么说明没有环路;如果 fast 可以无限走下去，那么说明一定有环路，且一定存 在一个时刻 slow 和 fast 相遇。当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并 让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。</p><p>原理解释如下:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324193621.png"></p><ul><li><p>假设两指针在紫色点处相遇, 且此时slow指针一定是入环的第一圈, slow指针走的距离是 $a+b$ , fast指针走的距离是 $a+n(b+c)+b = a+(n+1)b+nc$ , 由于fast指针一次前进2步, slow指针一次前进1步, 故<br>$a+(n+1)b+nc = 2(a+b)$ , 可得 $a=(n-1)(b+c)+c$</p></li><li><p>此时重新设置fast指向头节点, 两指针再以相同速度前进, 则一定能在环路起点相遇</p></li><li><p>为何两指针一定可以在slow指针入环第一圈相遇?</p><ul><li>当slow在环路起点时, fast一定在环路的某一位置, slow在环路前进1圈, fast可以前进2圈,所以slow和fast一定可以在slow前进一圈内相遇</li></ul></li><li><p>为何要将fast速度设为2倍slow?</p><ul><li>事实上, fast速度可以是slow速度的任意倍, 任意倍数可能就没有一圈内相遇也没有相遇点加上环外节点长度刚好是入环点这些性质</li></ul></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;            ListNode *fast = head, *slow = head;            do&#123;                if(!fast || !fast-&gt;next) return nullptr;                fast = fast-&gt;next-&gt;next;                slow = slow-&gt;next;            &#125;while(fast != slow);            fast = head;            while(fast!=slow)&#123;                fast = fast-&gt;next;                slow = slow-&gt;next;            &#125;            return fast;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324195636.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(N)</code> 判断是否为环路时, slow指针没有走完一圈, 判断环路起点时, slow走过的距离也不会超过链表的总长度. 因此, 时间复杂度为 <code>O(N) + O(N) = O(N)</code></li><li>空间复杂度: <code>O(1)</code></li></ul><h3 id="方法2-哈希表"><a href="#方法2-哈希表" class="headerlink" title="方法2: 哈希表"></a>方法2: 哈希表</h3><p>遍历整个链表, 记录每个节点, 若出现重复节点, 则该链表含有环路, 且该重复节点即为环路起始点</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    ListNode *detectCycle(ListNode *head) &#123;            unordered_set&lt;ListNode *&gt; visited;            while(head!=nullptr)&#123;                if(visited.count(head))&#123;                    return head;                &#125;                visited.insert(head);                head = head-&gt;next;            &#125;            return nullptr;        &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_images/img/20210324201142.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(N)</code> , 只需遍历一次链表</li><li>空间复杂度:  <code>O(N)</code>, 需要建立额外的hash表, 表长为N</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day17</title>
      <link href="/2021/03/22/leetcode-day17/"/>
      <url>/2021/03/22/leetcode-day17/</url>
      
        <content type="html"><![CDATA[<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="[88] 合并两个有序数组"></a>[88] 合并两个有序数组</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/description/">https://leetcode-cn.com/problems/merge-sorted-array/description/</a></p><ul><li>algorithms</li><li>Easy (49.33%)</li><li>Likes:    808</li><li>Dislikes: -</li><li>Total Accepted:    291.8K</li><li>Total Submissions: 589.2K</li><li>Testcase Example:  ‘[1,2,3,0,0,0]\n3\n[2,5,6]\n3’</li><li>Source Code:       88.merge-sorted-array.cpp</li></ul><p>给你两个有序整数数组 <code>nums1</code><em> </em>和 <code>nums2</code>，请你将 <code>nums2</code><em> </em>合并到 <code>nums1</code><em> </em>中<em>，</em>使 <code>nums1</code><em> </em>成为一个有序数组。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code><em> </em>。你可以假设 <code>nums1</code><em> </em>的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<strong>输出：</strong>[1,2,2,3,5,6]</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>nums1 = [1], m = 1, nums2 = [], n = 0<strong>输出：</strong>[1]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>nums1.length == m + n</code></li>    <li><code>nums2.length == n</code></li>    <li><code>0 <= m, n <= 200</code></li>    <li><code>1 <= m + n <= 200</code></li>    <li><code>-10<sup>9</sup> <= nums1[i], nums2[i] <= 10<sup>9</sup></code></li></ul><h3 id="方法1-优美的双指针"><a href="#方法1-优美的双指针" class="headerlink" title="方法1: 优美的双指针!"></a>方法1: 优美的双指针!</h3><p>由于两个数组是有序的, 所以可以分别在两个数组末尾设置指针, 比较他们的值, 较大的直接写入 <code>nums1</code> 数组的末尾, 为了写入, 还需设置一个 <code>pos</code> 指针来记录位置</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324175252.png"></p><p>当 <code>nums1</code> 完成重写, 那么可直接将 <code>nums2</code> 中的数写入 <code>nums1</code> 即可; 若 <code>nums2</code> 先完成, 因为 <code>nums1</code> 中本就有序, 则完成重排</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;            int pos = (m--) + (n--) -1;            while(m&gt;=0 &amp;&amp; n&gt;=0)&#123;                nums1[pos--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];             &#125;            while(n&gt;=0)&#123;                nums1[pos--] = nums2[n--];            &#125;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324180346.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(m+n)</code> ,  最多移动 <code>m+n</code> 次</li><li>空间复杂度: <code>O(1)</code> , 直接在 <code>nums1</code> 上操作, 无需额外空间</li></ul><p>注意: 这里用到了 <code>a++, ++a</code> 的一些小技巧. </p><ul><li><code>a++</code> , 将a加1, 返回值为 <code>a</code></li><li><code>++a</code> , 将a加1, 返回值为 <code>a+1</code></li><li>若只希望增加a的值, 不需要返回值, 则推荐 <code>++a</code> , 运行速度快</li></ul>]]></content>
      
      
      <categories>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day16</title>
      <link href="/2021/03/21/leetcode-day16/"/>
      <url>/2021/03/21/leetcode-day16/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul><li><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多 个数组的多个指针。</p></li><li><p>若两个指针指向同一数组，遍历方向相同且不会相交，则也称为 <strong>滑动窗口</strong> (两个指针包围的 区域即为当前的窗口)，经常用于区间搜索。</p></li><li><p>若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是 排好序的。</p></li></ul><h2 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="[167] 两数之和 II - 输入有序数组"></a>[167] 两数之和 II - 输入有序数组</h2><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/</a></p><ul><li>algorithms</li><li>Easy (57.40%)</li><li>Likes:    490</li><li>Dislikes: -</li><li>Total Accepted:    201.7K</li><li>Total Submissions: 349.6K</li><li>Testcase Example:  ‘[2,7,11,15]\n9’</li><li>Source Code:       167.two-sum-ii-input-array-is-sorted.cpp</li></ul><p>给定一个已按照<strong><em> </em>升序排列  </strong>的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p><p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 <= answer[0] < answer[1] <= numbers.length</code> 。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>numbers = [2,7,11,15], target = 9<strong>输出：</strong>[1,2]<strong>解释：</strong>2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>numbers = [2,3,4], target = 6<strong>输出：</strong>[1,3]</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>numbers = [-1,0], target = -1<strong>输出：</strong>[1,2]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>2 <= numbers.length <= 3 * 10<sup>4</sup></code></li>    <li><code>-1000 <= numbers[i] <= 1000</code></li>    <li><code>numbers</code> 按 <strong>递增顺序</strong> 排列</li>    <li><code>-1000 <= target <= 1000</code></li>    <li>仅存在一个有效答案</li></ul><h3 id="方法1-双指针"><a href="#方法1-双指针" class="headerlink" title="方法1: 双指针"></a>方法1: 双指针</h3><p>这是一个简单的双指针应用, 通过在数组首尾设置左右指针, 将其和与 <code>target</code> 进行对比, 若 <code>sum &gt; target</code> ,则将右指针左移, 若 <code>sum &lt; target</code> , 则将左指针右移</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;            int left = 0, right = numbers.size() - 1, sum;            while(left &lt; right)&#123;                sum = numbers[left] + numbers[right];                if(target == sum) break;                if(target &gt; sum) left++;                else right--;            &#125;            return vector&lt;int&gt;&#123;left+1, right+1&#125;;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324171452.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 双指针移动总数最多为 n</li><li>空间复杂度: <code>O(1)</code></li></ul><p>关于双指针为什么不会漏掉答案的详细解释:</p><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/">一张图告诉你 O(n) 的双指针解法的本质原理（C++/Java）</a> </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day15</title>
      <link href="/2021/03/20/leetcode-day15/"/>
      <url>/2021/03/20/leetcode-day15/</url>
      
        <content type="html"><![CDATA[<h3 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="[665] 非递减数列"></a>[665] 非递减数列</h3><p><a href="https://leetcode-cn.com/problems/non-decreasing-array/description/">https://leetcode-cn.com/problems/non-decreasing-array/description/</a></p><ul><li>algorithms</li><li>Easy (26.42%)</li><li>Likes:    549</li><li>Dislikes: -</li><li>Total Accepted:    62.8K</li><li>Total Submissions: 236.8K</li><li>Testcase Example:  ‘[4,2,3]’</li></ul><p>给你一个长度为 <code>n</code> 的整数数组，请你判断在 <strong>最多 </strong>改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p><p>我们是这样定义一个非递减数列的： 对于数组中任意的 <code>i</code> <code>(0 <= i <= n-2)</code>，总满足 <code>nums[i] <= nums[i + 1]</code>。</p><p> </p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> nums = [4,2,3]<strong>输出:</strong> true<strong>解释:</strong> 你可以通过把第一个4变成1来使得它成为一个非递减数列。</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> nums = [4,2,1]<strong>输出:</strong> false<strong>解释:</strong> 你不能在只改变一个元素的情况下将其变为非递减数列。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 <= n <= 10 ^ 4</code></li>    <li><code>- 10 ^ 5 <= nums[i] <= 10 ^ 5</code></li></ul><h3 id="方法1-贪心算法"><a href="#方法1-贪心算法" class="headerlink" title="方法1: 贪心算法"></a>方法1: 贪心算法</h3><p>思路:<br>当出现递减时, 如何选择放缩是问题的关键, 有两种修改方式:</p><ul><li>扩大后者, 可能会造成后续不连增</li><li>缩小前者, 可能会导致前面不连增</li></ul><p>所以要采取贪心的策略，在遍历时，每次需要看连续的三个元素，也就是瞻前顾后，遵循以下两个原则：</p><ul><li>尽量不扩大后者的值, 因为这会使后面递增困难</li><li>若缩小前者, 则要保证缩小后依然满足递增</li></ul><p>实现步骤:</p><ul><li>遍历数组, 若 <code>i+1</code> 出现递减, 则判断 <code>i-1</code> 与 <code>i+1</code> 的大小关系, 前者大则只可执行放大后者操作, 后者大则放大 <code>i+1</code> 和缩小 <code>i</code> 皆可, 遵循贪心策略, 应缩小 <code>i</code></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123;        int size = nums.size();        bool flag = nums[0] &lt;= nums[1] ? true : false;        for(int i = 1; i &lt; size - 1; ++i)&#123;            if(nums[i] &gt; nums[i+1])&#123;                if(flag)&#123;                    if(nums[i-1] &gt; nums[i+1])&#123;                        nums[i+1] = nums[i];                    &#125;else&#123;                        nums[i] = nums[i+1];                    &#125;                    flag = false;                &#125;                else&#123;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324135254.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 仅遍历一次数组</li><li>空间复杂度: <code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day14</title>
      <link href="/2021/03/19/leetcode-day14/"/>
      <url>/2021/03/19/leetcode-day14/</url>
      
        <content type="html"><![CDATA[<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="[122] 买卖股票的最佳时机 II"></a>[122] 买卖股票的最佳时机 II</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p><ul><li>algorithms</li><li>Easy (66.44%)</li><li>Likes:    1153</li><li>Dislikes: -</li><li>Total Accepted:    326.7K</li><li>Total Submissions: 487.3K</li><li>Testcase Example:  ‘[7,1,5,3,6,4]’</li><li>Source Code:       122.best-time-to-buy-and-sell-stock-ii.cpp</li></ul><p>给定一个数组，它的第&nbsp;<em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>&nbsp;</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [7,1,5,3,6,4]<strong>输出:</strong> 7<strong>解释:</strong> 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&nbsp;    随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> [1,2,3,4,5]<strong>输出:</strong> 4<strong>解释:</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&nbsp;    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。&nbsp;    因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</pre><p><strong>示例&nbsp;3:</strong></p><pre><strong>输入:</strong> [7,6,4,3,1]<strong>输出:</strong> 0<strong>解释:</strong> 在这种情况下, 没有交易完成, 所以最大利润为 0。</pre><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>    <li><code>0 &lt;= prices[i]&nbsp;&lt;= 10 ^ 4</code></li></ul><h3 id="方法1-贪心算法"><a href="#方法1-贪心算法" class="headerlink" title="方法1: 贪心算法"></a>方法1: 贪心算法</h3><p>由于同一天可以进行多次买卖, 那么如果把所有的上坡全部买下, 那么获得的利益一定最大</p><p>注意: 此种方法仅可获得最大利润, 并非真实的买卖情况</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;            int res = 0;            int size = prices.size();            for(int i = 1; i &lt; size; ++i)&#123;                if(prices[i] &gt; prices[i-1])&#123;                    res += prices[i] - prices[i-1];                &#125;            &#125;            return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324104701.png"></p><p>官方解法:</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;            int res = 0;            int size = prices.size();            for(int i = 1; i &lt; size; ++i)&#123;                    res += max(0, prices[i] - prices[i-1]);            &#125;            return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324104833.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 仅需一次遍历</li><li>空间复杂度: <code>O(1)</code>, 常数空间</li></ul><h3 id="方法2-动态规划"><a href="#方法2-动态规划" class="headerlink" title="方法2: 动态规划"></a>方法2: 动态规划</h3><p>待完善</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day13</title>
      <link href="/2021/03/18/leetcode-day13/"/>
      <url>/2021/03/18/leetcode-day13/</url>
      
        <content type="html"><![CDATA[<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="[763] 划分字母区间"></a>[763] 划分字母区间</h3><p><a href="https://leetcode-cn.com/problems/partition-labels/description/">https://leetcode-cn.com/problems/partition-labels/description/</a></p><ul><li>algorithms</li><li>Medium (76.57%)</li><li>Likes:    467</li><li>Dislikes: -</li><li>Total Accepted:    60.1K</li><li>Total Submissions: 78.6K</li><li>Testcase Example:  ‘“ababcbacadefegdehijhklij”‘</li><li>Source Code:       763.partition-labels.cpp</li></ul><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p> </p><p><strong>示例：</strong></p><pre><strong>输入：</strong>S = "ababcbacadefegdehijhklij"<strong>输出：</strong>[9,7,8]<strong>解释：</strong>划分结果为 "ababcbaca", "defegde", "hijhklij"。每个字母最多出现在一个片段中。像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>    <li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code> 。</li></ul><h3 id="方法1-贪心算法"><a href="#方法1-贪心算法" class="headerlink" title="方法1: 贪心算法"></a>方法1: 贪心算法</h3><ul><li>遍历数组, 得到每个字母最后出现的位置, 记录在 hashtable 中</li><li>再次遍历数组, 设置两个标志 <code>start = end = 0</code> , 分别代表一个当前片段的起始位置和当前字母最后出现的位置. 在遍历的过程中, 更新 <code>end = max(end, end_x)</code> , 其中 <code>end_x</code> 为hashtable中记录的字母位置(即最后出现的位置)</li><li>如果当前字母的位置等于 <code>end</code>, 那么将此片段长度 <strong><code>(end - start + 1)</code></strong> 添加到返回结果中, 同时更新start的值到下一个片段 <code>start = end + 1</code></li></ul><p>上述做法使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; partitionLabels(string S) &#123;            int last_position_array[26];            for(int i=0;i&lt;S.size();++i)&#123;                last_position_array[S[i] - &#39;a&#39;] = i;            &#125;            int start =0, end = 0;            vector&lt;int&gt; res;            for(int i=0; i&lt;S.size(); ++i)&#123;                end = max(end, last_position_array[S[i] - &#39;a&#39;]);                if(i == end)&#123;                    res.push_back(end - start + 1);                    start = end + 1;                &#125;            &#125;            return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210324092412.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code> , 只需遍历两次数组</li><li>空间复杂度: <code>O()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day12</title>
      <link href="/2021/03/17/leetcode-day12/"/>
      <url>/2021/03/17/leetcode-day12/</url>
      
        <content type="html"><![CDATA[<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="[452] 用最少数量的箭引爆气球"></a>[452] 用最少数量的箭引爆气球</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/</a></p><ul><li>algorithms</li><li>Medium (50.95%)</li><li>Likes:    366</li><li>Dislikes: -</li><li>Total Accepted:    67.6K</li><li>Total Submissions: 133.8K</li><li>Testcase Example:  ‘[[10,16],[2,8],[1,6],[7,12]]’</li></ul><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x</code><sub><code>start</code>，</sub><code>x</code><sub><code>end</code>，</sub> 且满足  <code>x<sub>start</sub> ≤ x ≤ x</code><sub><code>end</code>，</sub>则该气球会被引爆<sub>。</sub>可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [x<sub>start</sub>,x<sub>end</sub>]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>points = [[10,16],[2,8],[1,6],[7,12]]<strong>输出：</strong>2<strong>解释：</strong>对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>points = [[1,2],[3,4],[5,6],[7,8]]<strong>输出：</strong>4</pre><p><strong>示例 3：</strong></p><pre><strong>输入：</strong>points = [[1,2],[2,3],[3,4],[4,5]]<strong>输出：</strong>2</pre><p><strong>示例 4：</strong></p><pre><strong>输入：</strong>points = [[1,2]]<strong>输出：</strong>1</pre><p><strong>示例 5：</strong></p><pre><strong>输入：</strong>points = [[2,3],[2,3]]<strong>输出：</strong>1</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>0 <= points.length <= 10<sup>4</sup></code></li>    <li><code>points[i].length == 2</code></li>    <li><code>-2<sup>31</sup> <= x<sub>start</sub> < x<sub>end</sub> <= 2<sup>31</sup> - 1</code></li></ul><h3 id="方法1-排序-贪心算法"><a href="#方法1-排序-贪心算法" class="headerlink" title="方法1: 排序 + 贪心算法"></a>方法1: 排序 + 贪心算法</h3><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210323210413.png"></p><p>该箭可一直向右移动, 直至蓝色气球右边界, 因此箭能移动的前提是 <strong>保证原本被引爆的气球仍会被引爆</strong> , 所以 <strong>一定存在一种最优（射出的箭数最小）的方法，使得每一支箭的射出位置都恰好对应着某一个气球的右边界。</strong> , 而这只箭的位置, 一定在 <strong>蓝色气球右边界</strong> , 这是局部最优解, 去除掉已经射爆的气球, 重复此方法, 则可找到最优解. </p><p>思路:    </p><ul><li>将数组按右侧区间升序排列</li><li>将最左侧气球设置为标志气球, 取其右侧位置 <code>y[i]</code> 与后面的气球的左侧位置 <code>x[j]</code> 做对比, 若 <code>y[i] &gt;= x[j]</code> , 则气球可被射爆; 若出现 <code>y[i] &lt; x[j]</code> 表示当前箭射不到该气球, 则将该气球设置为标志气球, 进行下一轮比较即可</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;            if(points.empty())&#123;                return 0;            &#125;            sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;                    return a[1] &lt; b[1];                    &#125;);            vector&lt;int&gt; point = points[0];            int count = 1;            for(int i=1; i &lt; points.size(); ++i)&#123;                if(point[1] &lt; points[i][0])&#123;                    point = points[i];                    count++;                &#125;            &#125;            return count;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210323212043.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(nlogn)</code>, 排序为 <code>O(nlogn)</code> , 再进行一次遍历 <code>O(n)</code></li><li>空间复杂度: <code>O(logn)</code>, 排序所使用的栈空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day11</title>
      <link href="/2021/03/16/leetcode-day11/"/>
      <url>/2021/03/16/leetcode-day11/</url>
      
        <content type="html"><![CDATA[<h2 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="[605] 种花问题"></a>[605] 种花问题</h2><p><a href="https://leetcode-cn.com/problems/can-place-flowers/description/">https://leetcode-cn.com/problems/can-place-flowers/description/</a></p><ul><li>algorithms</li><li>Easy (34.14%)</li><li>Likes:    322</li><li>Dislikes: -</li><li>Total Accepted:    84.3K</li><li>Total Submissions: 249.4K</li><li>Testcase Example:  ‘[1,0,0,0,1]\n1’</li><li>Source Code:       605.can-place-flowers.cpp</li></ul><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组  <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code><strong> </strong>，能否在不打破种植规则的情况下种入 <code>n</code><strong> </strong>朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 1<strong>输出：</strong>true</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>flowerbed = [1,0,0,0,1], n = 2<strong>输出：</strong>false</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>1 <= flowerbed.length <= 2 * 10<sup>4</sup></code></li>    <li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code></li>    <li><code>flowerbed</code> 中不存在相邻的两朵花</li>    <li><code>0 <= n <= flowerbed.length</code></li></ul><h3 id="方法1-跳格法"><a href="#方法1-跳格法" class="headerlink" title="方法1: 跳格法"></a>方法1: 跳格法</h3><p>该方法仅需一次遍历, 可在不遍历完的情况下得出答案</p><p>思路如下:</p><ul><li>遍历数组, 若 <code>index</code> 为1, 则往后跳两格</li><li>若 <code>index</code> 为0, 由于上一条操作可得, <code>index-1</code> 一定为0, 则需要判断 <code>index+1</code> 的值<ul><li>当 <code>index</code> 为最后一位, 可直接种花, 无需其他判断</li><li><code>index+1</code> 为0, 则可以种花, 可以将 <code>index</code> 置为1, 后续按照第一条进行处理</li><li><code>index+1</code> 为1, 不可种花, 向后跳三格</li></ul></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;            if(n == 0)&#123;                return true;            &#125;            int size = flowerbed.size();            for(int i=0; i&lt;size;)&#123;                if(flowerbed[i] == 1)&#123;                    i += 2;                &#125;else if(i == size - 1 || flowerbed[i+1] == 0)&#123;                    // 若在最后一个则直接可以种                    n--;                    if(n == 0)&#123;                        return n == 0;                    &#125;                    i+=2;                &#125;else&#123;                    i+=3;                &#125;            &#125;            return n == 0;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210323180355.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 仅需一次遍历</li><li>空间复杂度: <code>O(1)</code></li></ul><h3 id="方法2-前后种花，瞬间秒杀"><a href="#方法2-前后种花，瞬间秒杀" class="headerlink" title="方法2:前后种花，瞬间秒杀"></a>方法2:前后种花，瞬间秒杀</h3><p><strong>如果存在连续的3个0, 则一定能种花</strong></p><p>若直接进行讨论, 需要进行复杂的边界问题讨论, 如</p><p><code>[0, 0, 1, 0, 0, 1, 0, 0]</code> 虽然首尾都只有2个0, 但首尾是可以种花的<br>,所以需要对首尾进行讨论</p><p>其实不用这样, 可以直接在数组两端添加一个 <code>0</code> 来解决这个问题<br><code>[0, 0, 1, 0, 0, 1, 0, 0]</code> -&gt; <code>[0, 0, 0, 1, 0, 0, 1, 0, 0, 0]</code> </p><p>这样就可以统一讨论</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;            if(n == 0)&#123;                return true;            &#125;            flowerbed.insert(flowerbed.begin(), 0);            flowerbed.insert(flowerbed.end(), 0);            for(int i = 1; i &lt; flowerbed.size() - 1; i++)&#123;                if(flowerbed[i-1] == 0 &amp;&amp; flowerbed[i] == 0 &amp;&amp; flowerbed[i+1] == 0)&#123;                    n--;                    flowerbed[i] = 1;                    if(n == 0)&#123;                        return n == 0;                    &#125;                &#125;            &#125;            return n == 0;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210323183030.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 仅需一次遍历</li><li>空间复杂度: <code>O(1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day10</title>
      <link href="/2021/03/15/leetcode-day10/"/>
      <url>/2021/03/15/leetcode-day10/</url>
      
        <content type="html"><![CDATA[<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="[435] 无重叠区间"></a>[435] 无重叠区间</h2><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/description/">https://leetcode-cn.com/problems/non-overlapping-intervals/description/</a></p><ul><li>algorithms</li><li>Medium (49.21%)</li><li>Likes:    378</li><li>Dislikes: -</li><li>Total Accepted:    61.4K</li><li>Total Submissions: 124.8K</li><li>Testcase Example:  ‘[[1,2]]’</li><li>Source Code:       435.non-overlapping-intervals.cpp</li></ul><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ol>    <li>可以认为区间的终点总是大于它的起点。</li>    <li>区间 [1,2] 和 [2,3] 的边界相互&ldquo;接触&rdquo;，但没有相互重叠。</li></ol><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [ [1,2], [2,3], [3,4], [1,3] ]<strong>输出:</strong> 1<strong>解释:</strong> 移除 [1,3] 后，剩下的区间没有重叠。</pre><p><strong>示例 2:</strong></p><pre><strong>输入:</strong> [ [1,2], [1,2], [1,2] ]<strong>输出:</strong> 2<strong>解释:</strong> 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</pre><p><strong>示例 3:</strong></p><pre><strong>输入:</strong> [ [1,2], [2,3] ]<strong>输出:</strong> 0<strong>解释:</strong> 你不需要移除任何区间，因为它们已经是无重叠的了。</pre><h3 id="方法1-贪心算法"><a href="#方法1-贪心算法" class="headerlink" title="方法1: 贪心算法"></a>方法1: 贪心算法</h3><p>要选择保留区间, 区间的结尾十分重要. 相同的起始空间, 选择的区间结尾越小, 余留给其他区间的空间就越大, 则可保留更多的空间. 首先确定最左侧区间, 再选择与之不相交的区间中右区间最小的区间, 将该区间当作余下空间的最左侧空间, 重复此操作即可. 所以贪心策略为: 优先保留 <strong>结尾小</strong> 且 <strong>不相交</strong> 的区间. </p><ul><li>首先按照右区间增序排序(使用Lambda)</li><li>每次选择结尾小且和前一区间不相交的区间</li></ul><p>注意: </p><ul><li><p>排序后最左侧出现 <code>[[1, 4], [2, 4], [3, 4]...]</code> 该如何选择?</p><p>  任选一个即可, 我选择的是第一项, 后面与其相交的会被舍去</p></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;            if(intervals.empty())&#123;                return 0;            &#125;            int size = intervals.size();            sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)&#123;                    return a[1] &lt; b[1];                    &#125;);            int total = 0, prev = intervals[0][1];            for(int i = 1; i &lt; size; ++i)&#123;                if(intervals[i][0] &lt; prev)&#123;                    ++total;                &#125;                else&#123;                    prev = intervals[i][1];                &#125;            &#125;            return total;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210323170045.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(nlogn)</code>, 需要 <code>O(nlogn)</code> 进行排序, 再需要 <code>O(n)</code> 进行遍历</li><li>空间复杂度: <code>O(logn)</code>, 排序所需要的栈空间</li></ul><h3 id="方法2-动态规划"><a href="#方法2-动态规划" class="headerlink" title="方法2: 动态规划"></a>方法2: 动态规划</h3><p>待完成</p>]]></content>
      
      
      <categories>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day9</title>
      <link href="/2021/03/14/leetcode-day9/"/>
      <url>/2021/03/14/leetcode-day9/</url>
      
        <content type="html"><![CDATA[<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法:"></a>贪心算法:</h3><ul><li>采用贪心的策略, 保证每次操作都是局部最优的, 从而使最后得到的结果是全局最优的</li><li>全局结果是局部结果的简单求和, 且局部结果互不相干, 因此局部最优策略也是全局最优策略</li></ul><h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="[135] 分发糖果"></a>[135] 分发糖果</h3><p><a href="https://leetcode-cn.com/problems/candy/description/">https://leetcode-cn.com/problems/candy/description/</a></p><ul><li>algorithms</li><li>Hard (48.16%)</li><li>Likes:    508</li><li>Dislikes: -</li><li>Total Accepted:    68.3K</li><li>Total Submissions: 141.8K</li><li>Testcase Example:  ‘[1,0,2]’</li><li>Source Code:       135.candy.cpp</li></ul><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul>    <li>每个孩子至少分配到 1 个糖果。</li>    <li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p> </p><p><strong>示例 1：</strong></p><pre><strong>输入：</strong>[1,0,2]<strong>输出：</strong>5<strong>解释：</strong>你可以分别给这三个孩子分发 2、1、2 颗糖果。</pre><p><strong>示例 2：</strong></p><pre><strong>输入：</strong>[1,2,2]<strong>输出：</strong>4<strong>解释：</strong>你可以分别给这三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><ul><li><p>将所有孩子的糖果数量置为1</p></li><li><p>从左至右遍历评分数组, 如果左侧评分小于右侧, 则将  <strong>右侧糖果数量改为左侧糖果数量+1</strong> </p></li><li><p>从右往左遍历评分数组, 如果左侧评分大于右侧, 则 <strong>选择左侧评分与右侧评分+1的最大值</strong></p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>1</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td>j-1</td><td>j</td><td></td></tr></tbody></table><p>  若出现以上情况, 直接对 <code>j-1</code> 项 +1 或等于  <code>j</code> 项+1, 会造成错误</p></li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int candy(vector&lt;int&gt;&amp; ratings) &#123;        int size = ratings.size();        if(size &lt; 2)&#123;            return size;        &#125;        vector&lt;int&gt; num(size, 1);        for(int i = 0; i &lt; size - 1; ++i)&#123;            if(ratings[i] &lt; ratings[i+1])&#123;                num[i+1] = num[i] + 1;            &#125;        &#125;        for(int j = size - 1; j &gt; 0; --j)&#123;            if(ratings[j] &lt; ratings[j-1])&#123;                num[j-1] = max(num[j-1], num[j] + 1);            &#125;        &#125;        return accumulate(num.begin(), num.end(), 0);    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210323125046.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code> , 只需遍历两次</li><li>空间复杂度: <code>O(n)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day8</title>
      <link href="/2021/03/13/leetcode-day8/"/>
      <url>/2021/03/13/leetcode-day8/</url>
      
        <content type="html"><![CDATA[<h3 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a>剑指 Offer 09. 用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code> 操作返回 -1 )</p><p>示例 1：</p><pre><code>输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1]</code></pre><p>示例 2：</p><pre><code>输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]</code></pre><p>提示：</p><ul><li><code>1 &lt;= values &lt;= 10000</code></li><li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li></ul><p>解题思路:</p><ul><li><code>appendTail</code> , 可直接执行栈的 <code>push</code> 操作</li><li><code>deleteHead</code> , 可将栈翻转, 再执行出栈 <code>pop</code> 操作</li></ul><p>栈的翻转可利用两个栈来实现, 具体操作是: 对栈A执行出栈操作, 将出栈元素在栈B入栈, 直至栈A为空</p><pre><code class="line-numbers language-cpp">class CQueue &#123;public:    stack&lt;int&gt; A, B;    CQueue() &#123;&#125;    void appendTail(int value) &#123;        A.push(value);    &#125;    int deleteHead() &#123;        if(!B.empty())&#123;            int tmp = B.top();            B.pop();            return tmp;        &#125;        if(A.empty())&#123;            return -1;        &#125;        while(!A.empty())&#123;            int tmp = A.top();            A.pop();            B.push(tmp);        &#125;        int tmp = B.top();        B.pop();        return tmp;    &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319174210.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>appendTail</code> 复杂度为 $O(1)$ , <code>deleteHead</code> 执行 N 次共需执行N个元素的翻转</li><li>空间复杂度: $O(N)$ , 最坏情况为栈A和栈B都有N个元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day7</title>
      <link href="/2021/03/12/leetcode-day7/"/>
      <url>/2021/03/12/leetcode-day7/</url>
      
        <content type="html"><![CDATA[<h2 id="706-设计哈希映射"><a href="#706-设计哈希映射" class="headerlink" title="[706] 设计哈希映射"></a>[706] 设计哈希映射</h2><p><a href="https://leetcode-cn.com/problems/design-hashmap/description/">https://leetcode-cn.com/problems/design-hashmap/description/</a></p><ul><li>algorithms</li><li>Easy (58.60%)</li><li>Likes:    124</li><li>Dislikes: -</li><li>Total Accepted:    22.7K</li><li>Total Submissions: 38.6K</li><li>Testcase Example:  ‘[“MyHashMap”,”put”,”put”,”get”,”get”,”put”,”get”,”remove”,”get”]\n’ +<br>‘[[],[1,1],[2,2],[1],[3],[2,1],[2],[2],[2]]’</li></ul><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 <code>MyHashMap</code> 类：</p><ul>    <li><code>MyHashMap()</code> 用空映射初始化对象</li>    <li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>    <li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>    <li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li></ul><p> </p><p><strong>示例：</strong></p><pre><strong>输入</strong>：["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"][[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]<strong>输出</strong>：[null, null, null, 1, -1, null, 1, null, -1]<strong>解释</strong>：MyHashMap myHashMap = new MyHashMap();myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>0 <= key, value <= 10<sup>6</sup></code></li>    <li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li></ul><p> </p><p><strong>进阶：</strong>你能否不使用内置的 HashMap 库解决此问题？</p><h3 id="方法1-暴力一维数组"><a href="#方法1-暴力一维数组" class="headerlink" title="方法1: 暴力一维数组"></a>方法1: 暴力一维数组</h3><p>适用于key范围较小的情况</p><pre><code class="line-numbers language-cpp">class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            const int N = 1000001;            data = vector&lt;int&gt;(N, -1); //直接初始化为-1    &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            data[key] = value;    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            return data[key];    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            data[key] = -1;    &#125;private:        vector&lt;int&gt; data;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319103752.png"></p><h3 id="方法2-二维数组-稀疏数组节省空间"><a href="#方法2-二维数组-稀疏数组节省空间" class="headerlink" title="方法2: 二维数组, 稀疏数组节省空间"></a>方法2: 二维数组, 稀疏数组节省空间</h3><p>通过设置两个hash值来避免冲突</p><pre><code class="line-numbers language-cpp">class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            data.resize(N);    &#125;        auto getHashValue1(int key)&#123;            return key % N;        &#125;        auto getHashValue2(int key)&#123;            return key / N;        &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            auto hashkey1 = getHashValue1(key);            auto hashkey2 = getHashValue2(key);            if(data[hashkey1].empty())&#123;                data[hashkey1].resize(N, -1);            &#125;            data[hashkey1][hashkey2] = value;    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            auto hashkey1 = getHashValue1(key);            auto hashkey2 = getHashValue2(key);            if(data[hashkey1].empty())&#123;                return -1;            &#125;            return data[hashkey1][hashkey2];    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            auto hashkey1 = getHashValue1(key);            auto hashkey2 = getHashValue2(key);            if(!data[hashkey1].empty())&#123;                data[hashkey1][hashkey2] = -1;            &#125;    &#125;private:        const int N = 1001;        vector&lt;vector&lt;int&gt;&gt; data;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319110154.png"></p><h3 id="方法3-链地址法-无头节点"><a href="#方法3-链地址法-无头节点" class="headerlink" title="方法3: 链地址法 无头节点"></a>方法3: 链地址法 无头节点</h3><p>这是一种处理冲突的方法, 具体原理如图:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/IMG_3726.JPG"></p><p>此方法不使用头节点(dummy head node), 将所有关键字为同义词的记录存储在同一线性链表中, 减小空间开销, 但每次都需要判断是否为空节点</p><p>需注意当移除键值对时, 对于头节点与非头节点要分开讨论</p><pre><code class="line-numbers language-cpp">struct MyListNode&#123;    int key;     int val;    MyListNode* next;    MyListNode() : key(-1), val(-1), next(nullptr) &#123;&#125;    MyListNode(int _key, int _val) : key(_key), val(_val), next(nullptr) &#123;&#125;&#125;;class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            data.resize(N);    &#125;        auto getHashValue(int key)&#123;            return key % N;        &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            if(head==nullptr)&#123;                head = new MyListNode(key, value);                return;            &#125;            auto p = head;            auto tail = p;            // add value which has been added            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    p-&gt;val = value;                    return;                &#125;                tail = p;                p = p-&gt;next;            &#125;            // add new value            tail-&gt;next = new MyListNode(key, value);    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            if(head==nullptr)&#123;                return -1;            &#125;            auto p = head;            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    return p-&gt;val;                &#125;                p = p-&gt;next;            &#125;            return -1;    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            if(head==nullptr)&#123;                return;            &#125;            auto p = head;            MyListNode* prev = nullptr;            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    // remove head                    if(prev == nullptr)&#123;                        auto dummy = head;                        head = head-&gt;next; // nullptr                        dummy-&gt;next = nullptr;                        delete dummy;                    &#125;                    else&#123;                        prev-&gt;next = p-&gt;next;                        p-&gt;next = nullptr;                        delete p;                    &#125;                    return;                &#125;                prev = p;                p = p-&gt;next;            &#125;    &#125;private:        const int N = 1001;        vector&lt;MyListNode*&gt; data;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319120829.png"></p><h3 id="方法4-链地址法-有头节点"><a href="#方法4-链地址法-有头节点" class="headerlink" title="方法4: 链地址法 有头节点"></a>方法4: 链地址法 有头节点</h3><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/IMG_3726.JPG"></p><p>头节点一直存在, 省去了对头节点的判断, 但略占空间</p><pre><code class="line-numbers language-cpp">struct MyListNode&#123;    int key;     int val;    MyListNode* next;    MyListNode() : key(-1), val(-1), next(nullptr) &#123;&#125;    MyListNode(int _key, int _val) : key(_key), val(_val), next(nullptr) &#123;&#125;&#125;;class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            data.resize(N, new MyListNode());    &#125;        auto getHashValue(int key)&#123;            return key % N;        &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            auto p = head;            auto tail = p;            // add value which has been added            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    p-&gt;val = value;                    return;                &#125;                tail = p;                p = p-&gt;next;            &#125;            // add new value            tail-&gt;next = new MyListNode(key, value);    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            auto p = head;            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    return p-&gt;val;                &#125;                p = p-&gt;next;            &#125;            return -1;    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            auto p = head;            MyListNode* prev = nullptr;            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    prev-&gt;next = p-&gt;next;                    p-&gt;next = nullptr;                    delete p;                    return;                &#125;                prev = p;                p = p-&gt;next;            &#125;    &#125;private:        const int N = 1001;        vector&lt;MyListNode*&gt; data;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319154530.png"></p><h3 id="方法5-开放地址法-线性探测"><a href="#方法5-开放地址法-线性探测" class="headerlink" title="方法5: 开放地址法 线性探测"></a>方法5: 开放地址法 线性探测</h3><p>算法原理: </p><p>$$<br>H_i = (H(key) + d_i) \space MOD \space m  \quad i=1, 2, \cdots, k(k&lt;=m-1)<br>$$</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/IMG_3729.JPG"></p><pre><code class="line-numbers language-cpp">class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            hashtable = vector&lt;pair&lt;int, int&gt;&gt;(N, &#123;-1, -1&#125;);    &#125;        auto getHashValue(int key)&#123;            int k = key % N;            while(hashtable[k].first != key &amp;&amp; hashtable[k].first != -1)&#123;                k = (k + 1) % N;            &#125;            return k;         &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            auto k = getHashValue(key);            hashtable[k] = &#123;key, value&#125;;    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            auto k = getHashValue(key);            if(hashtable[k].first == -1)&#123;                return -1;            &#125;            return hashtable[k].second;    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            auto k = getHashValue(key);            if(hashtable[k].first != -1)&#123;                hashtable[k].first = -2;            &#125;    &#125;private:        const static int N = 20011;        vector&lt;pair&lt;int, int&gt;&gt; hashtable;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319162846.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day6</title>
      <link href="/2021/03/11/leetcode-day6/"/>
      <url>/2021/03/11/leetcode-day6/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><pre><code class="line-numbers language-cpp">输入：head = [1,3,2]输出：[2,3,1]</code></pre><p>限制：</p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h3 id="方法1-递归"><a href="#方法1-递归" class="headerlink" title="方法1: 递归"></a>方法1: 递归</h3><p>先进行递归至链表尾部, 在回溯的时候, 将值添加入数组, 即可实现逆序输出</p><ul><li>终止条件: 指针 <code>head == None</code> , 代表在链表尾部</li><li>递归进行: <code>head = head-&gt;next</code></li><li>回溯阶段: 将 <code>head-&gt;val</code> 添加至返回数组</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; reversePrint(ListNode* head) &#123;        reverse_array(head);        return res;    &#125;private:    vector&lt;int&gt; res;    void reverse_array(ListNode* head)&#123;        if(head == nullptr) return;               reverse_array(head-&gt;next);        res.push_back(head-&gt;val);        &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311120222.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(N)</code>,  遍历链表，递归N次。</li><li>空间复杂度:    <code>O(N)</code>, 递归需要 <code>O(N)</code> 的栈空间</li></ul><h3 id="方法2-辅助栈法"><a href="#方法2-辅助栈法" class="headerlink" title="方法2: 辅助栈法"></a>方法2: 辅助栈法</h3><p>链表只能从前向后, 而又需要倒序输出, 则可以使用栈来解决</p><ul><li>遍历链表, 将链表值添加入栈中</li><li>将栈顶元素添加至输出数组, 执行出栈操作</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; reversePrint(ListNode* head) &#123;        stack&lt;int&gt; st;        while(head != nullptr)&#123;            st.push(head-&gt;val);            head = head-&gt;next;        &#125;        vector&lt;int&gt; res;        while(!st.empty())&#123;            res.push_back(st.top());            st.pop();        &#125;        return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311162411.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(N)</code>, 入栈出栈时间总和为 <code>O(N)</code></li><li>空间复杂度:  <code>O(N)</code>, </li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day5</title>
      <link href="/2021/03/10/leetcode-day5/"/>
      <url>/2021/03/10/leetcode-day5/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a> </p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><pre><code class="line-numbers language-bash">输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p>限制：</p><p><code>0 &lt;= s 的长度 &lt;= 10000</code></p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h3><p>设置一个新的数组, 将结果存到新数组上.</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    string replaceSpace(string s) &#123;        string res;        for(auto &amp;e: s)&#123;            if(e == &#39; &#39;)&#123;                res += &quot;%20&quot;;            &#125;            else&#123;                res += e;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311114319.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code></li><li>空间复杂度: ‘O(n)’, 需要额外数组来存储</li></ul><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2:"></a>方法2:</h3><p>不创建新数组, 原地扩充</p><p>c++可以通过 <code>array.resize()</code> 来重置数组长度, 利用这一点, 则无需新建数组</p><ul><li>首先遍历原始数组, 统计空格数</li><li>重置数组长度,  新长度为原始长度 + 2 * 空格数</li><li>倒序遍历数组, 遇到空格替换, 否则不变, 直接移到相应位置</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    string replaceSpace(string s) &#123;        int count = 0, len = s.size();        for(auto &amp;e: s)&#123;            if(e == &#39; &#39;)&#123;                count++;            &#125;        &#125;        s.resize(len + 2 * count);        for(int i = len - 1, j = s.size() - 1; i &lt; j; i--,j--)&#123;            if(s[i] == &#39; &#39;)&#123;                s[j-2] = &#39;%&#39;;                s[j-1] = &#39;2&#39;;                s[j] = &#39;0&#39;;                j -= 2;            &#125;            else&#123;                s[j] = s[i];            &#125;           &#125;          return s;       &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311120222.png"></p><p>复杂度分析: </p><ul><li>时间复杂度:  <code>O(n)</code>  两次遍历数组</li><li>空间复杂度:  <code>O(1)</code> 无额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day4</title>
      <link href="/2021/03/09/leetcode-day4/"/>
      <url>/2021/03/09/leetcode-day4/</url>
      
        <content type="html"><![CDATA[<p>[136] 只出现一次的数字</p><p><a href="https://leetcode-cn.com/problems/single-number/description/">https://leetcode-cn.com/problems/single-number/description/</a></p><ul><li>algorithms</li><li>Easy (70.80%)</li><li>Likes:    1743</li><li>Dislikes: -</li><li>Total Accepted:    348.9K</li><li>Total Submissions: 491.3K</li><li>Testcase Example:  ‘[2,2,1]’</li><li>Source Code:       136.single-number.cpp</li></ul><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [2,2,1]<strong>输出:</strong> 1</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> [4,1,2,1,2]<strong>输出:</strong> 4</pre><p>方法一: 位运算</p><p>异或运算性质:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311101301.png"></p><p>故将数组内元素依次进行异或运算, 最终的结果即为出现一次的数.</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;            int res = 0;            for(auto e: nums)&#123;                res ^= e;            &#125;            return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311101604.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 与nums的大小有关, 相当于遍历一遍数组</li><li>空间复杂度: <code>O(1)</code>, 除输出数组外,无额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day3</title>
      <link href="/2021/03/08/leetcode-day3/"/>
      <url>/2021/03/08/leetcode-day3/</url>
      
        <content type="html"><![CDATA[<h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="[338] 比特位计数"></a>[338] 比特位计数</h2><p><a href="https://leetcode-cn.com/problems/counting-bits/description/">https://leetcode-cn.com/problems/counting-bits/description/</a></p><ul><li>algorithms</li><li>Medium (76.57%)</li><li>Likes:    664</li><li>Dislikes: -</li><li>Total Accepted:    115.6K</li><li>Total Submissions: 146.3K</li><li>Testcase Example:  ‘2’</li><li>Source Code:       338.counting-bits.cpp</li></ul><p>给定一个非负整数&nbsp;<strong>num</strong>。对于&nbsp;<strong>0 &le; i &le; num </strong>范围中的每个数字&nbsp;<strong>i&nbsp;</strong>，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><pre><strong>输入: </strong>2<strong>输出: </strong>[0,1,1]</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入: </strong>5<strong>输出: </strong><code>[0,1,1,2,1,2]</code></pre><p><strong>进阶:</strong></p><ul>    <li>给出时间复杂度为<strong>O(n*sizeof(integer))</strong>的解答非常容易。但你可以在线性时间<strong>O(n)</strong>内用一趟扫描做到吗？</li>    <li>要求算法的空间复杂度为<strong>O(n)</strong>。</li>    <li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的&nbsp;<strong>__builtin_popcount</strong>）来执行此操作。</li></ul><p>方法1: </p><p>从0到num直接计算1的个数, 计算方法用到了上面的 布赖恩·克尼根算法</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int count_ones(int x)&#123;        int count = 0;        while(x &gt; 0)&#123;            x &amp;= (x - 1);            count++;        &#125;        return count;    &#125;    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            for(int x=0; x &lt;= num; x++)&#123;                result[x] = count_ones(x);            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307234957.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(k*num)</code> , k 为int整型长度(32), </li><li>空间复杂度: <code>O(1)</code> , 除了返回的数组以外，空间复杂度为常数。</li></ul><p>方法2: 动态规划 最高有效位</p><p>对于整数x, 存在一个最大整数y, 且y是2的整数幂, 令 <code>z=y-x</code>, 用 <code>bits[x]</code> 来表示x的’一比特数’, 则 <code>bit[x] = bit[z] + 1 </code>, 这里加的 <code>1</code> 是最高位的1.</p><table><thead><tr><th>x</th><th>1</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>y</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>z=x-y</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p><strong>正整数 <code>y</code> 是 <code>2</code> 的整数次幂，当且仅当 <code>y&amp;(y-1)=0 </code></strong></p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            int highbit = 0;            for(int x=1; x &lt;= num; x++)&#123;                if((x &amp; (x - 1)) == 0)&#123;                    highbit = x;                &#125;                result[x] = result[x - highbit] + 1;            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210308113259.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(num)</code> , 只需要 <code>O(1)</code> 的时间计算</li><li>空间复杂度:  <code>O(1)</code>, 为常数</li></ul><p>方法3: 动态规划 最低有效位</p><p>将x右移一位可得到 $\dfrac{x}{2}$ 的值,</p><table><thead><tr><th>x</th><th>1</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>x/2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p> 反向考虑:</p><p>$$<br>bit[x] = bit[\dfrac{x}{2}] + bit[x]最低位<br>$$</p><p>据此, 合并奇偶情况:</p><p>$$<br>bit[x] = bit[\dfrac{x}{2}] + (x &amp; 1)<br>$$</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            int highbit = 0;            for(int x=1; x &lt;= num; x++)&#123;                result[x] = result[x&gt;&gt;1] + (x &amp; 1);            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210308115024.png"></p><p>方法4: 动态规划 最低设置位</p><p>定义正整数 <code>x</code> 的「最低设置位」为 <code>x</code> 的二进制表示中的最低的 <code>1</code> 所在位。</p><table><thead><tr><th>1</th><th>0</th><th>1</th><th>0</th></tr></thead></table><p> 最低设置位是 <code>2</code></p><p> 令 <code>y=x&amp;(x-1)</code> , 则y是去除最低设置位后的数, 则 <code>bits[x]=bits[y]+1</code></p><table><thead><tr><th>x</th><th>1</th><th>0</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>x-1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>x&amp;(x-1)</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            int highbit = 0;            for(int x=1; x &lt;= num; x++)&#123;                result[x] = result[x&amp;(x-1)] +1;            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210308120402.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day2</title>
      <link href="/2021/03/07/leetcode-day2/"/>
      <url>/2021/03/07/leetcode-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="[461] 汉明距离"></a>[461] 汉明距离</h2><p><a href="https://leetcode-cn.com/problems/hamming-distance/description/">https://leetcode-cn.com/problems/hamming-distance/description/</a></p><ul><li>algorithms</li><li>Easy (78.70%)</li><li>Likes:    379</li><li>Dislikes: -</li><li>Total Accepted:    97.6K</li><li>Total Submissions: 123.7K</li><li>Testcase Example:  ‘1\n4’</li><li>Source Code:       461.hamming-distance.cpp</li></ul><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p><p><strong>注意：</strong><br />0 &le; <code>x</code>, <code>y</code> &lt; 2<sup>31</sup>.</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> x = 1, y = 4<strong>输出:</strong> 2<strong>解释:</strong>1   (0 0 0 1)4   (0 1 0 0)       &uarr;   &uarr;上面的箭头指出了对应二进制位不同的位置。</pre><p>方法1:</p><p>计算x与y的XOR值, 值与1进行 <code>&amp;</code> 操作, 结果为1则x与y在此位值不同, 汉明距离+1, 再进行移位操作, 逐位计算即可.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307215223.png"></p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int hammingDistance(int x, int y) &#123;            int z = x ^ y;            int distance = 0;            while(z)&#123;                distance += z &amp; 1;                z = z &gt;&gt; 1;            &#125;            return distance;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307230112.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: O(1), 整数长度固定, 最高32位 </li><li>空间复杂度: O(1), 恒定空间</li></ul><p>方法2: 布赖恩·克尼根算法</p><p>逐位移动，逐位比较边缘位置是否为 1。利用布莱恩·克尼根算法, 遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多. </p><p>当 <code>num &amp; (num - 1)</code> 运算时, 最右边等于1的一位会被抹除</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307225134.png"></p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int hammingDistance(int x, int y) &#123;            int z = x xor y;            int distance = 0;            while(z)&#123;                distance += 1;                z = z &amp; (z - 1);            &#125;            return distance;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307230254.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(1)</code>, 实际进行了更少的迭代</li><li>空间复杂度:  <code>O(1)</code>, 恒定空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day1</title>
      <link href="/2021/03/06/leetcode-day1/"/>
      <url>/2021/03/06/leetcode-day1/</url>
      
        <content type="html"><![CDATA[<p>[1] Two Sum  </p><p><a href="https://leetcode.com/problems/two-sum/description/">https://leetcode.com/problems/two-sum/description/</a></p><ul><li>algorithms</li><li>Easy (46.37%)</li><li>Likes:    19171</li><li>Dislikes: 682</li><li>Total Accepted:    3.8M</li><li>Total Submissions: 8.3M</li><li>Testcase Example:  ‘[2,7,11,15]\n9’</li></ul><p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> nums = [2,7,11,15], target = 9<strong>Output:</strong> [0,1]<strong>Output:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> nums = [3,2,4], target = 6<strong>Output:</strong> [1,2]</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> nums = [3,3], target = 6<strong>Output:</strong> [0,1]</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>    <li><code>2 &lt;= nums.length &lt;= 10<sup>3</sup></code></li>    <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>    <li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>    <li><strong>Only one valid answer exists.</strong></li></ul><p><strong>Approach 1:</strong> Brute Force</p><p>Loop through each element <code>x</code>  and find if there is another value that equals to <code>target - x</code> </p><pre><code class="line-numbers language-c++">class Solution &#123;public:        vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;            vector&lt;int&gt; answer;            int i, j;            for(i = 0; i&lt; nums.size() - 1; i++)&#123;                for(j = i + 1; j &lt; nums.size(); j++)&#123;                    int diff = target - nums[j];                    if(nums[i] == diff)&#123;                        answer.push_back(i);                        answer.push_back(j);                    &#125;                &#125;            &#125;            return answer;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210211230613.png"></p><p><strong>Complexity Analysis</strong> </p><ul><li>Time Complexity: $O(n^2)$</li><li>Space Complexity: $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COC</title>
      <link href="/2021/03/02/coc/"/>
      <url>/2021/03/02/coc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FZF</title>
      <link href="/2021/02/28/fzf/"/>
      <url>/2021/02/28/fzf/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/junegunn/fzf">fzf</a> 是一个非常强大的终端文件模糊查找神器,在mac下也有许多优秀的工具,比如mac自带的    <code>spotlight</code> , <a href="https://www.alfredapp.com/">Alfred</a> ,这些工具在桌面环境下非常好用,也十分漂亮,但我的工作一般都在终端下, fzf解决了我的问题. fzf有很多优点,可移植,速度超快,最重要的是,当fzf与 <strong>zsh, ranger, vim</strong> 碰撞在一起,极大的提高了我的工作效率.    </p><h2 id="FZF"><a href="#FZF" class="headerlink" title="FZF"></a>FZF</h2><ul><li>fzf的安装非常简单,在mac下,可以使用<code>Homebrew</code>来安装:</li></ul><pre><code class="line-numbers language-bash">brew install fzf</code></pre><p>现在就可以通过 <code>fzf</code> 命令来使用fzf了</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210301101707.png"></p><p>如果你刚安装完成,你的界面跟上图不一样,没有右侧的预览窗口,别着急,这些是可以在配置文件中修改的.</p><ul><li>如果要安装    <code> key bindings</code> 和 <code>fuzzy completion</code> :</li></ul><pre><code class="line-numbers language-bash">$(brew --prefix)/opt/fzf/install</code></pre><p>一路y,则会在你的根目录下生成 <code>.fzf.bash</code> 和 <code>.fzf.zsh</code> 文件,想要配置fzf,则只需修改相应的文件即可.</p><h2 id="FZF-ZSH-AMAZING"><a href="#FZF-ZSH-AMAZING" class="headerlink" title="FZF + ZSH = AMAZING"></a>FZF + ZSH = AMAZING</h2><p>fzf的配置文件写在 <code>.fzf.zsh</code> 中, 由于我的 <code>zsh</code> 配置文件在 <code>.config/zsh</code> 目录下, 所以我将fzf的配置文件也移到此处</p><pre><code class="line-numbers language-bash">mv ~/.fzf.zsh ~/.config/zsh/fzf.zsh</code></pre><p>下面开始配置 <code>fzf.zsh</code> 文件</p><ul><li>fzf的默认搜索工具: ag</li></ul><pre><code class="line-numbers language-bash">export FZF_DEFAULT_COMMAND=&#39;ag&#39;export FZF_DEFAULT_COMMAND=&#39;ag --hidden --ignore .git -g &quot;&quot;&#39;</code></pre><p>上面两条任选其一, 第二条表示搜索到的文件包含隐藏文件,忽略 <code>.git</code> 文件</p><ul><li>模糊查找补全</li></ul><p>fzf的默认键位为 <code>**</code> ,太麻烦了,换成 <code>\</code> 就舒服多了</p><pre><code class="line-numbers language-bash">export FZF_COMPLETION_TRIGGER=&#39;\&#39;</code></pre><ul><li>预览窗口的实现</li></ul><pre><code class="line-numbers language-bash">export FZF_DEFAULT_OPTS=&#39;--bind ctrl-k:down,ctrl-i:up --preview &quot;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (ccat --color=always &#123;&#125; || highlight -O ansi -l &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&quot;&#39;</code></pre><p>结合我的vim使用习惯,我将 <code>ctrl + i</code> 设置为向上, <code>ctrl + k</code> 设置为向下</p><p>当然,还有一些其他的配置,这些都可以在fzf的文档里找到.</p><h2 id="FZF-RANGER-EXCELLENT"><a href="#FZF-RANGER-EXCELLENT" class="headerlink" title="FZF + RANGER = EXCELLENT"></a>FZF + RANGER = EXCELLENT</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/ranger.gif"></p><p>fzf 和ranger 结合可直接在ranger下进行文件搜索,直接跳转到文件所在目录</p><ul><li>首先在ranger的配置文件中设置打开fzf搜索的快捷键( <code>ctrl+f</code> )</li></ul><pre><code class="line-numbers language-bash">vim ~/.config/ranger/rc.conf// add the following linemap &lt;C-f&gt; fzf_select</code></pre><ul><li>在 <code>commands.py</code> 中添加    <code>fzf_select</code> 函数</li></ul><pre><code class="line-numbers language-python">class fzf_select(Command):    &quot;&quot;&quot;    :fzf_select    Find a file using fzf.    With a prefix argument select only directories.    See: https://github.com/junegunn/fzf    &quot;&quot;&quot;    def execute(self):        import subprocess        import os.path        if self.quantifier:            # match only directories            command=&quot;find -L . \( -path &#39;*/\.*&#39; -o -fstype &#39;dev&#39; -o -fstype &#39;proc&#39; \) -prune \            -o -type d -print 2&gt; /dev/null | sed 1d | cut -b3- | fzf +m&quot;        else:            # match files and directories            command=&quot;find -L . \( -path &#39;*/\.*&#39; -o -fstype &#39;dev&#39; -o -fstype &#39;proc&#39; \) -prune \            -o -print 2&gt; /dev/null | sed 1d | cut -b3- | fzf +m&quot;        fzf = self.fm.execute_command(command, universal_newlines=True, stdout=subprocess.PIPE)        stdout, stderr = fzf.communicate()        if fzf.returncode == 0:            fzf_file = os.path.abspath(stdout.rstrip(&#39;\n&#39;))            if os.path.isdir(fzf_file):                self.fm.cd(fzf_file)            else:                self.fm.select_file(fzf_file)</code></pre><h2 id="FZF-VIM-UNBELIVABLE"><a href="#FZF-VIM-UNBELIVABLE" class="headerlink" title="FZF + VIM = UNBELIVABLE"></a>FZF + VIM = UNBELIVABLE</h2><p><a href="https://github.com/junegunn/fzf.vim">fzf.vim</a> 是fzf为vim玩家编写的插件</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210301113521.png"></p><p><code>fzf.vim</code> 的 <a href="https://godliuyang.wang/2021/02/20/neovim/#toc-heading-8">详细配置与快捷键设置</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LINUX</title>
      <link href="/2021/02/27/linux/"/>
      <url>/2021/02/27/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><ul><li>添加用户</li></ul><pre><code class="line-numbers language-bash">sudo adduser username</code></pre><ul><li>将用户添加到sudo组</li></ul><pre><code class="line-numbers language-bash">sudo usermod -aG sudo username</code></pre><ul><li>删除用户</li></ul><pre><code class="line-numbers language-bash">sudo deluser username</code></pre><ul><li>删除用户,并删除加目录</li></ul><pre><code class="line-numbers language-bash">sudo deluser --remove-home username</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2021/02/27/git/"/>
      <url>/2021/02/27/git/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Github-Cheat-Sheet"><a href="#1-Github-Cheat-Sheet" class="headerlink" title="1. Github Cheat Sheet"></a>1. Github Cheat Sheet</h1><h2 id="配置工具"><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h2><p>对所有本地仓库的用户信息进行配置</p><ul><li>对你的commit操作设置关联的用户名</li></ul><pre><code class="line-numbers language-bash">$ git config --global user.name &quot;[name]&quot;</code></pre><ul><li>对你的commit操作设置关联的邮箱地址</li></ul><pre><code class="line-numbers language-bash">$ git config --global user.email &quot;[email address]&quot;</code></pre><ul><li>启用有帮助的彩色命令行输出</li></ul><pre><code class="line-numbers language-bash">$ git config --global color.ui auto</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是使用 Git 工作的一个重要部分。你做的任何提交都会发生在当前“checked out”到的分支上。使用<code>git status</code>查看那是哪个分支。</p><ul><li>创建一个新分支</li></ul><pre><code class="line-numbers language-bash">$ git branch [branch-name]</code></pre><ul><li>切换到指定分支并更新工作目录(working directory)</li></ul><pre><code class="line-numbers language-bash">$ git checkout [branch-name]</code></pre><ul><li>将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。</li></ul><pre><code class="line-numbers language-bash">$ git merge [branch]</code></pre><ul><li>删除指定分支</li></ul><pre><code class="line-numbers language-bash">$ git branch -d [branch-name]</code></pre><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>当着手于一个新的仓库时，你只需创建一次。要么在本地创建，然后推送到 GitHub；要么通过 clone 一个现有仓库。</p><ul><li>初始化仓库</li></ul><pre><code class="line-numbers language-bash">$ git init</code></pre><ul><li>在使用过<code>git init</code> 命令后，使用以下命令将本地仓库与一个 GitHub 上的空仓库连接起来, 即将现在目录转化为一个git仓库</li></ul><pre><code class="line-numbers language-bash">$ git remote add origin [url]</code></pre><ul><li>Clone（下载）一个已存在于 GitHub 上的仓库，包括所有的文件、分支和提交(commits)</li></ul><pre><code class="line-numbers language-bash">$ git clone [url]</code></pre><h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><p>有时一些文件最好不要用 Git 跟踪。这通常在名为<code>.gitignore</code>的特殊文件中完成。你可以在<a href="https://github.com/github/gitignore">github.com/github/gitignore</a> 找到有用的<code>.gitignore</code>文件模板.</p><h2 id="同步更改"><a href="#同步更改" class="headerlink" title="同步更改"></a>同步更改</h2><p>将你本地仓库与 GitHub.com 上的远端仓库同步</p><ul><li>下载远端跟踪分支的所有历史</li></ul><pre><code class="line-numbers language-bash">$ git fetch</code></pre><ul><li>将远端跟踪分支合并到当前本地分支</li></ul><pre><code class="line-numbers language-bash">git merge</code></pre><ul><li>将所有本地分支提交上传到 GitHub</li></ul><pre><code class="line-numbers language-bash">$ git push</code></pre><ul><li>使用来自 GitHub 的对应远端分支的所有新提交更新你当前的本地工作分支。·<code>git pull</code> 是 <code>git fetch</code> 和    <code>git merge</code> 的结合</li></ul><pre><code class="line-numbers language-bash">$ git pull</code></pre><h2 id="进行更改"><a href="#进行更改" class="headerlink" title="进行更改"></a>进行更改</h2><p>浏览并检查项目文件的发展</p><ul><li>列出当前分支的版本历史</li></ul><pre><code class="line-numbers language-bash">$ git log</code></pre><ul><li>列出文件的版本历史，包括重命名</li></ul><pre><code class="line-numbers language-bash">$ git log --follow [file]</code></pre><ul><li>展示两个分支之间的内容差异</li></ul><pre><code class="line-numbers language-bash">$ git diff [first-branch]...[second-branch]</code></pre><ul><li>输出指定commit的元数据和内容变化</li></ul><pre><code class="line-numbers language-bash">$ git show [commit]</code></pre><ul><li>将文件进行快照处理用于版本控制</li></ul><pre><code class="line-numbers language-bash">$ git add [file]</code></pre><ul><li>将文件快照永久地记录在版本历史中</li></ul><pre><code class="line-numbers language-bash">$ git commit -m &quot;[descriptive message]&quot;</code></pre><h2 id="重做提交"><a href="#重做提交" class="headerlink" title="重做提交"></a>重做提交</h2><p>清除错误和构建用于替换的历史</p><ul><li>撤销所有 <code>[commit]</code>  <strong>后</strong>的提交,在本地保存更改</li></ul><pre><code class="line-numbers language-bash">$ git reset [commit]</code></pre><ul><li>放弃所有历史，改回指定提交。</li></ul><pre><code class="line-numbers language-bash">$ git reset --hard [commit]</code></pre><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><ul><li><strong>git</strong> : 一个开源的分布式版本控制系统</li><li><strong>GitHub</strong> : 一个托管和协作管理 Git 仓库的平台</li><li><strong>commit提交</strong> : 一个 Git 对象，是你整个仓库的快照的哈希值</li><li><strong>branch分支</strong> : 一个轻型可移动的 commit 指针</li><li><strong>clone</strong> : 一个仓库的本地版本，包含所有提交和分支</li><li><strong>remote远端</strong> : 一个 GitHub 上的公共仓库，所有小组成员通过它来交换修改</li><li><strong>fork</strong> : 一个属于另一用户的 GitHub 上的仓库的副本</li><li><strong>pull request 拉取请求</strong>: 一处用于比较和讨论分支上引入的差异，且具有评审、评论、集成测试等功能的地方</li><li><strong>HEAD</strong> : 代表你当前的工作目录。使用git checkout 可移动 HEAD 指针到不同的分支、标记(tags)或提交</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Neovim</title>
      <link href="/2021/02/20/neovim/"/>
      <url>/2021/02/20/neovim/</url>
      
        <content type="html"><![CDATA[<p>本文是为了方便记忆vim插件的一些快捷键。这是我的配置地址：<a href="https://github.com/liuyaanng/nvim">nvim</a>, 该配置在你装完neovim之后，打开neovim后会自动安装插件，你需要修改的地方是下图中python位置以及markdown预览插件中的默认浏览器。<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Neovim/1.jpg"> </p><p>我的vim插件大部分来自于一位大佬<a href="https://github.com/theniceboy">theniceboy</a>, 他在B站上出了很多包括vim, ranger, i3, dwm等等教程, 这是他的B站地址：<a href="https://space.bilibili.com/13081489?from=search&seid=4240676561582012103">theCW</a> </p><h2 id="1-Install-Neovim"><a href="#1-Install-Neovim" class="headerlink" title="1. Install Neovim"></a>1. Install Neovim</h2><p><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim">Install Guide</a> </p><h2 id="2-有用的工具"><a href="#2-有用的工具" class="headerlink" title="2. 有用的工具"></a>2. 有用的工具</h2><ul><li>figlet</li></ul><pre><code class="line-numbers language-bash">brew install figlet</code></pre><h2 id="3-Vim基础快捷键"><a href="#3-Vim基础快捷键" class="headerlink" title="3. Vim基础快捷键"></a>3. Vim基础快捷键</h2><p>这里<code>&lt;LEADER&gt;</code>就是空格键</p><ul><li>基础快捷键</li></ul><pre><code class="line-numbers language-vim">- &#39;;&#39; :Save &amp; quit- &#39;Q&#39; quit- &#39;ctrl_q&#39; Exit Vim, unless there are some buffers which have been changed.- &#39;S&#39; save- &#39;&lt;LEADER&gt;rc&#39; open vimrcUndo -    `l` undo- &#39;Y&#39; Visual Mode : copy to system clipboard      Normal Mode : copy till the end of the line.- &#39;&gt;&#39; right indent- &#39;&lt;&#39; left indentSearch- &#39;&lt;LEADER&gt;&lt;CR&gt;&#39; highlight off- &#39;=&#39; next- &#39;-&#39; last- &#39;&lt;LEADER&gt;dw&#39; adjacent duplicate wordsSpace to Tab- &#39;&lt;LEADER&gt;tt&#39; turn space to tabFolding- &#39;&lt;LEADER&gt;o&#39; foldingLazyGit- &#39;\g&#39; :Git- &#39;ctrl_g&#39; open lazygitCursor Movement&quot;     ^&quot;     u&quot; &lt; n   i &gt;&quot;     e&quot;     v- &#39;u&#39; up- &#39;e&#39; down- &#39;n&#39; left- &#39;i&#39; right- &#39;N&#39; go to the start of the line- &#39;I&#39; go to the end of the line- &#39;\v&#39; choose current line- &#39;w&#39; go to the next word or sign- &#39;b&#39; go to the last word or sign- &#39;h&#39; go to the next end of word- &#39;ctrl_U&#39; move up the view port without moving the cursor- &#39;ctrl_E&#39; move down the view port without moving the cursor- &#39;ctrl_a&#39; Insert Mode: move to the end of current line           Command Mode: move to the start of command lineCommand Mode Cursor Movement - &#39;ctrl_a&#39; move to the start of command line- &#39;ctrl_e&#39; move to the end of command line- &#39;ctrl_p&#39; move up- &#39;ctrl_n&#39; move down - &#39;ctrl_b&#39; move left- &#39;ctrl_f&#39; move right- &#39;alt_b&#39; move to last word- &#39;alt_w&#39; move to next wordSplit the screen- &#39;su&#39; to up- &#39;se&#39; to down- &#39;sn&#39; to left- &#39;si&#39; to rightWindow management- &#39;&lt;LEADER&gt;w&#39; go to last window- &#39;&lt;LEADER&gt;u&#39; up- &#39;&lt;LEADER&gt;e&#39; down- &#39;&lt;LEADER&gt;n&#39; left- &#39;&lt;LEADER&gt;i&#39; right- &#39;sh&#39; place the two windows up and down- &#39;sv&#39; place the two windows left and right- &#39;&lt;LEADER&gt;q&#39; close the window below the current window- &#39;qf&#39; close current windowRotate screen- &#39;srh&#39; horizontal rotate- &#39;srv&#39; vertical rotateResize splits- &#39;&lt;up&gt;&#39; increase horizontal size- &#39;&lt;down&gt;&#39; decrease horizontal size- &#39;&lt;left&gt;&#39; decrease vertical size- &#39;&lt;right&gt;&#39; increase vertical sizeTab management- &#39;tu&#39; create a new tab- &#39;tn&#39; move to left tab- &#39;ti&#39; move to right tab- &#39;tmn&#39; move current tab to left- &#39;tmi&#39; move current tab to right- &#39;&lt;LEADER&gt;/&#39; open a terminal window- &#39;tx&#39; use &#39;figlet&#39; to generate words- &#39;\s&#39; find and replace</code></pre><h2 id="4-Vim-插件"><a href="#4-Vim-插件" class="headerlink" title="4. Vim 插件"></a>4. Vim 插件</h2><h3 id="Pretty-Dress"><a href="#Pretty-Dress" class="headerlink" title="Pretty Dress"></a>Pretty Dress</h3><ul><li><a href="https://github.com/bling/vim-bufferline">vim-bufferline</a> </li><li><a href="https://github.com/bpietravalle/vim-bolt">vim-bolt</a> </li><li><a href="https://github.com/ajmwagar/vim-deus">vim-deus</a> </li></ul><h3 id="Status-line"><a href="#Status-line" class="headerlink" title="Status line"></a>Status line</h3><ul><li><a href="https://github.com/theniceboy/eleline.vim">lelline</a> </li><li><a href="https://github.com/ojroques/vim-scrollstatus">vim-scrollstatus</a> </li></ul><h3 id="General-Highlight"><a href="#General-Highlight" class="headerlink" title="General Highlight"></a>General Highlight</h3><ul><li><a href="https://github.com/RRethy/vim-hexokinase">vim-hexokinase</a> </li><li><a href="https://github.com/RRethy/vim-illuminate">vim-illuminate</a> </li></ul><h3 id="File-navigation"><a href="#File-navigation" class="headerlink" title="File navigation"></a>File navigation</h3><ul><li><p><a href="https://github.com/Yggdroot/LeaderF">LeaderF</a> </p></li><li><p><a href="https://github.com/junegunn/fzf.vim">fzf.vim</a><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210301113521.png"></p><ul><li><p><a href="https://github.com/junegunn/fzf/blob/master/README-VIM.md">fzf.vim README</a> </p></li><li><p>安装</p><pre><code class="line-numbers language-vim">Plug &#39;junegunn/fzf.vim&#39;</code></pre><p>配置</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === FZF&quot; ===set rtp+=/usr/local/opt/fzf&quot; set rtp+=/home/linuxbrew/.linuxbrew/opt/fzf&quot; noremap &lt;silent&gt; &lt;C-p&gt; :Files&lt;CR&gt;noremap &lt;silent&gt; &lt;C-p&gt; :Leaderf file&lt;CR&gt;noremap &lt;silent&gt; &lt;C-f&gt; :Rg&lt;CR&gt;noremap &lt;silent&gt; &lt;C-h&gt; :History&lt;CR&gt;&quot;noremap &lt;C-t&gt; :BTags&lt;CR&gt;noremap &lt;silent&gt; &lt;C-l&gt; :Lines&lt;CR&gt;noremap &lt;silent&gt; &lt;C-w&gt; :Buffers&lt;CR&gt;noremap &lt;leader&gt;; :History:&lt;CR&gt;let g:fzf_preview_window = &#39;right:60%&#39;let g:fzf_commits_log_options = &#39;--graph --color=always --format=&quot;%C(auto)%h%d %s %C(black)%C(bold)%cr&quot;&#39;function! s:list_buffers()  redir =&gt; list  silent ls  redir END  return split(list, &quot;\n&quot;)endfunctionfunction! s:delete_buffers(lines)  execute &#39;bwipeout&#39; join(map(a:lines, &#123;_, line -&gt; split(line)[0]&#125;))endfunctioncommand! BD call fzf#run(fzf#wrap(&#123;  \ &#39;source&#39;: s:list_buffers(),  \ &#39;sink*&#39;: &#123; lines -&gt; s:delete_buffers(lines) &#125;,  \ &#39;options&#39;: &#39;--multi --reverse --bind ctrl-a:select-all+accept&#39;\ &#125;))noremap &lt;c-d&gt; :BD&lt;CR&gt;let g:fzf_layout = &#123; &#39;window&#39;: &#123; &#39;width&#39;: 0.9, &#39;height&#39;: 0.8 &#125; &#125;</code></pre><p>快捷键:    </p></li><li><p><code>ctrl_f</code> 查找文件</p></li><li><p><code>ctrl_p</code> 使用 <code>LeaderF</code> 查找当前目录下的文件</p></li><li><p><code>ctrl_l</code> 查找当前文件的行</p></li><li><p><code>ctrl_h</code> 打开文件浏览历史</p></li><li><p><code>ctrl_w</code> 打开buffer</p></li><li><p><code>ctrl_d</code> 选择关闭指定的buffer</p></li></ul></li><li><p><a href="https://github.com/kevinhwang91/rnvimr">rnvimr</a> 在vim下使用ranger</p><p>  配置 </p><pre><code class="line-numbers language-vim">&quot; ===&quot; === rnvimr&quot; ===let g:rnvimr_ex_enable = 1let g:rnvimr_pick_enable = 1let g:rnvimr_draw_border = 0&quot; Change the border&#39;s colorlet g:rnvimr_border_attr = &#123;&#39;fg&#39;: 14, &#39;bg&#39;: -1&#125;&quot; Add a shadow window, value is equal to 100 will disable shadowlet g:rnvimr_shadow_winblend = 70&quot; let g:rnvimr_bw_enable = 1highlight link RnvimrNormal CursorLinennoremap &lt;silent&gt; R :RnvimrToggle&lt;CR&gt;&lt;C-\&gt;&lt;C-n&gt;:RnvimrResize 0&lt;CR&gt;let g:rnvimr_action = &#123;                        \ &#39;&lt;C-t&gt;&#39;: &#39;NvimEdit tabedit&#39;,                        \ &#39;&lt;C-x&gt;&#39;: &#39;NvimEdit split&#39;,                        \ &#39;&lt;C-v&gt;&#39;: &#39;NvimEdit vsplit&#39;,                        \ &#39;gw&#39;: &#39;JumpNvimCwd&#39;,                        \ &#39;yw&#39;: &#39;EmitRangerCwd&#39;                        \ &#125;let g:rnvimr_layout = &#123; &#39;relative&#39;: &#39;editor&#39;,                        \ &#39;width&#39;: &amp;columns,                        \ &#39;height&#39;: &amp;lines,                        \ &#39;col&#39;: 0,                        \ &#39;row&#39;: 0,                        \ &#39;style&#39;: &#39;minimal&#39; &#125;let g:rnvimr_presets = [&#123;&#39;width&#39;: 0.8, &#39;height&#39;: 0.8&#125;]</code></pre><p>  快捷键</p><ul><li><code>R</code> 打开ranger</li></ul></li><li><p><a href="https://github.com/airblade/vim-rooter">vim-rooter</a> :自动将vim的工作目录到项目的根目录.</p><p>  <code>Rooter changes the working directory to the project root when you open a file or directory.</code></p><p>  对比:<br>  原文件目录:</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302121823.png"></p><p>  关闭rooter: 在vim里打开一个文件,此时vim的工作目录依旧是原文件所在目录</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302122402.png"></p><p>  启用rooter: 打开文件,vim的工作目录会切换到文件的根目录</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302122752.png"></p><p>  配置</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === vim-rooter&quot; ===let g:rooter_patterns = [&#39;__vim_project_root&#39;, &#39;.git/&#39;]let g:rooter_silent_chdir = 1</code></pre><p>  默认打开 <code>rooter</code></p></li><li><p><a href="https://github.com/pechorin/any-jump.vim">any-jump</a> </p><p>  用法: 在 <code>normal</code> 和 <code>visual</code> 模式下都可用. 只需要将光标放到想要查找的单词上,这个单词可以是 <code>变量</code>, <code>类</code>, <code>常量</code>, <code>名称</code>, <code>符号</code> ( <code>variable/class/constant/name/symbol</code> ) 然后按下 <code>&lt;LEADER&gt;j</code> 即可.</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302124051.png"></p><p>  配置</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === any-jump&quot; ===nnoremap &lt;LEADER&gt;j :AnyJump&lt;CR&gt;let g:any_jump_window_width_ratio  = 0.8let g:any_jump_window_height_ratio = 0.9</code></pre><p>  快捷键</p><ul><li><code>&lt;LEADER&gt;j</code> search </li></ul></li></ul><h3 id="Taglist"><a href="#Taglist" class="headerlink" title="Taglist"></a>Taglist</h3><ul><li><p><a href="https://github.com/liuchengxu/vista.vim">Vista.vim</a>  </p><p>  这是一款查看LSP符号,标签的插件,可配合多个vim插件使用</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302125525.png"></p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === Vista.vim&quot; ===noremap &lt;LEADER&gt;v :Vista coc&lt;CR&gt;noremap &lt;c-t&gt; :silent! Vista finder coc&lt;CR&gt;let g:vista_icon_indent = [&quot;╰─▸ &quot;, &quot;├─▸ &quot;]let g:vista_default_executive = &#39;ctags&#39;let g:vista_fzf_preview = [&#39;right:50%&#39;]let g:vista#renderer#enable_icon = 1let g:vista#renderer#icons = &#123;\   &quot;function&quot;: &quot;\uf794&quot;,\   &quot;variable&quot;: &quot;\uf71b&quot;,\  &#125;let g:scrollstatus_size = 15</code></pre><p>  快捷键:</p><ul><li><p><code>&lt;LEADER&gt;v</code> 打开vista面板</p></li><li><p><code>&lt;ctrl-t&gt;</code>  使用fzf查找名称</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302133944.png"></p></li></ul></li></ul><h3 id="Auto-Complete"><a href="#Auto-Complete" class="headerlink" title="Auto Complete"></a>Auto Complete</h3><ul><li><p><a href="https://github.com/neoclide/coc.nvim">coc</a> </p><p>  <a href="">详细配置教程</a> </p></li><li><p><a href="https://github.com/wellle/tmux-complete.vim">tmux-complete.vim</a> </p><p>  在临近的tmux窗格中启动单词的自动补全</p><h3 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h3></li><li><p><a href="https://github.com/honza/vim-snippets">vim-snippets</a>     </p><p>  快速补全工具,非常强大</p></li></ul><h3 id="Ubdo-Tree"><a href="#Ubdo-Tree" class="headerlink" title="Ubdo Tree"></a>Ubdo Tree</h3><ul><li><p><a href="https://github.com/mbbill/undotree">undotree</a></p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302154803.png"></p><p>  配置: </p><pre><code class="line-numbers language-vim">&quot; ===&quot; === Undotree&quot; ===noremap L :UndotreeToggle&lt;CR&gt;let g:undotree_DiffAutoOpen = 1let g:undotree_SetFocusWhenToggle = 1let g:undotree_ShortIndicators = 1let g:undotree_WindowLayout = 2let g:undotree_DiffpanelHeight = 8let g:undotree_SplitWidth = 24function g:Undotree_CustomMap()    nmap &lt;buffer&gt; u &lt;plug&gt;UndotreeNextState    nmap &lt;buffer&gt; e &lt;plug&gt;UndotreePreviousState    nmap &lt;buffer&gt; U 5&lt;plug&gt;UndotreeNextState    nmap &lt;buffer&gt; E 5&lt;plug&gt;UndotreePreviousStateendfunc</code></pre><p>  快捷键:</p><ul><li><code>L</code>  打开undotree 面板</li></ul></li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li><p><a href="https://github.com/gisphm/vim-gitignore">vim-gitignore</a>:<br>  提供 <code>.gitignore</code> 文件高亮显示</p></li><li><p><a href="https://github.com/fszymanski/fzf-gitignore">fzf-gitignore</a>:  生成 <code>.gitignore</code> 文件</p><p>  配置:</p><pre><code class="line-numbers language-vim">noremap &lt;LEADER&gt;gi :FzfGitignore&lt;CR&gt;</code></pre><p>  快捷键:</p><ul><li><code>&lt;LEADER&gt;gi</code> 生成 <code>.gitignore</code> 文件</li></ul></li><li><p><a href="https://github.com/akiomik/git-gutter-vim">vim-gitgutter</a>:<br>  一个保存文件后能看到状态的插件</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302164010.png"></p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ==&quot; == GitGutter&quot; ==&quot; let g:gitgutter_signs = 0let g:gitgutter_sign_allow_clobber = 0let g:gitgutter_map_keys = 0let g:gitgutter_override_sign_column_highlight = 0let g:gitgutter_preview_win_floating = 1let g:gitgutter_sign_added = &#39;▎&#39;let g:gitgutter_sign_modified = &#39;░&#39;let g:gitgutter_sign_removed = &#39;▏&#39;let g:gitgutter_sign_removed_first_line = &#39;▔&#39;let g:gitgutter_sign_modified_removed = &#39;▒&#39;&quot; autocmd BufWritePost * GitGutternnoremap &lt;LEADER&gt;gf :GitGutterFold&lt;CR&gt;nnoremap H :GitGutterPreviewHunk&lt;CR&gt;nnoremap &lt;LEADER&gt;g- :GitGutterPrevHunk&lt;CR&gt;nnoremap &lt;LEADER&gt;g= :GitGutterNextHunk&lt;CR&gt;</code></pre><p>  快捷键:</p><ul><li><p><code>&lt;LEADER&gt;gf</code> 折叠</p></li><li><p><code>H</code> 预览当前文件块</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302164503.png"></p></li><li><p><code>&lt;LEADER&gt;g-</code> 上一块</p></li><li><p><code>&lt;LEADER&gt;g+</code> 下一块</p></li></ul></li><li><p><a href="https://github.com/cohama/agit.vim">agit</a>: 轻松查看git提交记录以及做出的更改</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302164810.png"></p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === Agit&quot; ===nnoremap &lt;LEADER&gt;gl :Agit&lt;CR&gt;let g:agit_no_default_mappings = 1</code></pre><p>  快捷键:</p><ul><li><code>&lt;LEADER&gt;gl</code> 查看git提交记录</li></ul></li></ul><h3 id="Autoformat"><a href="#Autoformat" class="headerlink" title="Autoformat"></a>Autoformat</h3><ul><li><p><a href="https://github.com/Chiel92/vim-autoformat">vim-autoformat</a>: 一键格式化代码</p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === AutoFormatr&quot; ===nnoremap \f :Autoformat&lt;CR&gt;let g:formatdef_custom_js = &#39;&quot;js-beautify -t&quot;&#39;let g:formatters_javascript = [&#39;custom_js&#39;]au BufWrite *.js :Autoformat</code></pre><p>  快捷键:</p><ul><li><code>\f</code> 一键格式化代码</li></ul></li></ul><h3 id="HTML-CSS-JS-TypeScript-JSON-etc"><a href="#HTML-CSS-JS-TypeScript-JSON-etc" class="headerlink" title="HTML CSS JS TypeScript JSON, etc"></a>HTML CSS JS TypeScript JSON, etc</h3><ul><li><p><a href="https://github.com/leshill/vim-json">vim-json</a>: 提供json数据的高亮显示</p></li><li><p><a href="https://github.com/neoclide/jsonc.vim">jsonc.vim</a> : 支持 <code>jsonc</code> 语法</p></li><li><p><a href="https://github.com/othree/html5.vim">html5.vim</a> : 提供H5高亮和补全</p></li><li><p><a href="https://github.com/alvan/vim-closetag">vim-closetag</a> : 快速书写 <code>html</code> 的标签</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-colsetag.gif"></p><p>  注意: 下面的标签不适用</p><pre><code class="line-numbers language-html">&lt;area&gt;, &lt;base&gt;, &lt;br&gt;, &lt;col&gt;, &lt;command&gt;, &lt;embed&gt;, &lt;hr&gt;, &lt;img&gt;,&lt;input&gt;, &lt;keygen&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;param&gt;, &lt;source&gt;, &lt;track&gt;, &lt;wbr&gt;,&lt;menuitem&gt;</code></pre><p>  快捷键: </p><ul><li><code>&gt;</code> </li><li><code>&gt;&gt;</code> </li></ul></li><li><p><a href="https://github.com/coolwanglu/vim.js">vim-js</a> : 支持JS语法</p></li><li><p><a href="https://github.com/HerringtonDarkholme/yats.vim">yats.vim</a> : 支持 <code>TypeScript</code> 语法</p></li><li><p><a href="https://github.com/posva/vim-vue">vim-vue</a> : 支持vue</p></li></ul><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><ul><li><a href="https://github.com/fatih/vim-go">vim-go</a> 支持Go语言</li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><p><a href="https://github.com/Vimjas/vim-python-pep8-indent">vim-python-pep8-indent</a> : 调整vim的缩进以符合 <a href="https://www.python.org/dev/peps/pep-0008/">pep8</a> 规范</p></li><li><p><a href="https://github.com/tweekmonster/braceless.vim">braceless.vim</a> : 包含一些有用的快捷键, 在这里只配置函数主体高亮</p><p>  配置:</p><pre><code class="line-numbers language-vim">autocmd FileType python BracelessEnable +highlight-cc2</code></pre><p>  快捷键:</p><ul><li>Moving to recognized blocks is done with <code>[[</code> and <code>]]</code>. In Python, <code>[m</code> and <code>]m</code> moves to def and class blocks, while <code>[M</code> and <code>]M</code> moves to the end of those blocks.</li><li><code>zc</code> 折叠</li><li><code>zR</code> 取消折叠</li></ul></li></ul><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><ul><li><p><a href="https://github.com/iamcco/markdown-preview.nvim">markdown-preview</a> 这是一个实时预览markdown文件的插件, markdown 文件按<code>r</code>即可实时预览</p></li><li><p><a href="https://github.com/dhruvasagar/vim-table-mode">vim-table-mode</a> : md文件快速创建表格</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-table-mode.gif"><br>  配置:</p><pre><code class="line-numbers language-vim">&quot;let g:table_mode_disable_mappings = 1let g:table_mode_cell_text_object_i_map = &#39;k&lt;Bar&gt;&#39;</code></pre><p>  快捷键: </p><ul><li><code>&lt;LEADER&gt;tm</code>:  打开/关闭    <code>table-mode</code></li></ul></li><li><p><a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc</a> : 一键生成TOC</p></li><li><p><a href="https://github.com/dkarter/bullets.vim">bullets.vim</a> </p></li></ul><h3 id="Editor-Enhancement"><a href="#Editor-Enhancement" class="headerlink" title="Editor Enhancement"></a>Editor Enhancement</h3><ul><li><p><a href="https://github.com/jiangmiao/auto-pairs">auto-pairs</a> : 成对添加或删除括号, 引号</p></li><li><p><a href="https://github.com/mg979/vim-visual-multi">vim-visual-multi</a></p></li><li><p><a href="https://github.com/tomtom/tcomment_vim">tcomment_vim</a> :快速注释内容</p><p>  配置:</p><pre><code class="line-numbers language-vim">let g:tcomment_textobject_inlinecomment = &#39;&#39;nmap &lt;LEADER&gt;cn g&gt;cvmap &lt;LEADER&gt;cn g&gt;nmap &lt;LEADER&gt;cu g&lt;cvmap &lt;LEADER&gt;cu g&lt;</code></pre><p>  快捷键:</p><ul><li><code>&lt;leader&gt;cn</code> 注释</li><li><code>&lt;leader&gt;cu</code> 取消注释</li></ul></li><li><p><a href="https://github.com/LIUYAANNG/ANTOVIM">ANTOVIM</a> : 一键改变 <code>TRUE</code> 和 <code>FALSE</code></p><p>  快捷键:</p><ul><li><code>gs</code> 切换</li></ul></li><li><p><a href="https://github.com/tpope/vim-surround">vim-surround</a> </p><p>  快捷键:</p><ul><li><code>yskw&#39;</code> 在所选单词两边添加 <code>&#39;</code> : <code>word</code> to <code>&#39;word&#39;</code></li><li><code>cd&#39;&quot;</code> 将单词两边的 <code>&#39;&#39;</code> 变成    <code>&quot;&quot;</code> : <code>&#39;word&#39;</code> to <code>&quot;word&quot;</code></li></ul></li><li><p><a href="https://github.com/gcmt/wildfire.vim">wildfire.vim</a> : 选中特殊符号包裹的文字</p><p>  快捷键:</p><ul><li><p>在 <code>Visual Mode</code> 下, 使用 <code>k&#39;</code> 会选中被 <code>&#39;&#39;</code>包裹的文字, 同样的    <code>k), k&#125;, k]</code> 也适用</p><p>注意: 仓库wiki中快捷键是 <code>i&#39;</code>, 因为我做了按键映射, 将 <code>i</code> 映射到 <code>k</code> 上了</p></li></ul></li><li><p><a href="https://github.com/godlygeek/tabular">tabular</a> : 快速对齐文本</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-tabular.gif"></p><p>  快捷键:</p><ul><li><code>ga</code> + 对齐的参照物, 如: <code>:</code>, <code>=</code></li></ul></li><li><p><a href="https://github.com/tpope/vim-capslock">vim-capslock</a> : 大写锁定</p><p>  快捷键:</p><ul><li><code>Insert Mode</code> : <code>ctrl_C</code> </li><li><code>Normal Mode</code> : <code>gC</code></li></ul></li><li><p><a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>  待完善</p></li><li><p><a href="https://github.com/svermeulen/vim-subversive">vim-subversive</a><br>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-subversive.gif"></p></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> neovim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-CLI</title>
      <link href="/2021/02/10/leetcode-cli/"/>
      <url>/2021/02/10/leetcode-cli/</url>
      
        <content type="html"><![CDATA[<p>由于我有长期使vim的习惯, 在刷leetcode题时,在网页上写代码实在是有点难受, <a href="https://github.com/skygragon/leetcode-cli">LeetCode-cli</a> 完美解决了我的问题. </p><p>leetcode支持本地缓存题目,写代码,测试以及提交到<code>leetcode.com</code>.</p><p><img loading="lazy" src="https://github.com/skygragon/leetcode-cli/raw/master/docs/screenshots/intro.2018.01.13.gif" alt="LeetCode-cli">     </p><p>下面记录一下配置<code>leetcode-cli</code></p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><ul><li>下载稳定版本,并非开发版本. <a href="https://skygragon.github.io/leetcode-cli/install">Install guide</a> <pre><code class="line-numbers language-bash">npm install -g leetcode-cli</code></pre></li></ul><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>所有用法wiki介绍的很详细, 自己探索吧哈哈哈! </p><p>后续发现什么骚操作了再来这里分享</p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p><strong>一:  连接不到<code>leetcode</code>和<code>leetcode.cn</code>服务器,都会报<code>invalid password</code>的<code>error</code></strong><br>解决方案如下:  参考<br><a href="https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/478#issuecomment-564757098">https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/478#issuecomment-564757098</a> </p><ol><li>确保已安装<code>Node.js 8+</code></li><li><pre><code class="line-numbers language-bash"># to remove the old versionnpm uninstall -g leetcode-cli# to install the up-to-date version(2.6.17+)npm install -g leetcode-tools/leetcode-cli</code></pre>使用<code>leetcode version</code>确保版本2.6.17+    </li><li>使用<code>cookie</code>登陆<br>这个版本中包含了很多种登陆方式    </li></ol><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210222559.png"><br>若使用账号密码无法登陆,可尝试使用<code>Cookie</code>登陆, 具体方式如下:<br>以<code>chrome</code>浏览器为例:    </p><ul><li><p>登陆<a href="">leetcode</a> , 打开 <strong><code>检查</code></strong><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210223002.png"></p></li><li><p>选择 <code>network</code> -&gt; <code>XHR</code> -&gt; <code>search</code> -&gt; <code>uid</code> -&gt; <code>all/</code><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210223441.png"></p></li><li><p>使用<code>leetcode user -c</code>, 输入<code>user</code>, 再将<code>cookie</code>粘贴就ok了<img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210231428.png"></p></li></ul><p><strong>2. 使用<code>leetcode.cn</code>, 用<code>leetcode show</code>命令出现<code>http error</code></strong><br>解决办法: 参考<a href="https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/489">https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/489</a> </p><ul><li>找到<code>leetcode.cn.js</code>文件, <strong>MacOS</strong> 一般在<code>/usr/local/lib/node_modules/vsc-leetcode-cli/lib/plugins/leetcode.cn.js</code></li><li>替换成以下代码:</li></ul><pre><code class="line-numbers language-js">&#39;use strict&#39;var request = require(&#39;request&#39;);var config = require(&#39;../config&#39;);var h = require(&#39;../helper&#39;);var log = require(&#39;../log&#39;);var Plugin = require(&#39;../plugin&#39;);var session = require(&#39;../session&#39;);//// [Usage]//// https://github.com/skygragon/leetcode-cli-plugins/blob/master/docs/leetcode.cn.md//var plugin = new Plugin(15, &#39;leetcode.cn&#39;, &#39;2018.11.25&#39;,    &#39;Plugin to talk with leetcode-cn APIs.&#39;);plugin.init = function() &#123;  config.app = &#39;leetcode.cn&#39;;  config.sys.urls.base            = &#39;https://leetcode-cn.com&#39;;  config.sys.urls.login           = &#39;https://leetcode-cn.com/accounts/login/&#39;;  config.sys.urls.problems        = &#39;https://leetcode-cn.com/api/problems/$category/&#39;;  config.sys.urls.problem         = &#39;https://leetcode-cn.com/problems/$slug/description/&#39;;  config.sys.urls.graphql         = &#39;https://leetcode-cn.com/graphql&#39;;  config.sys.urls.problem_detail  = &#39;https://leetcode-cn.com/graphql&#39;;  config.sys.urls.test            = &#39;https://leetcode-cn.com/problems/$slug/interpret_solution/&#39;;  config.sys.urls.session         = &#39;https://leetcode-cn.com/session/&#39;;  config.sys.urls.submit          = &#39;https://leetcode-cn.com/problems/$slug/submit/&#39;;  config.sys.urls.submissions     = &#39;https://leetcode-cn.com/api/submissions/$slug&#39;;  config.sys.urls.submission      = &#39;https://leetcode-cn.com/submissions/detail/$id/&#39;;  config.sys.urls.verify          = &#39;https://leetcode-cn.com/submissions/detail/$id/check/&#39;;  config.sys.urls.favorites       = &#39;https://leetcode-cn.com/list/api/questions&#39;;  config.sys.urls.favorite_delete = &#39;https://leetcode-cn.com/list/api/questions/$hash/$id&#39;;&#125;;// FIXME: refactor those// update options with user credentialsfunction signOpts(opts, user) &#123;  opts.headers.Cookie = &#39;LEETCODE_SESSION=&#39; + user.sessionId +                        &#39;;csrftoken=&#39; + user.sessionCSRF + &#39;;&#39;;  opts.headers[&#39;X-CSRFToken&#39;] = user.sessionCSRF;  opts.headers[&#39;X-Requested-With&#39;] = &#39;XMLHttpRequest&#39;;&#125;function makeOpts(url) &#123;  const opts = &#123;&#125;;  opts.url = url;  opts.headers = &#123;&#125;;  if (session.isLogin())    signOpts(opts, session.getUser());  return opts;&#125;function checkError(e, resp, expectedStatus) &#123;  if (!e &amp;&amp; resp &amp;&amp; resp.statusCode !== expectedStatus) &#123;    const code = resp.statusCode;    log.debug(&#39;http error: &#39; + code);    if (code === 403 || code === 401) &#123;      e = session.errors.EXPIRED;    &#125; else &#123;      e = &#123;msg: &#39;http error&#39;, statusCode: code&#125;;    &#125;  &#125;  return e;&#125;plugin.getProblems = function(cb) &#123;  plugin.next.getProblems(function(e, problems) &#123;    if (e) return cb(e);    plugin.getProblemsTitle(function(e, titles) &#123;      if (e) return cb(e);      problems.forEach(function(problem) &#123;        const title = titles[problem.id];        if (title)          problem.name = title;      &#125;);      return cb(null, problems);    &#125;);  &#125;);&#125;;plugin.getProblemsTitle = function(cb) &#123;  log.debug(&#39;running leetcode.cn.getProblemNames&#39;);  const opts = makeOpts(config.sys.urls.graphql);  opts.headers.Origin = config.sys.urls.base;  opts.headers.Referer = &#39;https://leetcode-cn.com/api/problems/algorithms/&#39;;  opts.json = true;  opts.body = &#123;    query: [      &#39;query getQuestionTranslation($lang: String) &#123;&#39;,      &#39;  translations: allAppliedQuestionTranslations(lang: $lang) &#123;&#39;,      &#39;    title&#39;,      &#39;    questionId&#39;,      &#39;  &#125;&#39;,      &#39;&#125;&#39;,      &#39;&#39;    ].join(&#39;\n&#39;),    variables:     &#123;&#125;,    operationName: &#39;getQuestionTranslation&#39;  &#125;;  const spin = h.spin(&#39;Downloading questions titles&#39;);  request.post(opts, function(e, resp, body) &#123;    spin.stop();    e = checkError(e, resp, 200);    if (e) return cb(e);    const titles = [];    body.data.translations.forEach(function(x) &#123;      titles[x.questionId] = x.title;    &#125;);    return cb(null, titles);  &#125;);&#125;;module.exports = plugin;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Daily_Questions</title>
      <link href="/2021/02/09/leetcode-daily-questions/"/>
      <url>/2021/02/09/leetcode-daily-questions/</url>
      
        <content type="html"><![CDATA[<p>待完善</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可爱的壁纸</title>
      <link href="/2020/09/24/ke-ai-de-bi-zhi/"/>
      <url>/2020/09/24/ke-ai-de-bi-zhi/</url>
      
        <content type="html"><![CDATA[<p>在寻找壁纸api的时候突然发现了一套灰常灰常可爱的壁纸，于是想把他们都放到我的壁纸界面上，无奈api一次请求的图片一样，所以就想着把这些图片搞下来，存到我的cdn加速中。</p><p>先来几张图：</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/1.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/13.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/29.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/65.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/94.jpg"> </p><h3 id="1-得到图片"><a href="#1-得到图片" class="headerlink" title="1. 得到图片"></a>1. 得到图片</h3><p>懒癌晚期当然是不能一张一张的下载了，于是就有了下面</p><pre><code class="line-numbers language-python">import osimport timeimport randomimport requestsimport urllib.requestfrom urllib.request import Request, urlopen, urlretrieveurl = yourapiheaders = &#123;    &#39;User-Agent&#39;:    &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:23.0) Gecko/20100101 Firefox/23.0&#39;&#125;folder_path = &#39;/Users/kevin/Pictures/wallpapers/mc/&#39;folder = os.path.exists(folder_path)if not folder:    os.makedirs(folder_path)    print(&quot;创建文件夹%s成功&quot; % folder_path)file_names = os.listdir(folder_path)index = len(file_names)try:    while True:        flag = False        request = urllib.request.Request(url, headers=headers)        resp = urllib.request.urlopen(request)        real_url = resp.geturl()        response = requests.get(real_url)        # img_name = real_url.split(&#39;/&#39;)[4]        img_name = os.path.split(real_url)[1]        for file_name in file_names:            if file_name == img_name:                print(&#39;图片已存在&#39;)                flag = True                break        if flag:            time.sleep(random.randint(0, 3))            continue        path = folder_path + img_name        index += 1        urlretrieve(real_url, path)        print(&#39;已下载%d张图片,该图片的真实链接为%s&#39; % (index, real_url))        time.sleep(random.randint(0, 3))except:    print(&#39;出现异常&#39;)</code></pre><p>运行如下，没想到这么多张<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/1.jpg"> </p><h2 id="2-改名字"><a href="#2-改名字" class="headerlink" title="2. 改名字"></a>2. 改名字</h2><p>由于原图片的名字是一串神秘代码，这样看着太难受了，于是我决定给他们改名字，正好最近vim用的很顺手，接下来就是vim的骚操作了。</p><p>操作之前先讲讲vim为什么可以这么做: 可以在 Vim 内部调用外部程序(如shell命令)，还可以把缓冲区的内容作为标准输入传递给外部命令，或是把外部命令的标准输出导入到Vim缓冲区。</p><h3 id="1-在vim内部执行shell命令"><a href="#1-在vim内部执行shell命令" class="headerlink" title="1. 在vim内部执行shell命令"></a>1. 在vim内部执行shell命令</h3><p>在Vim的命令行模式中，在命令前加一个!前缀 (参见:h :! ) 就可以调用外部的shell程序。<br>例如：在vim中，想要查看当前目录的所有文件,在命令行模式下使用<code>:!ls</code></p><p>注：<code>:!ls</code> 和 <code>:ls</code> 是两个不同的Vim命令，前者是在Vim中调用shell命令 <code>ls</code>，用于列出目录下的所有文件，后者调用的是 Vim内置命令<code>ls</code>，用来显示当前缓冲区列表的内容.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/1.gif"> </p><h3 id="2-将Vim-缓冲区内容作为标准输入或标准输出"><a href="#2-将Vim-缓冲区内容作为标准输入或标准输出" class="headerlink" title="2. 将Vim 缓冲区内容作为标准输入或标准输出"></a>2. 将Vim 缓冲区内容作为标准输入或标准输出</h3><p>在使用<code>!&#123;cmd&#125;</code>时，vim会回显command的输出，可以用<code>:read !&#123;cmd&#125;</code>把command的输出重定向到当前vim的缓冲区中,或使用<code>:write !&#123;cmd&#125;</code>把当前vim缓冲区的内容作为command的标准输入.</p><p>例如：执行<code>:write !sh</code>则会在shell中逐行执行当前vim缓冲区的内容</p><h3 id="3-改名字"><a href="#3-改名字" class="headerlink" title="3. 改名字"></a>3. 改名字</h3><p>我想把名字改成（1.jpg，2.jpg）的形式，所以需要用到递增</p><ul><li>首先选中需要修改的部分，接下来执行两条指令:</li></ul><pre><code class="line-numbers language-vim">:&#39;&lt;,&gt;&#39;s/.*/mv &amp; aaa.jpg:&#39;&lt;,&gt;&#39;s/aaa/\=line(&quot;.&quot;)-line(&quot;&#39;&lt;&quot;)+1</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/2.gif"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@latest/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/3.gif"> </p><p>具体命令详解：</p><pre><code class="line-numbers language-vim">&#39;&lt;,&#39;&gt;        所选中的区域 (:help &#39;&lt;，:help &#39;&gt; )s            在选中的区域中进行替换 (:help :s ).*           匹配当前所有字符\=           指明后面是一个表达式 (:help :s\= )line(&quot;.&quot;)    当前光标所在行的行号 (:help line() )line(&quot;&#39;&lt;&quot;)   所选区域中第一行的行号 (:help line() ) </code></pre><p><code>&#39;&lt;</code>和<code>&#39;&gt;</code>是使用了”v”，”V”命令选中一个visual区域后，VIM设置的标记，分别用来标识visual区域的开始和结束。</p><ul><li>接着执行<code>:wirte !sh</code>即可</li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/4.gif"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>魔改hexo博客</title>
      <link href="/2020/09/18/mo-gai-hexo-bo-ke/"/>
      <url>/2020/09/18/mo-gai-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="魔改hexo博客"><a href="#魔改hexo博客" class="headerlink" title="魔改hexo博客"></a>魔改hexo博客</h2><p>本次魔改主要包括以下几个方面</p><h2 id="1-添加一言插件"><a href="#1-添加一言插件" class="headerlink" title="1. 添加一言插件"></a>1. 添加一言插件</h2><h2 id="2-添加动态线条背景"><a href="#2-添加动态线条背景" class="headerlink" title="2. 添加动态线条背景"></a>2. 添加动态线条背景</h2><h2 id="3-添加Dplayer视频播放器"><a href="#3-添加Dplayer视频播放器" class="headerlink" title="3. 添加Dplayer视频播放器"></a>3. 添加Dplayer视频播放器</h2><h2 id="4-添加Aplayer播放器"><a href="#4-添加Aplayer播放器" class="headerlink" title="4. 添加Aplayer播放器"></a>4. 添加Aplayer播放器</h2><h2 id="5-添加看板娘（live2d-widget插件）"><a href="#5-添加看板娘（live2d-widget插件）" class="headerlink" title="5. 添加看板娘（live2d-widget插件）"></a>5. 添加看板娘（live2d-widget插件）</h2><h2 id="6-添加黑夜模式"><a href="#6-添加黑夜模式" class="headerlink" title="6. 添加黑夜模式"></a>6. 添加黑夜模式</h2><h2 id="7-添加文章更新日期"><a href="#7-添加文章更新日期" class="headerlink" title="7. 添加文章更新日期"></a>7. 添加文章更新日期</h2><h2 id="8-添加访客地图统计"><a href="#8-添加访客地图统计" class="headerlink" title="8. 添加访客地图统计"></a>8. 添加访客地图统计</h2><h2 id="9-添加valine评论邮件提醒"><a href="#9-添加valine评论邮件提醒" class="headerlink" title="9. 添加valine评论邮件提醒"></a>9. 添加valine评论邮件提醒</h2><h2 id="10-添加网站背景"><a href="#10-添加网站背景" class="headerlink" title="10. 添加网站背景"></a>10. 添加网站背景</h2><h2 id="11-添加腾讯兔小巢"><a href="#11-添加腾讯兔小巢" class="headerlink" title="11. 添加腾讯兔小巢"></a>11. 添加腾讯兔小巢</h2><h2 id="12-Mac样式的代码块的添加"><a href="#12-Mac样式的代码块的添加" class="headerlink" title="12. Mac样式的代码块的添加"></a>12. Mac样式的代码块的添加</h2><h3 id="12-1-代码高亮"><a href="#12-1-代码高亮" class="headerlink" title="12.1 代码高亮"></a>12.1 代码高亮</h3><h4 id="12-1-1-禁用highlight"><a href="#12-1-1-禁用highlight" class="headerlink" title="12.1.1 禁用highlight"></a>12.1.1 禁用highlight</h4><p>打开根目录下的<code>_config.yml</code>文件,修改配置</p><pre><code class="line-numbers language-yml">highlight:enable: falseline_number: falseauto_detect: falsetab_replace:</code></pre><h4 id="12-1-2-获取prism配置文件"><a href="#12-1-2-获取prism配置文件" class="headerlink" title="12.1.2 获取prism配置文件"></a>12.1.2 获取prism配置文件</h4><p>在<a href="https://prismjs.com/download.html">https://prismjs.com/download.html</a>选择喜欢的theme, 需要的language和plug(不推荐选太多,需要的选上即可), 将文件下载到本地后分别重命名为<code>prism.css</code>, <code>prism.js</code>, 将其放入到<code>/theme/matery/source/js/prism</code>目录下(prism文件夹自己创建) </p><h4 id="12-1-3-配置prism"><a href="#12-1-3-配置prism" class="headerlink" title="12.1.3 配置prism"></a>12.1.3 配置prism</h4><ul><li>在<code>themes/matery/layout/_partial/head.ejs</code> 添加以下代码:</li></ul><pre><code class="line-numbers language-ejs">&lt;link rel=&quot;stylesheet&quot; href=&quot;/js/prism/prism.css&quot;&gt;</code></pre><ul><li>在<code>themes/matery/layout/_partial/footer.ejs</code> 添加以下代码:</li></ul><pre><code class="line-numbers language-ejs">&lt;script src=&quot;/js/prism/prism.js&quot; async&gt;&lt;/script&gt;</code></pre><h4 id="12-1-4-添加配置"><a href="#12-1-4-添加配置" class="headerlink" title="12.1.4 添加配置"></a>12.1.4 添加配置</h4><p>在根目录的 <code>_config.yml</code> 文件中添加以下代码:</p><pre><code class="line-numbers language-yml">prism_plugin:    mode: &#39;preprocess&#39;    # realtime/preprocess    theme: &#39;tomorrow&#39;    line_number: false   # default false    custom_css:marked:    langPrefix: line-numbers language-</code></pre><p>此时测试效果如下图所示:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source/blog_images/%E9%AD%94%E6%94%B9hexo%E5%8D%9A%E5%AE%A2/1.png"> </p><h3 id="12-2-添加mac样式"><a href="#12-2-添加mac样式" class="headerlink" title="12.2 添加mac样式"></a>12.2 添加mac样式</h3><h4 id="12-2-1-创建codeblock的js文件"><a href="#12-2-1-创建codeblock的js文件" class="headerlink" title="12.2.1 创建codeblock的js文件"></a>12.2.1 创建codeblock的js文件</h4><p>在目录<code>theme/source/libs/codeBlock/</code>下创建<code>codeBlock.js</code>文件, 在里面添加如下代码:</p><pre><code class="line-numbers language-javascript">// 代码块$(function () &#123;    $(&#39;pre&#39;).wrap(&#39;&lt;div class=&quot;code-area&quot; style=&quot;position: relative&quot;&gt;&lt;/div&gt;&#39;);&#125;);</code></pre><h4 id="12-2-2-添加css样式"><a href="#12-2-2-添加css样式" class="headerlink" title="12.2.2 添加css样式"></a>12.2.2 添加css样式</h4><p>在<code>theme/source/css/matery.css</code>文件中添加:</p><pre><code class="line-numbers language-css">pre &#123;    padding: 2.5rem 1.5rem 1.5rem 1.5rem !important;    margin: 1rem 0 !important;    background: #272822;    overflow: auto;    border-radius: 0.35rem;    tab-size: 4;&#125;.code-area::after &#123;    content: &quot; &quot;;    position: absolute;    border-radius: 50%;    background: #ff5f56;    width: 12px;    height: 12px;    top: 0;    left: 12px;    margin-top: 12px;    -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;    box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;&#125;code &#123;    padding: 1px 5px;    top: 13px !important;    font-family: Inconsolata, Monaco, Consolas, &quot;Courier New&quot;, Courier, monospace;    font-size: 0.91rem;    color: #e96900;    background-color: #f8f8f8;    border-radius: 2px;&#125;pre code &#123;    padding: 0;    color: #e8eaf6;    background-color: #272822;&#125;pre[class*=&quot;language-&quot;] &#123;    padding: 1.2em;    margin: 0.5em 0;&#125;code[class*=&quot;language-&quot;],pre[class*=&quot;language-&quot;] &#123;    color: #e8eaf6;    white-space: pre-wrap !important;&#125;</code></pre><h4 id="12-2-3-调用js文件"><a href="#12-2-3-调用js文件" class="headerlink" title="12.2.3 调用js文件"></a>12.2.3 调用js文件</h4><p>在<code>theme/layout/_partial/post-detail.ejs</code>文件中添加</p><pre><code class="line-numbers language-ejs">&lt;!-- 代码块 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/libs/codeBlock/codeBlockFuction.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="12-3-测试"><a href="#12-3-测试" class="headerlink" title="12.3 测试"></a>12.3 测试</h3><p>执行<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>, 效果如下:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source/blog_images/%E9%AD%94%E6%94%B9hexo%E5%8D%9A%E5%AE%A2/2.png"> </p><h2 id="13-访问速度优化"><a href="#13-访问速度优化" class="headerlink" title="13. 访问速度优化"></a>13. 访问速度优化</h2><h3 id="13-1-静态资源优化"><a href="#13-1-静态资源优化" class="headerlink" title="13.1 静态资源优化"></a>13.1 静态资源优化</h3><h4 id="13-1-1-图片压缩"><a href="#13-1-1-图片压缩" class="headerlink" title="13.1.1 图片压缩"></a>13.1.1 图片压缩</h4><p><a href="https://developers.google.com/speed/webp?hl=zh-cn">WebP</a> 是Google开发的新图像格式,旨在以可接受的视觉质量为无损和有损压缩提供较小的文件大小。有损模式下比 JPEG 小 25% - 34%，无损模式下较 PNG 小 26%,很显然,在相同的用户体验下,使用WebP格式可以提高网站的访问速度.<br>如果你想详细了解这其中的技术细节，可以阅读 Google 开发者文章<a href="https://developers.google.com/speed/webp/docs/compression?hl=zh-cn">WebP压缩技术</a> </p><h5 id="13-1-1-1-优化目标"><a href="#13-1-1-1-优化目标" class="headerlink" title="13.1.1.1 优化目标"></a>13.1.1.1 优化目标</h5><p>使用WebP固然可以优化图像资源,提高访问速度,但截止到目前为止,即便浏览器对WebP的<a href="https://caniuse.com/#search=webp">支持情况</a> 已经接近80%, 却依然有些主流浏览器如 Safari、IE 仍不支持，所以不能直接转用 WebP.<br>由于目前精力有限,故先设定一个优化目标如下:    </p><ul><li>由于压缩图像这项工作重复且繁琐，图像优化应自动化完成,初次配置完成，日后使用无需任何操作便可全自动切换 WebP 图片格式.</li><li>对于不支持的浏览器，会自动回退到 JPEG/PNG 等传统格式</li><li>提前生成好两份文件而非请求时计算，节省算力且响应更迅速</li></ul><h5 id="13-1-1-2-目前已完成-网站首页轮播图"><a href="#13-1-1-2-目前已完成-网站首页轮播图" class="headerlink" title="13.1.1.2 目前已完成(网站首页轮播图)"></a>13.1.1.2 目前已完成(网站首页轮播图)</h5><p>这里使用一个开源工具: <a href="https://github.com/Jacksgong/webp-converter">Webp Converter and Analytics</a>, 具体使用方法在项目介绍页,这里不再赘述.<br>只是暂时使用这个工具,因为我的博客目前图片资源大的就是首页轮播图,这只是一个暂时的解决方案,因为需要手动(懒)…</p><h4 id="13-1-2-HTML压缩"><a href="#13-1-2-HTML压缩" class="headerlink" title="13.1.2 HTML压缩"></a>13.1.2 HTML压缩</h4><p>待定</p><h4 id="13-1-3-CSS压缩"><a href="#13-1-3-CSS压缩" class="headerlink" title="13.1.3 CSS压缩"></a>13.1.3 CSS压缩</h4><p>待定</p><h3 id="13-2-静态资源加载优化"><a href="#13-2-静态资源加载优化" class="headerlink" title="13.2 静态资源加载优化"></a>13.2 静态资源加载优化</h3><h4 id="13-2-1-使用CDN"><a href="#13-2-1-使用CDN" class="headerlink" title="13.2.1 使用CDN"></a>13.2.1 使用CDN</h4><p>参考<a href="https://godliuyang.wang/2020/09/15/cdn-for-blog/">CDN for Blog</a> </p><h2 id="14-添加推荐文章插件-hexo-recommended-posts"><a href="#14-添加推荐文章插件-hexo-recommended-posts" class="headerlink" title="14. 添加推荐文章插件(hexo-recommended-posts)"></a>14. 添加推荐文章插件(<a href="https://github.com/huiwang/hexo-recommended-posts">hexo-recommended-posts</a>)</h2><p>推荐文章的插件有很多, <a href="https://github.com/tea3/hexo-related-popular-posts">hexo-related-popular-posts</a> 是一个很棒的插件, 安装也很简单,不过我这里使用的是<code>hexo-recommended-posts</code></p><h3 id="14-1-安装"><a href="#14-1-安装" class="headerlink" title="14.1 安装"></a>14.1 安装</h3><pre><code class="line-numbers language-bash">npm install hexo-recommended-posts --save</code></pre><h3 id="14-2-下载推荐文章列表"><a href="#14-2-下载推荐文章列表" class="headerlink" title="14.2 下载推荐文章列表"></a>14.2 下载推荐文章列表</h3><pre><code class="line-numbers language-bash">hexo recommend</code></pre><h3 id="14-3-自定义配置"><a href="#14-3-自定义配置" class="headerlink" title="14.3 自定义配置"></a>14.3 自定义配置</h3><p>在博客根目录添加以下默认配置,根据个人情况修改</p><pre><code class="line-numbers language-yml">recommended_posts:  server: https://api.truelaurel.com #后端推荐服务器地址  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式  internalLinks: 3 #内部文章数量  externalLinks: 1 #外部文章数量  fixedNumber: false #控制是否返回固定数量的推荐文章, 如果默认推荐文章不够的话会填充当前文章的前后文章作为推荐文章.  autoDisplay: true #自动在文章底部显示推荐文章  excludePattern: [] #添加想要被过滤的链接的正则表达式, 如配置为 [&quot;example.com&quot;], 则所有包含 example.com 的链接都会从推荐文章中过滤掉.  titleHtml: &lt;h1&gt;推荐文章&lt;span style=&quot;font-size:0.45em; color:gray&quot;&gt;（由&lt;a href=&quot;https://github.com/huiwang/hexo-recommended-posts&quot;&gt;hexo文章推荐插件&lt;/a&gt;驱动）&lt;/span&gt;&lt;/h1&gt; #自定义标题</code></pre><h3 id="14-4-一点小改动"><a href="#14-4-一点小改动" class="headerlink" title="14.4 一点小改动"></a>14.4 一点小改动</h3><p>插件虽然有<code>autoDisplay</code>选项来控制是否在文章底部显示文章,但在配置文件中竟然没有一个选项来控制是否启用插件,这不能忍,于是我修改了一点插件的代码,实现了这个功能,具体实现如下:</p><ul><li><p>编辑<code>hexo-recommended-posts/lib/recommend.js</code>文件,第二行修改为</p><pre><code class="line-numbers language-javascript">var posts = filterPosts(recommended_posts, post, config.excludePattern, config.enable)</code></pre><p>第九行修改为</p><pre><code class="line-numbers language-javascript">function filterPosts(recommended_posts, post, excludePattern, enable) &#123;  if (recommended_posts === undefined || !enable ||      recommended_posts[post.permalink] === undefined) &#123;      return [];  &#125;</code></pre></li><li><p>在根目录config中添加<code>enable</code>选项,具体如下:</p><pre><code class="line-numbers language-yml">recommended_posts:  enable: trueserver: https://api.truelaurel.com #后端推荐服务器地址timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式internalLinks: 3 #内部文章数量externalLinks: 1 #外部文章数量fixedNumber: false #控制是否返回固定数量的推荐文章, 如果默认推荐文章不够的话会填充当前文章的前后文章作为推荐文章.autoDisplay: true #自动在文章底部显示推荐文章excludePattern: [] #添加想要被过滤的链接的正则表达式, 如配置为 [&quot;example.com&quot;], 则所有包含 example.com 的链接都会从推荐文章中过滤掉.titleHtml: &lt;h1&gt;推荐文章&lt;span style=&quot;font-size:0.45em; color:gray&quot;&gt;（由&lt;a href=&quot;https://github.com/huiwang/hexo-recommended-posts&quot;&gt;hexo文章推荐插件&lt;/a&gt;驱动）&lt;/span&gt;&lt;/h1&gt; #自定义标题</code></pre></li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="2020-12-07"><a href="#2020-12-07" class="headerlink" title="2020.12.07"></a>2020.12.07</h3><ul><li>添加<code>hexo-recommended-posts</code>插件</li></ul><h3 id="2020-12-06"><a href="#2020-12-06" class="headerlink" title="2020.12.06"></a>2020.12.06</h3><ul><li>优化图片资源(首页轮播图)</li></ul><h3 id="2020-12-05"><a href="#2020-12-05" class="headerlink" title="2020.12.05"></a>2020.12.05</h3><ul><li>修复了一个 <code>ClustrMaps</code> 未统计访客的bug</li><li>默认不开启看板娘(太占用cpu内存,影响用户体验)</li></ul><h3 id="2020-11-22"><a href="#2020-11-22" class="headerlink" title="2020.11.22"></a>2020.11.22</h3><ul><li>使用<a href="https://github.com/fengkx/hexo-native-lazy-load">hexo-native-lazy-load</a> 代替<a href="https://github.com/Troy-Yang/hexo-lazyload-image">hexo-lazyload-image</a> </li></ul><h3 id="2020-11-16"><a href="#2020-11-16" class="headerlink" title="2020.11.16"></a>2020.11.16</h3><ul><li>添加网站背景图, 添加腾讯兔小巢</li><li>添加Mac样式的代码块</li></ul><h3 id="2020-11-15"><a href="#2020-11-15" class="headerlink" title="2020.11.15"></a>2020.11.15</h3><ul><li>删除冗余脚本, 模块化插件</li><li>使用<a href="https://deserts.io/valine-admin-document/">valine-admin</a>实现评论邮件提醒</li><li>修复黑夜模式bug, 现已完美运行</li></ul><h3 id="2020-11-14"><a href="#2020-11-14" class="headerlink" title="2020.11.14"></a>2020.11.14</h3><ul><li>加入文章更新日期</li><li>添加<a href="https://clustrmaps.com/">ClustrMaps</a>访客地图统计(从即日起)<ul><li>可通过config文件切换地图的样式</li><li>目前在pc端访问globe样式无法加载, 移动端则正常(bug)</li></ul></li></ul><h3 id="2020-09-25"><a href="#2020-09-25" class="headerlink" title="2020.09.25"></a>2020.09.25</h3><ul><li>加入黑夜模式</li><li>试运行黑夜模式</li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/15/cdn-for-blog/">CDN_for_blog</a></li><li><a href="https://godliuyang.wang/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/">Arch Linux + i3wm详细配置篇</a></li><li><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/">Manjaro i3wm 高效率环境配置篇(持续更新)</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN_for_blog</title>
      <link href="/2020/09/15/cdn-for-blog/"/>
      <url>/2020/09/15/cdn-for-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-CND"><a href="#Why-CND" class="headerlink" title="Why CND?"></a>Why CND?</h2><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><h2 id="USE-CDN"><a href="#USE-CDN" class="headerlink" title="USE CDN"></a>USE CDN</h2><ol><li>创建一个名为CDN的github仓库</li><li>把仓库clone到本地</li><li>将图片文件存储到仓库中并上传<br>注：jsDelivr不支持加载超过20M的资源</li><li>发布仓库</li></ol><ul><li>点击release发布仓库<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CDN_for_blog/release.jpg">  </li><li>注明版本号后发布<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CDN_for_blog/release_number.jpg"> </li></ul><ol start="5"><li>通过如下形式来使用</li></ol><pre><code>// load any GitHub release, commit, or branch// note: we recommend using npm for projects that support ithttps://cdn.jsdelivr.net/gh/user/repo@version/file</code></pre><p>例如：在我的github仓库中有这么一个文件</p><p><a href="https://github.com/liuyaanng/CDN/blob/1.02/blog_images/CDN_for_blog/release.jpg">https://github.com/liuyaanng/CDN/blob/1.02/blog_images/CDN_for_blog/release.jpg</a></p><p>使用jsdelivr加速访问就是：</p><p><a href="https://cdn.jsdelivr.net/gh/liuyaanng/CDN@1.02/blog_images/CDN_for_blog/release.jpg">https://cdn.jsdelivr.net/gh/liuyaanng/CDN@1.02/blog_images/CDN_for_blog/release.jpg</a> </p><p>其中<strong>1.02</strong>是我发布的版本号，当然也可以使用模糊版本号的方法进行访问，无论哪种形式，都可以明显的感觉到访问速度快了很多。</p><p>另外，在我使用的过程中，发现在第一次发布之后，以后在使用图片可将版本号换成<code>master</code>直接访问。</p><h2 id="Generate-Jsdelivr-Link"><a href="#Generate-Jsdelivr-Link" class="headerlink" title="Generate Jsdelivr Link"></a>Generate Jsdelivr Link</h2><h3 id="1-使用脚本生成-更优解见2"><a href="#1-使用脚本生成-更优解见2" class="headerlink" title="1. 使用脚本生成  **更优解见2 **"></a><del>1. 使用脚本生成</del>  **更优解见<a href="#toc-heading-5">2</a> **</h3><ul><li>我写博客的截图均是由<a href="https://zh.xnipapp.com/">Xnip</a> 生成，截图文件存储目录<code>Pictures/Xnip</code>,故我写了一个小脚本来实现</li></ul><pre><code class="line-numbers language-bash">#!/bin/bash# @author:liuyaanngrep_path=~/Github/Myrep/CDN/blog_photo_folder=blog_imagespath=~/Pictures/Xnipprefix=https://cdn.jsdelivr.net/gh/liuyaanng/CDN@files=$(ls $path)check_v=0check_f=0help_text=&quot;This is a script for move the picture files to github, and get the jsdelivr link quickly. This scripts run with 2 arguments.\n1. cdn_server.sh -v version -f folder. version is the release version,folder is the pictures&#39;s file folder. \nfor example: cdn_server.sh -v 1.0 -f cdn_for_blog, it will get\nhttps://cdn.jsdelivr.net/gh/liuyaanng/CDN@1.0/blog_images/cdn_for_blog/filename\nif you do not use version, please use:cdn_server.sh -v master -f foldername.2. cdn_server.sh -h    Show help content.&quot;while getopts :v:f:h optdo    case &quot;$opt&quot; in        v) version=$OPTARG             check_v=1;;        f) folder=$OPTARG             check_f=1;;        h) echo -e $help_text             exit 1;;        ?) echo &quot;sync error. Use &#39;cdn_server.sh -h&#39; for help.&quot;;;    esacdoneprint_link()&#123;if [ ! -n &quot;$files&quot; ]; then    echo &quot;There is no file in Xnip folder.&quot;else    for filename in $files    do        echo $prefix$version/$blog_photo_folder/$folder/$filename        mv $path/* $rep_path$blog_photo_folder/$folder        echo &quot;move file $filename success&quot;    done    cd $rep_path    git add .    git commit -m &quot;upload $folder&quot;    git pushfi&#125;if [ $check_v -eq $check_f ]; then    print_linkelse    echo &quot;need 2 args but given 1.&quot;fi</code></pre><p>该脚本有以下功能：</p><ol><li>将截图转到github仓库中并提交</li><li>自动生成jsdelivr链接</li></ol><p>如果你想使用的话只需修改上面的路径信息就行了。</p><p>脚本有两个参数，你可以用<code>cdn_server.sh -h</code> 来查看帮助信息。</p><ol><li><code>-a version</code>. <code>-a</code>参数后跟发布的版本号</li><li><code>-f folder</code>. <code>-f</code>参数后跟仓库中文件夹名</li></ol><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源. 若不想指定版本号（第一次发布之后可用），可以直接使用 <code>-a master</code>.</p><p>例如：</p><pre><code class="line-numbers language-bash">cdn_server.sh -a master -f CDN_for_blog</code></pre><h3 id='1'> 2. 使用PicGO工具实现一键上传并生成CDN链接</h3><p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a><br>文档太详细,不想做过多介绍了</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2019/07/22/hexo-da-keng/">hexo大坑</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> jsdelivr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode EASY_9</title>
      <link href="/2020/08/17/leetcode-easy-9/"/>
      <url>/2020/08/17/leetcode-easy-9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</li></ul><p>示例：</p><pre><code>输入：121输出：True</code></pre><pre><code>输入：-121输出：False</code></pre><ul><li><p>思路1：将数字转化为字符串形式，分别进行头尾判断数字是否一致。<br>实现需要3步：</p><p>预判断：<br>首先判断当输入数字为负数或其个位数字是0（排除0）时一定输出False</p><pre><code class="line-numbers language-python">if (x &lt; 0 or (x % 10 == 0 and x!= 0)):    return False</code></pre><ul><li><p>将输入转化为字符串</p><pre><code class="line-numbers language-python3">x_str = str(x)</code></pre></li><li><p>分割字符串，不能用split方法。这里因为当输入为奇数时，数字中间的一位对结果无影响，故将这一位删掉。</p><pre><code class="line-numbers language-python3">x_list = []for x_s in x_str:  x_list.append(x_s)if num != num_i:  x_list.pop(num_i)</code></pre></li><li><p>判断是否为回文数。采用循环判断，从中间往两边依次判断，注意这里只要有一位不相同就会输出False</p></li></ul></li></ul><p>程序完整代码如下：</p><pre><code class="line-numbers language-python">if (x &lt; 0 or (x % 10 == 0 and x!= 0)):    return False    x_str = str(x)num = len(x_str) / 2 num_i = len(x_str) // 2x_list = []for x_s in x_str:    x_list.append(x_s)if num != num_i:    x_list.pop(num_i)i = 0result = Truewhile i &lt; num_i:    if x_list[num_i + i] == x_list[num_i - (i + 1)]:        result = True    else:        result = False        return result    i += 1return result</code></pre><p>在参考了LeetCode官网解法之后，发现了类似思路更简单的解法，代码如下：</p><pre><code class="line-numbers language-python">return (str(x) == str(x)[::-1])</code></pre><p>只需判断输入数字的一半即可判断结果，故可改进如下：</p><pre><code class="line-numbers language-python">x_str = str(x)x_len = len(x_str)x_h = x_len // 2return (x_str[:x_h] == x_str[-1:-x_h - 1:-1])</code></pre><p>以上方法均将输入转化为字符串之后再进行判断</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><p>你能不将整数转为字符串来解决这个问题吗？</p><ul><li>思路2: 将数字反转，然后将反转得到的数字与原始数字进行比较，两者相同则是回文数。但这时要考虑到溢出问题，反转得到的数字可能会大于整数的最大值。为了避免这个问题，考虑只反转输入数字的一半，若后一半反转后与前一半相同则是回文数。算法考虑如下：<ul><li>预判断如上</li><li>设置一个反转数，将输入数字除10求余，得到的数字是反转数的首位，依次循环，可得到一系列的反转数，x的值会越来越小，而反转数的值会越来越大。对于偶数来说，循环终止的条件很简单，就是当x等于反转数，对于奇数来说，循环终止的条件是x小于反转数，随后判断此时的x与反转数是否相同。注意：对于奇数来说，判断条件是x是否等于反转数除10取整的值，因为奇数多了一轮迭代。</li></ul></li></ul><p>完整代码如下：</p><pre><code class="line-numbers language-python">if (x &lt; 0 or (x % 10 == 0 and x != 0)):    return Falsex_reversed = 0while x_reversed &lt; x:    x_reversed = x_reversed * 10 + x % 10    x = x // 10return (x == x_reversed or x == x_reversed // 10)</code></pre><p>C代码如下：</p><pre><code class="line-numbers language-C">bool isPalindrome(int x)&#123;if (x&lt;0 || (x%10 == 0 &amp;&amp; x != 0))&#123;    return false;&#125;int x_reversed = 0;while (x_reversed &lt; x)&#123;    x_reversed = x_reversed * 10 + x % 10;     x = x / 10;&#125;return (x == x_reversed || x == x_reversed / 10);&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(log n) ，对于每次迭代，都将输入除以n，故时间复杂度为O(log n)</li><li>空间复杂度： O(1). 只需在常数空间存储若干变量。</li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/03/30/scikit-image-guide/">scikit-image guide</a></li><li><a href="https://godliuyang.wang/2020/01/29/sort/">SORT</a></li><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLSW</title>
      <link href="/2020/04/22/clsw/"/>
      <url>/2020/04/22/clsw/</url>
      
        <content type="html"><![CDATA[<p><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/#toc-heading-14">Install and Configure guide</a> </p><p><a href="https://github.com/liuyaanng/CLSW">My config</a> </p><h2 id="1-Vim-Neovim"><a href="#1-Vim-Neovim" class="headerlink" title="1. Vim(Neovim)"></a>1. Vim(Neovim)</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/vim_cheat_sheet.png" alt="vim cheat sheet"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/nvim.png" alt="Vim"></p><h2 id="2-Ranger"><a href="#2-Ranger" class="headerlink" title="2. Ranger"></a>2. Ranger</h2><ul><li><p>If you want a tool to preview images or other file type can preview as images (pdf, videos), i recommended ueberzug , but note, you should use ranger-git by <code>yaourt -S ranger-git</code></p></li><li><p>If you are a Mac user, iterm2 is enough to preview images.</p></li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/ranger.png" alt="Ranger"> </p><h2 id="3-Fish"><a href="#3-Fish" class="headerlink" title="3. Fish"></a>3. Fish</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/Fish.png" alt="Fish"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GPU servers</title>
      <link href="/2020/04/21/gpu-servers/"/>
      <url>/2020/04/21/gpu-servers/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的任务是在GPU服务器上使用深度强化学习训练Amazing Brick，Amazing Brick使用Python的<a href="https://arcade.academy/index.html">Arcade</a> 库来写的。    </p><p>我在考虑在GPU服务器上训练之前，没有注意到Arcade是使用<strong>OpenGL</strong> 和<strong>Pyglet</strong> 来进行渲染的</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/ArcadeVSPygame.png" alt="Arcade VS Pygame"></p><p>而服务器大多都以ssh登陆，而OpenGL就更不要说了，所以在我寻找服务器和准备环境的过程中就遇到了很多问题，这个在下面会说到。</p><h2 id="GPU-servers"><a href="#GPU-servers" class="headerlink" title="GPU servers"></a>GPU servers</h2><p>  <a href="https://www.zhihu.com/question/51707286">知乎:目前哪里可以租用到GPU服务器？</a> </p><hr><ul><li><a href="https://aistudio.baidu.com/aistudio/index">AI Studio</a></li></ul><p>非常良心，用算力可以获得算力，不怕你用，用得多送的多。<br>这里有一位同学写的攻略<a href="https://zhuanlan.zhihu.com/p/73361554?utm_source=wechat_session&utm_medium=social&utm_oi=28323023421440">薅薅国产免费GPU计算资源</a><br>登陆方式有 <strong>notebook</strong> ,可使用 <strong>Terminal</strong> ,但没有root权限，这就意味着有很多限制，最重要的是预装框架为 <strong>PaddlePaddle</strong> .  不能用 <code>TensorFlow</code>, 总不能为了嫖GPU服务器再去学一种框架吧，别担心, 这里有<a href="https://www.zhihu.com/question/336485090">百度paddlepaddle平台如何配置tensorflow-gpu</a>. 这个我没有尝试，有兴趣的可以尝试一下（有空了我会来填这个坑）</p><ul><li><a href="https://www.easyaiforum.cn/">易学智能</a> </li></ul><p>我现在使用的就是这个</p><p>感谢<a href="https://www.paratera.com/liveInterface.html">并行超算</a> 给我提供的50算力的试用，我就是靠着这50算力把环境给搭明白了哈哈哈。</p><ul><li>…</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-Ubuntu"><a href="#1-Ubuntu" class="headerlink" title="1. Ubuntu"></a>1. Ubuntu</h3><p>GPU 配置可根据自己的需要调整<br>我选择的是：</p><pre><code>OS: UbuntuGPU: RTX 2080TICPU: E5 4COREMEMARY: 15GENVIROMENT: Python 3.6 + TF 2.0</code></pre><p>这里的环境使开箱即用的，不需要激活</p><ol><li>基本包安装</li></ol><pre><code class="line-numbers language-bash">pip install arcade dataclasses scikit-image</code></pre><ol start="2"><li>测试arcade环境</li></ol><ul><li>Arcade 官方的一个小demo</li></ul><pre><code class="line-numbers language-python">&quot;&quot;&quot;Drawing an example happy faceIf Python and Arcade are installed, this example can be run from the command line with:python -m arcade.examples.happy_face&quot;&quot;&quot;import arcade# Set constants for the screen sizeSCREEN_WIDTH = 600SCREEN_HEIGHT = 600SCREEN_TITLE = &quot;Happy Face Example&quot;# Open the window. Set the window title and dimensionsarcade.open_window(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)# Set the background colorarcade.set_background_color(arcade.color.WHITE)# Clear screen and start render processarcade.start_render()# --- Drawing Commands Will Go Here ---# Draw the facex = 300y = 300radius = 200arcade.draw_circle_filled(x, y, radius, arcade.color.YELLOW)# Draw the right eyex = 370y = 350radius = 20arcade.draw_circle_filled(x, y, radius, arcade.color.BLACK)# Draw the left eyex = 230y = 350radius = 20arcade.draw_circle_filled(x, y, radius, arcade.color.BLACK)# Draw the smilex = 300y = 280width = 120height = 100start_angle = 190end_angle = 350arcade.draw_arc_outline(x, y, width, height, arcade.color.BLACK,                        start_angle, end_angle, 10)# Finish drawing and display the resultarcade.finish_render()# Keep the window open until the user hits the &#39;close&#39; buttonarcade.run()</code></pre><ul><li><p>-&gt;运行发现报错：<code>ImportError: Library “GLU” not found</code></p><p>解决办法：<a href="https://stackoverflow.com/questions/50446867/importerror-library-glu-not-found"><code>sudo apt-get install freeglut3-dev</code></a> </p></li><li><p>-&gt;再次运行报错：<code>pyglet.canvas.xlib.NoSuchDisplayException: Cannot connect to &quot;None&quot;</code></p><p>原因大概是arcade调用<code>pyglet</code>绘制窗口需要图形界面（就是弹出来的那个框框），而当你使用ssh连接server时是没有图形界面的。<br>因此我们需要一个虚拟的图形界面，而<a href="https://linux.die.net/man/1/xvfb"><code>xvfb-run</code></a>就是一个提供虚拟图形界面的工具。<br>这里有一篇文章是介绍如何使用<code>xvfb</code>来创建一个虚拟桌面来进行服务器端的图形测试的。</p><p><a href="http://elementalselenium.com/tips/38-headless">How To Run Your Tests Headlessly with Xvfb</a></p><p>安装<code>xvfb</code>之前要先更新一下 <code>sudo apt update</code>, 如果遇到密钥不可用可以<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 密钥</code></p></li><li><p>-&gt;使用<code>xvfb-run -a python xxx.py</code> 来继续测试报错：<code>arcade.application.NoOpenGLException:  Unable to create an OpenGL 3.3+ context. Check to make sure your system supports OpenGL 3.3 or higher.</code>     </p><p>意思是OpenCV版本太低</p></li><li><p>接下来查看服务器端的OpenGL版本，使用<code>glxinfo | grep &quot;OpenGL&quot;</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/opencv_version.png" alt="opencv_version"> </p><p>还是没有图形界面的问题，继续使用<code>xvfb-run -a glxinfo | grep &quot;OpenGL&quot;</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/opencv_version2.png" alt="opencv_version"> </p><p>显示OpenGL的版本为3.1, 依旧无法满足arcade需要的OpenGL3+。</p></li><li><p>会不会是由于服务端原机器上的低版本OpenGL造成<code>xvfb</code>虚拟后的OpenCV版本较低？</p><p>我在本地的Ubuntu系统上分别运行<code>glxinfo | grep &quot;OpenGL&quot;</code>, 发现原机器版本为4.6，但<code>xvfb</code>虚拟后的版本为3.1，推测为<code>Xvfb</code>虚拟图形界面的原因。</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/glxinfo.png"></p><p>此问题没有找到解决办法</p></li><li><p>⚠️ 如果你是一个<code>pygame</code>用户，或者你对OpenGL的版本要求不高（3.1），你完全可以使用<code>xvfb-run</code>来进行要求图形化的测试。经测试，pygame在GPU服务器上可以运行。</p></li></ul><p>既然Ubuntu无法完成我的工作，故我开始使用Windows</p><h3 id="2-Windows-10"><a href="#2-Windows-10" class="headerlink" title="2. Windows 10"></a>2. Windows 10</h3><p>系统配置</p><pre><code>OS: Windows 10GPU: RTX 2080TICPU: I5</code></pre><ul><li>进入系统要先激活环境,详细信息见<a href="https://www.easyaiforum.cn/helpDocument?manual_id=136">帮助文档</a> </li></ul><pre><code class="line-numbers language-bash">conda activate py36h</code></pre><ul><li><p>安装基本包和Ubuntu一样，测试的时候发现依旧存在<code>OpenGL</code>的问题,查看OpenGL版本为1.1</p><p>这里给几个查看OpenGL的工具：</p><ul><li>GPU_Caps_Viewer: 链接: <a href="https://pan.baidu.com/s/1_YisKqKJY_2Uml2MQXKnNQ">https://pan.baidu.com/s/1_YisKqKJY_2Uml2MQXKnNQ</a> 提取码: use7</li><li>GLViewer: 链接: <a href="https://pan.baidu.com/s/1G2GR5S9oSqatMmBqv5YLdA">https://pan.baidu.com/s/1G2GR5S9oSqatMmBqv5YLdA</a> 提取码: 27s2</li></ul></li><li><p>更新OpenGL</p><p>更新显卡驱动即可: <a href="https://www.nvidia.com/Download/index.aspx#">NVIDIA Driver Downloads</a> , 下载对应版本的驱动安装。</p><p>我在网上找到很多说用 驱动精灵， 鲁大师等软件更新驱动，我试了一下，完全不起作用。官网驱动亲测可行，就是有点耗时间。</p></li><li><p>更新完OpenGL之后代码就可以快乐地训练啦</p></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/05/09/use-tensorflow-in-ai-studio/">Use Tensorflow in AI Studio</a></li><li><a href="https://godliuyang.wang/2019/08/07/enjoy-pytorch/">Enjoy PyTorch</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-image guide</title>
      <link href="/2020/03/30/scikit-image-guide/"/>
      <url>/2020/03/30/scikit-image-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="Python的数字图片处理包。比如-PIL-pillow-opencv-scikit-image"><a href="#Python的数字图片处理包。比如-PIL-pillow-opencv-scikit-image" class="headerlink" title="Python的数字图片处理包。比如 PIL, pillow, opencv, scikit-image"></a>Python的数字图片处理包。比如 PIL, pillow, opencv, scikit-image</h1><p>PIL和pillow只提供最基础的数字图像处理，功能有限；opencv实际上是一个c++库，只提供了python借口，更新速度非常慢。scikit-image是基于scipy的一款图像处理包，它将图片作为numpy数组进行处理，与matlab一样，所以我选择了是scikit-image进行图像处理</p><h2 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h2><pre><code class="line-numbers language-bash">conda install -c conda-forge scikit-image</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/08/17/leetcode-easy-9/">LeetCode EASY_9</a></li><li><a href="https://godliuyang.wang/2020/01/29/sort/">SORT</a></li><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Proxy</title>
      <link href="/2020/02/04/about-proxy/"/>
      <url>/2020/02/04/about-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="About-Proxy"><a href="#About-Proxy" class="headerlink" title="About Proxy"></a>About Proxy</h1><p><del>Script: <a href="https://github.com/liuyaanng/SSR">SSR</a></del>  SSR seems very unstable, i use <strong>v2ray</strong> now.</p><p>Ping test: <a href="http://ping.chinaz.com/">ping</a> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/1.png" alt="Youtube speed"> </p><h2 id="V2Ray"><a href="#V2Ray" class="headerlink" title="V2Ray"></a>V2Ray</h2><p>Preconditions:</p><ul><li>a VPS: <a href="https://www.vultr.com/">vultr</a>( $5/m , i uesd now) , <a href="https://billing.virmach.com/cart.php">VIRMACH</a>( $1.25/m)</li><li>a Domain: (<a href="https://www.namesilo.com/">Namesilo</a>($0.99), <a href="https://www.freenom.com/">Freenom</a>(free) )</li><li>VPS OS version: Debian 9+ / Ubuntu 18.04+ / CentOS 7+</li></ul><h3 id="1-Resolve-the-domain-to-the-IP-of-your-VPS"><a href="#1-Resolve-the-domain-to-the-IP-of-your-VPS" class="headerlink" title="1. Resolve the domain to the IP of your VPS"></a>1. Resolve the domain to the IP of your VPS</h3><p><a href="https://www.cloudflare.com/">Cloudflare</a> </p><h4 id="1-Add-site"><a href="#1-Add-site" class="headerlink" title="1. Add site"></a>1. Add site</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/2.png"> </p><h4 id="2-Change-your-domain-NS"><a href="#2-Change-your-domain-NS" class="headerlink" title="2. Change your domain NS"></a>2. Change your domain NS</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/5.png"> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/3.png"> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/4.png"> </p><h4 id="3-Add-record"><a href="#3-Add-record" class="headerlink" title="3. Add record"></a>3. Add record</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/6.png"> </p><p><del>You can light the cloud icon to use a proxy which can hidden real ip. ~</del> it is possible to make v2ray doesn’t work.</p><p>NOTE: <strong>Do it after installed V2Ray if u need it</strong></p><h4 id="4-Ping"><a href="#4-Ping" class="headerlink" title="4. Ping"></a>4. Ping</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/7.png"> </p><p>it works.</p><h3 id="2-Set-BBR-lotserver"><a href="#2-Set-BBR-lotserver" class="headerlink" title="2. Set BBR lotserver"></a>2. Set BBR lotserver</h3><pre><code class="line-numbers language-bash">wget --no-check-certificate https://raw.githubusercontent.com/liuyaanng/SSR/master/tcp.sh &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/8.png"> </p><h3 id="3-Install-V2Ray"><a href="#3-Install-V2Ray" class="headerlink" title="3. Install V2Ray"></a>3. Install V2Ray</h3><p>There are two way to install V2Ray use different methods.</p><ul><li>Vmess+websocket+TLS+Nginx+Website</li></ul><pre><code class="line-numbers language-bash">bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) | tee v2ray_ins.log</code></pre><ul><li>Vmess + HTTP2 over TLS</li></ul><pre><code class="line-numbers language-bash">bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install_h2.sh) | tee v2ray_ins_h2.log</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/9.png"> </p><p>SELF TESTING</p><h3 id="4-Run-V2Ray"><a href="#4-Run-V2Ray" class="headerlink" title="4. Run V2Ray"></a>4. Run V2Ray</h3><ul><li>start v2ray: <code>systemctl start v2ray</code></li><li>stop v2ray: <code>systemctl stop v2ray</code></li><li>start nginx: <code>systemctl start nginx</code></li><li>stop nginx: <code>systemctl stop nginx</code></li></ul><h3 id="5-V2Ray-client"><a href="#5-V2Ray-client" class="headerlink" title="5. V2Ray client"></a>5. V2Ray client</h3><ul><li><p>Windows: </p><ul><li><a href="https://tlanyan.me/download.php?filename=/v2/windows/v2rayN-v3.5.zip">V2RayN</a> </li></ul></li><li><p>MacOS:</p><ul><li><a href="https://tlanyan.me/download.php?filename=/v2/macos/v2rayU-v1.5.1.dmg">V2RayU</a> </li><li><a href="https://github.com/yichengchen/clashX/releases/download/1.18.2/ClashX.dmg">ClashX</a> (what i use now)</li></ul></li><li><p>Linux:</p><ul><li><p><a href="https://www.jianshu.com/p/a5b6d9dc0441">link</a> </p></li><li><p><a href="https://snapcraft.io/install/v2ray-core/arch#install">Snap</a></p></li><li><p>Configuration V2Ray</p><p>config file is located in <code>/etc/v2ray/config.json</code></p><pre><code class="line-numbers language-bash">&#123;&quot;policy&quot;: null,&quot;log&quot;: &#123;&quot;access&quot;: &quot;&quot;,&quot;error&quot;: &quot;&quot;,&quot;loglevel&quot;: &quot;warning&quot;&#125;,&quot;inbounds&quot;: [&#123;  &quot;tag&quot;: &quot;proxy&quot;,  &quot;port&quot;: 1080,  &quot;listen&quot;: &quot;127.0.0.1&quot;,  &quot;protocol&quot;: &quot;socks&quot;,  &quot;sniffing&quot;: &#123;    &quot;enabled&quot;: true,    &quot;destOverride&quot;: [      &quot;http&quot;,      &quot;tls&quot;    ]  &#125;,  &quot;settings&quot;: &#123;    &quot;auth&quot;: &quot;noauth&quot;,    &quot;udp&quot;: true,    &quot;ip&quot;: null,    &quot;address&quot;: null,    &quot;clients&quot;: null  &#125;,  &quot;streamSettings&quot;: null&#125;],&quot;outbounds&quot;: [&#123;  &quot;tag&quot;: &quot;proxy&quot;,  &quot;protocol&quot;: &quot;vmess&quot;,  &quot;settings&quot;: &#123;    &quot;vnext&quot;: [      &#123;        &quot;address&quot;: &quot; &quot;, //your domain address        &quot;port&quot;:  ,   //port        &quot;users&quot;: [          &#123;            &quot;id&quot;: &quot; &quot;,   //id            &quot;alterId&quot;: 2,            &quot;email&quot;: &quot;t@t.tt&quot;,            &quot;security&quot;: &quot;auto&quot;          &#125;        ]      &#125;    ],    &quot;servers&quot;: null,    &quot;response&quot;: null  &#125;,    &quot;streamSettings&quot;: &#123;    &quot;network&quot;: &quot;ws&quot;,    &quot;security&quot;: &quot;tls&quot;,    &quot;tlsSettings&quot;: &#123;      &quot;allowInsecure&quot;: true,      &quot;serverName&quot;: &quot; &quot;    //domain address    &#125;,    &quot;tcpSettings&quot;: null,    &quot;kcpSettings&quot;: null,    &quot;wsSettings&quot;: &#123;      &quot;connectionReuse&quot;: true,      &quot;path&quot;: &quot;/e3137ae7/&quot;,   //path      &quot;headers&quot;: &#123;        &quot;Host&quot;: &quot; &quot;  //domain address      &#125;    &#125;,    &quot;httpSettings&quot;: null,    &quot;quicSettings&quot;: null  &#125;,  &quot;mux&quot;: &#123;    &quot;enabled&quot;: true,    &quot;concurrency&quot;: 8  &#125;&#125;,&#123;  &quot;tag&quot;: &quot;direct&quot;,  &quot;protocol&quot;: &quot;freedom&quot;,  &quot;settings&quot;: &#123;    &quot;vnext&quot;: null,    &quot;servers&quot;: null,    &quot;response&quot;: null  &#125;,  &quot;streamSettings&quot;: null,  &quot;mux&quot;: null&#125;,&#123;  &quot;tag&quot;: &quot;block&quot;,  &quot;protocol&quot;: &quot;blackhole&quot;,  &quot;settings&quot;: &#123;    &quot;vnext&quot;: null,    &quot;servers&quot;: null,    &quot;response&quot;: &#123;      &quot;type&quot;: &quot;http&quot;    &#125;  &#125;,  &quot;streamSettings&quot;: null,  &quot;mux&quot;: null&#125;],&quot;stats&quot;: null,&quot;api&quot;: null,&quot;dns&quot;: null,&quot;routing&quot;: &#123;&quot;domainStrategy&quot;: &quot;IPIfNonMatch&quot;,&quot;rules&quot;: [  &#123;    &quot;type&quot;: &quot;field&quot;,    &quot;port&quot;: null,    &quot;inboundTag&quot;: [      &quot;api&quot;    ],    &quot;outboundTag&quot;: &quot;api&quot;,    &quot;ip&quot;: null,    &quot;domain&quot;: null  &#125;]&#125;&#125;</code></pre></li></ul></li></ul><h2 id="Terminal-Proxy"><a href="#Terminal-Proxy" class="headerlink" title="Terminal Proxy"></a>Terminal Proxy</h2><h3 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h3><p>i can make some terminal commands run with proxy. But it seems can’t work on my computer. Sad. Anyway, i still share the way to install and configure.</p><ul><li>Installation</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S proxychains</code></pre><p>Or you can install it from source code. (make sure your <code>gcc</code> installed)</p><pre><code class="line-numbers language-bash">git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuresudo make &amp;&amp; make installsudo make install-config(generate config file)</code></pre><ul><li>Configuration<br>config file is saved in <code>/etc/proxychains.conf</code></li></ul><p>Add <code>socks5  127.0.0.1 1080</code> to the end. note the space!</p><ul><li>Use</li></ul><p>Add <code>proxychains</code> before the terminal commands.</p><pre><code class="line-numbers language-bash">proxychains git clone https://github.com/rofl0r/proxychains-ng</code></pre><p>you can run <code>npm</code> , <code>docker</code> … But <code>ping</code> command is not suitable, because proxychains can only proxy <strong>TCP</strong>, and <code>ping</code> is use <strong>ICMP</strong>.</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>You may need to configure a proxy server if you’re having trouble cloning or fetching from a remote repository or getting an error like unable to access <code>Couldn&#39;t resolve host</code>.</p><p>Consider something like:</p><pre><code class="line-numbers language-bash">git config --global http.proxy http://proxyUsername:proxyPassword@proxy.server.com:port</code></pre><p>i use <code>git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;</code> to set my git cause i use socks5.</p><p>i also use <code> git config --local http.proxy &#39;socks5://127.0.0.1:1080&#39;</code> to set my local config that can only work in ‘git clone’ repositories.</p><p>Check global proxy:</p><pre><code class="line-numbers language-bash">git config --global http.proxy</code></pre><p>Check local proxy:</p><pre><code class="line-numbers language-bash">git config --local http.proxy</code></pre><p>Cancel proxy:</p><pre><code class="line-numbers language-bash">git config --global --unset http.proxy</code></pre><pre><code class="line-numbers language-bash">git config --local --unset http.proxy</code></pre><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>Create <code>.wgetrc</code> file in home directory.</p><pre><code class="line-numbers language-bash">use_proxy=yeshttp_proxy=127.0.0.1:1080https_proxy=127.0.0.1:1080</code></pre><p>it can only use http proxy.</p>]]></content>
      
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Horner&#39;s Method</title>
      <link href="/2020/02/02/horner-s-method/"/>
      <url>/2020/02/02/horner-s-method/</url>
      
        <content type="html"><![CDATA[<h3 id="Function-vs-Polynomial"><a href="#Function-vs-Polynomial" class="headerlink" title="Function vs Polynomial"></a>Function vs Polynomial</h3><ul><li>f(x) means a function, any function<ul><li>$$ f(x) = \sin (e^x) + \ln ( \frac{1}{x^2+1} ) $$</li><li>$$ f(x) = \alpha x^3 - \arctan(x) $$</li></ul></li><li>p(x) means a polynomial function<ul><li>$$ p(x) = dx^3 + cx^2 + bx + a $$</li><li>$$ p(x) = a + bx + cx^2 + dx^3 $$</li></ul></li><li>evaluating p(x) can be slow<ul><li>$$ p(x) = a + bx + cx^2 + dx^3 $$</li><li>$$ p(x) = a + b \times x + c \times x \times x + d \times x \times x \times x $$</li></ul></li></ul><p>It include <strong>4 additions</strong> and <strong>6 multiplications</strong></p><h3 id="Horner’s-Method"><a href="#Horner’s-Method" class="headerlink" title="Horner’s Method"></a>Horner’s Method</h3><ul><li>Rewrite p(x)<ul><li>$$ p(x) = a + bx + cx^2 + dx^3 $$</li><li>$$ p(x) = a + bx + x(cx + dx^2) $$</li><li>$$ p(x) = a + x(b + x(cx + dx)) $$</li><li>$$ p(x) = a + x \times (b + x \times (c + d \times x)) $$</li></ul></li></ul><p>It include <strong>3 additions</strong> and <strong>3 multiplications</strong></p><ul><li>In terms of $a_n$<ul><li>$$ p(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \cdots + a_nx^n $$</li><li>$$ p(x) = a_0x^0 + a_1x + a_2x^2 + a_3x^3 + \cdots + a_nx^n  = \sum_{i=0}^{n} a_i x^i $$</li><li>$$ p(x) = a_0 +x(a_1 + x(a_2 + \cdots + x(a_{n-1} + xa_n    ) \cdots )) $$</li><li>$$p(x) = p_0(x) where p_i(x) = \begin{cases} a_i + x \times p_{i+1}(x), if i &lt; n \ a_n, if i = n \end{cases}$$</li></ul></li></ul><h4 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><p>Give the value of coefficient $a_0$, $a_1$, $\cdots$, $a_n$ and $x$.</p><pre><code class="line-numbers language-python">y = 0for i = n downto 0  y = a_i + xy</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SORT</title>
      <link href="/2020/01/29/sort/"/>
      <url>/2020/01/29/sort/</url>
      
        <content type="html"><![CDATA[<h2 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h2><h3 id="1-BUBBLE-SORT"><a href="#1-BUBBLE-SORT" class="headerlink" title="1. BUBBLE SORT"></a>1. BUBBLE SORT</h3><pre><code class="line-numbers language-python">BUBBLE-SORT(A)//A:sort arrayfor i = 1 to A.length - 1  for j = A.length to i + 1    if A[j] &lt; A[j-1]      swap(A[j], A[j-1]</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/BUBBLE_SORT.gif" alt="BUBBLE_SORT"> </p><p>$$ \Theta (n^2) $$</p><h3 id="2-INSERTION-SORT"><a href="#2-INSERTION-SORT" class="headerlink" title="2. INSERTION SORT"></a>2. INSERTION SORT</h3><pre><code class="line-numbers language-python">INSERTION-SORT(A)//A:sort arrayfor j = 2 to A.length  key = A[j]  //Insert A[j] into the sorted sequence A[1..j-1]  i = j - 1  while i &gt; 0 and A[i] &gt; key    A[i+1] = A[i]    i = i - 1  A[i+1] = key</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/INSERTION_SORT.gif" alt="INSERTION_SORT"> </p><p>$$ \Theta (n^2) $$</p><h3 id="3-SELECT-SORT"><a href="#3-SELECT-SORT" class="headerlink" title="3. SELECT SORT"></a>3. SELECT SORT</h3><pre><code class="line-numbers language-python">SELECT-SORT(A)//A:sort arrayfor i = 1 to range(i,A.length)  min = A[i]  for j = 1 to A.length    if min &gt; A[j]      min = A[j]      min_index = j  swap(A[i],A[min_index])</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/SELECT_SORT.gif" alt="SELECT_SORT"> </p><p>$$ \Theta (n^2) $$</p><h3 id="4-MERGE-SORT"><a href="#4-MERGE-SORT" class="headerlink" title="4. MERGE SORT"></a>4. MERGE SORT</h3><pre><code class="line-numbers language-python">MERGE-SORT(A, p, r)//A:sort array//p:begin index//r:end indexif p &lt; r  q = [(p + r) / 2]  MERGE-SORT(A, p, q)  MERGE-SORT(A, q+1, r)  MERGE(A, p, q, r)MERGE(A, p, q, r)//A:sort array//p:begin index//q:mid index//r:end indexn1 = q - p + 1n2 = r - qLet L[1..n1 + 1] and R[1..n2 + 1] be new arraysfor i = 1 to n1  L[i] = A[p + i - 1]for j = 1 to n2  R[j] = A[q + j]L[n1 + 1] = infinityR[n2 + 1] = infinityi = 1j = 1for k = p to r  if L[i] &lt;= R[j]    A[k] = L[i]    i = i + 1  else    A[k] = R[j]    j = j + 1</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/MERGE_SORT.gif" alt="MERGE_SORT"> </p><p>$$ \Theta (n) $$</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/08/17/leetcode-easy-9/">LeetCode EASY_9</a></li><li><a href="https://godliuyang.wang/2020/03/30/scikit-image-guide/">scikit-image guide</a></li><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux + i3wm详细配置篇</title>
      <link href="/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/"/>
      <url>/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Arch-linux-i3"><a href="#Arch-linux-i3" class="headerlink" title="Arch linux + i3"></a>Arch linux + i3</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/img.jpg" alt="arch+i3"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/main.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/albert.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/music.png"> </p><h2 id="Installation-guide"><a href="#Installation-guide" class="headerlink" title="Installation guide"></a>Installation guide</h2><h3 id="1-Boot-the-live-environment"><a href="#1-Boot-the-live-environment" class="headerlink" title="1. Boot the live environment"></a>1. Boot the live environment</h3><p>The live environment can be booted from a USB flash device, an optical disc or a network with PXE. </p><h3 id="2-Connect-the-Internet"><a href="#2-Connect-the-Internet" class="headerlink" title="2. Connect the Internet"></a>2. Connect the Internet</h3><pre><code class="line-numbers language-bash">wifi-menu</code></pre><p>Use <code>ping www.archlinux.org</code> to verify the connection.</p><h3 id="3-Update-the-system-clock"><a href="#3-Update-the-system-clock" class="headerlink" title="3. Update the system clock"></a>3. Update the system clock</h3><p>Use <code>tiledatectl</code> to ensure the system colck is accurate</p><pre><code class="line-numbers language-bash">timedatectl set-ntp true</code></pre><p>To check the service status, use <code>timedatectl status</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/1.png" alt="timedate"> </p><h3 id="4-Partition-the-disks"><a href="#4-Partition-the-disks" class="headerlink" title="4. Partition the disks"></a>4. Partition the disks</h3><p>When recognized by the live system, disks are assigned to a block device such as <code>/dev/sda</code> or <code>/dev/nvme0n1</code> . To identify these devices, use <code>lsblk</code> or <code>fdisk</code> .</p><pre><code class="line-numbers language-bash">fdisk -l</code></pre><p>Use <a href="https://wiki.archlinux.org/index.php/Fdisk">fdisk</a> or <a href="https://wiki.archlinux.org/index.php/Parted">parted</a> to modify partition tables. </p><p>for example: </p><pre><code class="line-numbers language-bash"># parted /dev/sda(parted) mklabelNew disk label type? gpt(parted) exit</code></pre><p>Use <code>cfdisk</code> to create partition.    </p><p>It should include <strong>EFI</strong> , <strong>/</strong> (root), <strong>/home</strong> , <strong>/swap</strong> .</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/2.png" alt="Disks"> </p><h3 id="5-Format-the-partitions"><a href="#5-Format-the-partitions" class="headerlink" title="5. Format the partitions"></a>5. Format the partitions</h3><p>Note the correct partitions</p><ul><li>EFI partition</li></ul><pre><code class="line-numbers language-bash">mkfs.vfat /dev/sda2</code></pre><ul><li>root and home partition</li></ul><pre><code class="line-numbers language-bash">mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4</code></pre><ul><li>swap partition</li></ul><pre><code class="line-numbers language-bash">mkswap -f /dev/sda5swapon /dev/swap</code></pre><h3 id="6-Mount-the-file-systems"><a href="#6-Mount-the-file-systems" class="headerlink" title="6. Mount the file systems"></a>6. Mount the file systems</h3><p>Pay attention to the <strong>order</strong> of mounting partitions!</p><ul><li>mount the file system on the root partition to <code>/mnt</code></li></ul><pre><code class="line-numbers language-bash">mount /dev/sda3 /mnt</code></pre><ul><li>create <strong>home</strong> folder in <code>/mnt</code> folder and mount the file system on the home partition to <code>/mnt/home</code></li></ul><pre><code class="line-numbers language-bash">mkdir /mnt/homemount /dev/sda4 /mnt/home</code></pre><ul><li>create <strong>/mnt/boot/EFI</strong> folder and mount the file system on the EFI partition to <code>/mnt/boot/EFI</code></li></ul><pre><code class="line-numbers language-bash">mkdir /mnt/bootmkdir /mnt/boot/EFImount /dev/sda2 /mnt/boot/EFI</code></pre><h3 id="7-Select-the-mirrors"><a href="#7-Select-the-mirrors" class="headerlink" title="7. Select the mirrors"></a>7. Select the mirrors</h3><pre><code class="line-numbers language-bash">vim /etc/pacman.d/mirrorlist</code></pre><p>Paste the China mirrors in the beginning</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/3.png" alt="mirrorlist"> </p><h3 id="8-Install-essential-packages"><a href="#8-Install-essential-packages" class="headerlink" title="8. Install essential packages"></a>8. Install essential packages</h3><pre><code class="line-numbers language-bash">pacstrap /mnt base linux linux-firmware</code></pre><h3 id="9-Generate-an-fstab-file"><a href="#9-Generate-an-fstab-file" class="headerlink" title="9. Generate an fstab file"></a>9. Generate an <strong>fstab</strong> file</h3><pre><code class="line-numbers language-bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code></pre><p>Check the resulting <code>/mnt/etc/fstab</code> file, and edit it in case of errors.</p><pre><code class="line-numbers language-bash">cat /mnt/etc/fstab</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/4.png" alt="fstab"> </p><h3 id="10-Change-root-into-the-new-system"><a href="#10-Change-root-into-the-new-system" class="headerlink" title="10. Change root into the new system"></a>10. Change root into the new system</h3><pre><code class="line-numbers language-bash">arch-chroot /mnt</code></pre><h3 id="11-Time-zone"><a href="#11-Time-zone" class="headerlink" title="11. Time zone"></a>11. Time zone</h3><pre><code class="line-numbers language-bash">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc.localtimehwclock --systohc</code></pre><h3 id="12-Localozation-Language"><a href="#12-Localozation-Language" class="headerlink" title="12. Localozation(Language)"></a>12. Localozation(Language)</h3><ul><li>Uncomment <code>en_US.UTF-8 UTF-8</code> and others needed locals in <code>/etc/locale.gen</code> , and generate them with:</li></ul><pre><code class="line-numbers language-bash">locale-gen</code></pre><ul><li>Create the <code>locale.conf</code> file, and set <code>LANG</code> variable accordingly:</li></ul><pre><code class="line-numbers language-bash">vim /etc/locale.confLANG=en_US.UTF-8</code></pre><h3 id="13-Initramfs"><a href="#13-Initramfs" class="headerlink" title="13. Initramfs"></a>13. Initramfs</h3><pre><code class="line-numbers language-bash">mkinitcpio -P</code></pre><h3 id="14-Root-password"><a href="#14-Root-password" class="headerlink" title="14. Root password"></a>14. Root password</h3><pre><code class="line-numbers language-bash">passwd root</code></pre><h3 id="15-Network-configuration"><a href="#15-Network-configuration" class="headerlink" title="15. Network configuration"></a>15. <a href="https://wiki.archlinux.org/index.php/Network_configuration">Network configuration</a></h3><ul><li>Create the <strong>hostname</strong> file</li></ul><pre><code class="line-numbers language-bash">vim /etc/hostname</code></pre><p>Enter your hostname in this file.</p><ul><li>Add matching entries to <strong>hosts</strong></li></ul><pre><code class="line-numbers language-bash">vim /etc/hosts</code></pre><pre><code>127.0.0.1    localhost::1          localhost127.0.0.1    yourhostname.localdomain    yourhostname</code></pre><ul><li>Install some software to ensure you can connect the Internet after reboot system.</li></ul><pre><code class="line-numbers language-bash">pacman -S iw wpa_supplicant dialog networkmanager</code></pre><p><a href="#nm">Detailed configuration</a> </p><h3 id="16-Microcode"><a href="#16-Microcode" class="headerlink" title="16. Microcode"></a>16. <a href="https://wiki.archlinux.org/index.php/Microcode">Microcode</a></h3><p>My computer is <code>Intel</code> processors.</p><pre><code class="line-numbers language-bash">pacman -S intel-ucode</code></pre><h3 id="17-Boot-loader"><a href="#17-Boot-loader" class="headerlink" title="17. Boot loader"></a>17. <a href="https://wiki.archlinux.org/index.php/Arch_boot_process#Boot_loader">Boot loader</a></h3><p><a href="https://wiki.archlinux.org/index.php/GRUB"><strong>GRUB</strong></a> </p><pre><code class="line-numbers language-bash">pacman -S grub efibootmgrgrub-install --target=x86_64-efi --efi-directory=/boot/EFI -bootloader-id=Archlinuxgrub-mkconfig -o /boot/grub/grub.cfg</code></pre><p>If you can see some <code>img</code> file generated, it means the grub boot loader file are successful creatted.</p><h3 id="18-Reboot"><a href="#18-Reboot" class="headerlink" title="18. Reboot"></a>18. Reboot</h3><pre><code class="line-numbers language-bash">exitumount -R /mntreboot</code></pre><p>Use <code>uname -a</code> to view the Version of Arch linux.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/5.png" alt="Arch_linux Version"> </p><h2 id="My-config-recommendations"><a href="#My-config-recommendations" class="headerlink" title="My config recommendations"></a>My config recommendations</h2><h3 id="1-Add-users"><a href="#1-Add-users" class="headerlink" title="1. Add users"></a>1. Add users</h3><pre><code class="line-numbers language-bash">useradd -s -G wheel -s /bin/bash username</code></pre><p>To allow user to gain full root privileges when he precdeds a command with <code>sudo</code> , add the following line to <code>/etc/sudoers</code> .</p><pre><code class="line-numbers language-bash">USER_NAME ALL=(ALL) ALL</code></pre><p><code>su username</code> to switch users.</p><h3 id="2-NetworkManager"><a href="#2-NetworkManager" class="headerlink" title="2. NetworkManager "></a>2. <a id = "nm"><a href="https://wiki.archlinux.org/index.php/NetworkManager">NetworkManager</a> </a></h3><p>NetworkManager(package <code>networkmanager</code> ) contains a daemon, a command line interface( <code>nmcli</code> ) and a curses-based interface( <code>nmtui</code> ). After installation, you should <strong>enable the daemon</strong>.</p><pre><code class="line-numbers language-bash">systemctl enable NetworkManager.servicesystemctl start NetworkManager.service</code></pre><p>Use <code>ip link</code> to view the network interface.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/6.png" alt="Network interface"> </p><p><strong>Usage</strong></p><ul><li>List nearby wifi networks</li></ul><pre><code class="line-numbers language-bash">nmcli device wifi list</code></pre><ul><li>Connect to a wifi network</li></ul><pre><code class="line-numbers language-bash">nmcli device wifi connect SSID password password</code></pre><ul><li>Disconnect an interface</li></ul><pre><code class="line-numbers language-bash">nmcli device disconnect ifname eth0</code></pre><ul><li>See a list of network devices and wheir state</li></ul><pre><code class="line-numbers language-bash">nmcli device</code></pre><ul><li>Turn off wifi</li></ul><pre><code class="line-numbers language-bash">nmcli radio wifi off</code></pre><p><code>nm-applet</code> for a system tray applet</p><pre><code class="line-numbers language-bash">sudo pacman -S network-manager-applet</code></pre><ul><li>Add <code>exec --no-startup-id nm-applet</code> to <code>~/.config/i3/config</code> fot autostart <code>nm-applet</code> .</li></ul><h3 id="3-Xorg-display-server"><a href="#3-Xorg-display-server" class="headerlink" title="3. Xorg display server"></a>3. <a href="https://wiki.archlinux.org/index.php/Xorg">Xorg</a> display server</h3><ul><li>Installation</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S xorg xorg-server xorg-apps</code></pre><ul><li><p>Driver installation</p><ol><li>First, identify your card:</li></ol><pre><code class="line-numbers language-bash">lspci | grep -e VGA -e 3D</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/7.png" alt="card"> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/8.png"> </p><ol start="2"><li>Install an appropriate deiver</li></ol><pre><code class="line-numbers language-bash">pacman -Ss xf86-video</code></pre><p><strong>Note</strong> : For NVIDIA Optimus enabled laptop which uses an integrated video card combined with a dedicated GPU, You  <strong>can not</strong> just install <code>xf86-video-intel</code> &amp; <code>nvidia</code> , it will get a blcak screen. See <a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus">NVIDIA Optimus</a> to get more informations. </p><p>I just install <code>xf86-video-vesa</code> . </p><pre><code class="line-numbers language-bash">pacman -S xf86-video-vesa</code></pre><p><a href="https://wiki.archlinux.org/index.php/Xorg#Driver_installation">Xorg: Driver_installtion</a> </p></li><li><p>Use <a href="https://wiki.archlinux.org/index.php/Xinit">xinit</a> to start Xorg display server.</p></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S xorg-xinit</code></pre><ul><li>Create <code>.xinitrc</code> file(in common users)</li></ul><pre><code class="line-numbers language-bash">sudo cp /etc/X11/xinit/xinitrc ~/.xinitrc</code></pre><ul><li>Tap-to-click</li></ul><pre><code class="line-numbers language-bash">sudo vim /etc/X11/xorg.conf.d/30-touchpad.conf</code></pre><p>Add the following lines to it.</p><pre><code>Section &quot;InputClass&quot;  Identifier &quot;touchpad&quot;  Driver &quot;libinput&quot;  MatchIsTouchpad &quot;on&quot;  Option &quot;Tapping&quot; &quot;on&quot;EndSection</code></pre><ul><li>Install Windows Manager (i3)</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S i3</code></pre><p>It include <code>i3-gaps</code> , <code>i3wm</code> , <code>i3blocks</code> , <code>i3lock</code> , <code>i3status</code></p><ul><li>Use i3</li></ul><p>Add <code>exec i3</code> to the end of <code>~.xinitrc</code> .</p><ul><li>Start Xorg server.</li></ul><pre><code class="line-numbers language-bash">startx</code></pre><ul><li>Autostart X at login</li></ul><p>I’m a <a href="https://fishshell.com/">fish</a> user, so i just need add the following to the bottom of my <code>~/.config/fish/config.fish</code> .</p><pre><code class="line-numbers language-bash"># Start X at loginif status is-login    if test -z &quot;$DISPLAY&quot; -a $XDG_VTNR = 1        exec startx -- -keeptty    endend</code></pre><p>Other shell user (like <strong>bash</strong> , <strong>zsh</strong> ), Please visit <a href="https://wiki.archlinux.org/index.php/Xinit#Autostart_X_at_login">here</a> </p><h3 id="4-i3wm"><a href="#4-i3wm" class="headerlink" title="4. i3wm"></a>4. i3wm</h3><p><a href="https://i3wm.org/">i3wm</a>  ,   <a href="https://wiki.archlinux.org/index.php/I3">i3-ArchWiki</a> </p><p><a href="https://github.com/liuyaanng/Arch_linux#i3-and-i3status">My i3 config</a> </p><h3 id="5-Some-useful-software"><a href="#5-Some-useful-software" class="headerlink" title="5. Some useful software"></a>5. Some useful software</h3><ul><li>yaourt</li></ul><p>Add the source to <code>/etc/pacman.conf</code></p><pre><code>[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch#Server   = http://repo.archlinuxcn.org/$arch#Server   = http://repo.archlinux.fr/$arch</code></pre><p>Synchronized communities</p><pre><code class="line-numbers language-bash">sudo pacman -Syu</code></pre><p>Insatll yaourt </p><pre><code class="line-numbers language-bash">sudo pacman -S yaourt</code></pre><ul><li><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/#toc-heading-13">Software i often use</a></li></ul><h3 id="6-Fonts"><a href="#6-Fonts" class="headerlink" title="6. Fonts"></a>6. Fonts</h3><p><a href="https://wiki.archlinux.org/index.php/Fonts">Fonts-ArchWiki</a> , <a href="https://github.com/ryanoasis/nerd-fonts">Nerd-fonts</a> , <a href="https://unicode-table.com/en/">Unicode-table</a>  </p><table><thead><tr><th align="center">adobe-source-code-pro</th><th align="center">adobe-source-han-serif-cn-fonts</th><th align="center">adobe-source-han-serif-tw-fonts</th></tr></thead><tbody><tr><td align="center">ttf-symbola</td><td align="center">nerd-fonts-complete</td><td align="center">nerd-fonts-dejavu-complete</td></tr><tr><td align="center">font-awesome</td><td align="center">noto-fonts-emoji</td><td align="center"></td></tr></tbody></table><p><code>fc-list</code> to show the fonts you have installed.</p><h3 id="7-Volume"><a href="#7-Volume" class="headerlink" title="7. Volume"></a>7. Volume</h3><ul><li><p>ALSA is a set of built-in GNU/Linux modules. Therefore, manual insatllation is not necessary.</p></li><li><p>Install <strong>pulseaudio</strong></p></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S pulseaudio</code></pre><ul><li>Install <strong>alsa-utils</strong></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S alsa-utils</code></pre><p>Use <code>alsamixer</code> to manage the system volume</p><ul><li>VoulmeIcon</li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/9.png" alt="VolumeIcon"> </p><p>If you want a System volume tray, you can try <strong>volumeicon</strong></p><ol><li><p>Install volumeicon</p><pre><code class="line-numbers language-bash">sudo pacman -S volumeicon</code></pre></li><li><p>Add <code>volumeicon</code> file in <code>~/.config/volumeicon</code>  , and add the following lines to it.</p><pre><code class="line-numbers language-bash">[Alsa]card=default[Notification]show_notification=truenotification_type=1[StatusIcon]stepsize=5onclick=xterm -e &#39;alsamixer&#39;theme=White Gnomeuse_panel_specific_icons=truelmb_slider=truemmb_mute=trueuse_horizontal_slider=falseshow_sound_level=trueuse_transparent_bac&lt;++&gt;kground=true[Hotkeys]up_enabled=truedown_enabled=truemute_enabled=trueup=XF86AudioRaiseVolumedown=XF86AudioLowerVolumemute=XF86AudioMute</code></pre></li><li><p>Create <code>pulseaudio-ctl.desktop</code> in <code>~/.config/autostart</code> , and add the following lines to it.</p><pre><code class="line-numbers language-bash">[Desktop Entry]Encoding=UTF-8Type=ApplicationName=pulseaudio-ctlcomment=Set Volume to 70%Exec=pulseaudio-ctl-normalStartupNotify=trueTerminal=falseHidden=false</code></pre></li><li><p>Add <code>exec --no-startup-id volumeicon</code> to <code>~/.config/i3/config</code> .</p></li><li><p>I wrote two scripts to control the volume of the system with <code>alsamixer</code> and <code>dunst</code> , put them to <code>/usr/bin/</code> .</p><p><a href="https://github.com/liuyaanng/Arch_linux/blob/master/volume_up.sh">volume_up</a><br><a href="https://github.com/liuyaanng/Arch_linux/blob/master/volume_down.sh">volume_down</a> </p></li></ol><h3 id="8-Screen-brightness"><a href="#8-Screen-brightness" class="headerlink" title="8. Screen brightness"></a>8. Screen brightness</h3><p>A good advice for backlight management is <code>xorg-xbacklight</code> , but it seems not work on my computer. </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/12.png" alt="xbacklight -error"> </p><p>If you have the same problem, you can try the solution of Wiki, but it still can’t work on my computer. Sad! So i try another way to control the screen brightness.<br>The backlight can be controlled by the file <code>/sys/class/backlight/intel_backlight/brightness</code> ‘s value. So i wrote a script to control it. I named it <code>intel_brightness_control.sh</code></p><pre><code class="line-numbers language-bash">#!/bin/bashset -efile=&quot;/sys/class/backlight/intel_backlight/brightness&quot;current=$(cat &quot;$file&quot;)new=&quot;$current&quot;if [ &quot;$1&quot; = &quot;-inc&quot; ]then  new=$(( current + $2 ))  status=&quot;Up&quot;fiif [ &quot;$1&quot; = &quot;-dec&quot; ]then  if [ current &lt; 100 ]  then    new=&quot;50&quot;  else    new=$(( current - $2 ))  fi  status=&quot;Down&quot;fiecho &quot;$new&quot; | tee &quot;$file&quot;brightness=`light -G`notify-send &quot;Brightness $status($brightness%)&quot;</code></pre><p>Remember put it in your <code>/usr/bin/</code>.</p><p>Then do <code>sudo chmod 777 /sys/class/backlight/intel_backlight/brightness</code> . The last thing is adding the following lines to <code>.config/i3/config</code> .</p><pre><code class="line-numbers language-bash"># Screen brightness controlsbindsym XF86MonBrightnessUp exec &quot;intel_brightness_control.sh -inc 100&quot;bindsym XF86MonBrightnessDown exec &quot;intel_brightness_control.sh -dec 100&quot;</code></pre><h3 id="9-Bluetooth"><a href="#9-Bluetooth" class="headerlink" title="9. Bluetooth"></a>9. Bluetooth</h3><ul><li>Install <strong>bluez</strong> , <strong>bluez-utils</strong></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S bluez bluez-utils</code></pre><ul><li>The generic Bluetooth driver is the <code>btusb</code> Kernel module. Use <code>lsmod</code> to check whether that module is loaded. </li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/11.png" alt="btusb module"><br>  If it’s not, do <code>modprobe btusb</code> to load the moudle.</p><ul><li>Start / Enable</li></ul><pre><code class="line-numbers language-bash">systemctl enable bluetooth.servicesystemctl start bluetooth.service</code></pre><ul><li>Auto power-on after boot</li></ul><p>Add the line <code>AutoEnable=true</code> in <code>/etc/bluetooth/main.conf</code> at the bottom in the <code>[Policy]</code> section.</p><ul><li>Discoverable on startup</li></ul><pre><code class="line-numbers language-bash">/etc/bluetooth/main.conf[General]DiscoverableTimeout = 0Discoverable=true</code></pre><ul><li>Install <strong>pulseaudio-bluetooth</strong> to use audio equipment like bluetooth headphones or speakers.</li></ul><p><a href="https://wiki.archlinux.org/index.php/Bluetooth_headset">Bluetooth headset</a> </p><pre><code class="line-numbers language-bash">sudo pacman -S pulseaudio-bluetooth</code></pre><ul><li>Install <a href="https://github.com/blueman-project/blueman">blueman</a> </li></ul><pre><code class="line-numbers language-bash">sudo pacman -S blueman</code></pre><ol><li><code>blueman-applet</code> to use.</li><li>add <code>exec --no-startup-id blueman-applet</code> to <code>~/.config/i3/config</code> to auto start <code>blueman-applet</code> .</li></ol><h3 id="10-Notify-Dunst"><a href="#10-Notify-Dunst" class="headerlink" title="10. Notify(Dunst)"></a>10. Notify(Dunst)</h3><pre><code class="line-numbers language-bash">sudo pacman -S libnotify dunst</code></pre><p>Create <code>org.freedesktop.Notifications.service</code> in <code>/usr/share/dbus-1/services/</code> folder. Add the following lines.</p><pre><code>[D-BUS Service]Name.org.freedesktop.NotificationsExec=/usr/local/bin/dunst</code></pre><p>An example configuration file is included at <code>/usr/local/share/dunst/dunstrc</code> . Copy this file to <code>~/.config/dunst/dunstrc</code> and edit it accordingly.</p><p><a href="https://github.com/liuyaanng/Arch_linux/tree/master/dunst">My Dunstrc</a> </p><p>Use <code>notify-send &quot;Hello, world!&quot; </code> to test.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/10.png" alt="Dunst"> </p><h3 id="11-Shutdown-Reboot-LockScreen"><a href="#11-Shutdown-Reboot-LockScreen" class="headerlink" title="11. Shutdown Reboot LockScreen"></a>11. Shutdown Reboot LockScreen</h3><ul><li>Create a script named <code>i3exit</code> . Make sure you have <code>polkit</code> installed. </li></ul><pre><code class="line-numbers language-bash">#!/bin/shlock() &#123;    i3lock&#125;case &quot;$1&quot; in    lock)        blurlock        ;;    logout)        i3-msg exit        ;;    suspend)        blurlock &amp;&amp; systemctl suspend        ;;    hibernate)        blurlock &amp;&amp; systemctl hibernate        ;;    reboot)        systemctl reboot        ;;    shutdown)        systemctl poweroff        ;;    *)        echo &quot;Usage: $0 &#123;lock|logout|suspend|hibernate|reboot|shutdown&#125;&quot;        exit 2esacexit 0</code></pre><p>Do <code>chmod +x</code> and put it in <code>$PATH</code> ( <code>/usr/bin/</code> ) .</p><ul><li>Add the following lines to <code>.config/i3/config</code></li></ul><pre><code class="line-numbers language-bash">set $mode_system System (l) lock, (e) logout, (s) suspend, (h) hibernate, (r) reboot, (Shift+s) shutdownmode &quot;$mode_system&quot; &#123;    bindsym l exec --no-startup-id i3exit lock, mode &quot;default&quot;    bindsym e exec --no-startup-id i3exit logout, mode &quot;default&quot;    bindsym s exec --no-startup-id i3exit suspend, mode &quot;default&quot;    bindsym h exec --no-startup-id i3exit hibernate, mode &quot;default&quot;    bindsym r exec --no-startup-id i3exit reboot, mode &quot;default&quot;    bindsym Shift+s exec --no-startup-id i3exit shutdown, mode &quot;default&quot;      # back to normal: Enter or Escape    bindsym Return mode &quot;default&quot;    bindsym Escape mode &quot;default&quot;&#125;bindsym $mod+Pause mode &quot;$mode_system&quot;</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/">Manjaro i3wm 高效率环境配置篇(持续更新)</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> i3wm </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bilibili-Evolved</title>
      <link href="/2019/09/21/bilibili-evolved/"/>
      <url>/2019/09/21/bilibili-evolved/</url>
      
        <content type="html"><![CDATA[<h2 id="Bilibili-Evolved"><a href="#Bilibili-Evolved" class="headerlink" title="Bilibili-Evolved"></a>Bilibili-Evolved</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/2.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/3.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/4.png"></p><h3 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h3><ul><li><p>You should install <a href="https://www.tampermonkey.net/">Tampermonkey</a> first.</p></li><li><p><a href="https://greasyfork.org/en/scripts/373563-bilibili-evolved">Bilibili-Evolved</a></p></li></ul><p>Please access <a href="https://github.com/the1812/Bilibili-Evolved">GitHub</a> to view how to use it.</p><h3 id="2-Download-videos"><a href="#2-Download-videos" class="headerlink" title="2. Download videos"></a>2. Download videos</h3><h4 id="2-1-Download-single-video"><a href="#2-1-Download-single-video" class="headerlink" title="2.1 Download single video."></a>2.1 Download single video.</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/5.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/6.png"></p><h4 id="2-2-Batch-export-with-aria2"><a href="#2-2-Batch-export-with-aria2" class="headerlink" title="2.2 Batch export(with aria2)."></a>2.2 Batch export(with aria2).</h4><ul><li>Install aria2.</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S aria2</code></pre><ul><li>export aria2(a txt file)</li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/7.png"></p><ul><li>Download videos in current directory.</li></ul><pre><code class="line-numbers language-bash">aria2c -i Download.txt</code></pre><h3 id="3-Convert-video-files"><a href="#3-Convert-video-files" class="headerlink" title="3. Convert video files."></a>3. Convert video files.</h3><p>The default video files format is <code>flv</code>.<br>I recommend using <a href="http://ffmpeg.org/">ffmpeg</a> to convert video files format on Linux.</p><pre><code class="line-numbers language-bash">ffmpeg -i input.flv output.mp4</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bilibili.com </tag>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git &amp; Github</title>
      <link href="/2019/09/18/git-github/"/>
      <url>/2019/09/18/git-github/</url>
      
        <content type="html"><![CDATA[<h3 id="1-When-i-download-files-from-GitHub-Failed-to-connect-to-127-0-0-1-port-1080-Connection-refused"><a href="#1-When-i-download-files-from-GitHub-Failed-to-connect-to-127-0-0-1-port-1080-Connection-refused" class="headerlink" title="1. When i download files from GitHub, Failed to connect to 127.0.0.1 port 1080: Connection refused"></a>1. When i download files from GitHub, <code>Failed to connect to 127.0.0.1 port 1080: Connection refused</code></h3><ol><li>Find wheather you are using proxy server or not.</li></ol><pre><code class="line-numbers language-bash">git config --global http.proxy</code></pre><ol start="2"><li>Cancel the proxy server.</li></ol><pre><code class="line-numbers language-bash">git config --global --unset http.proxy</code></pre><h3 id="2-Clone-with-SSH-Github-guide"><a href="#2-Clone-with-SSH-Github-guide" class="headerlink" title="2. Clone with SSH (Github guide)"></a>2. Clone with SSH (<a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">Github guide</a>)</h3><ul><li>Install Openssh</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S openssh</code></pre><ul><li>Generating a new SSH key</li></ul><pre><code class="line-numbers language-bash">ssh-keygen</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/1.png"> </p><pre><code class="line-numbers language-bash">tree .ssh</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/2.png"> </p><ul><li>Copy the SSH key to your clipboard</li></ul><pre><code class="line-numbers language-bash">cat .ssh/id_rsa.pub</code></pre><ul><li>In the upper-right corner of any page, click your profile photo, then click <strong>Settings</strong></li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/3.png"></p><ul><li><p>In the user settings sidebar, click <strong>SSH and GPG keys</strong></p></li><li><p>Click <strong>New SSH key</strong> or <strong>Add SSH key</strong>.</p></li><li><p>In the “Title” field, add a descriptive label for the new key. For example, if you’re using arch linux, you might call this key “Arch linux”</p></li><li><p>Paste your key into the “Key” field.</p></li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/4.png"> </p><ul><li>If prompted, confirm your GitHub password.</li></ul><h3 id="3-Mandatory-update-of-local-repository"><a href="#3-Mandatory-update-of-local-repository" class="headerlink" title="3.Mandatory update of local repository"></a>3.Mandatory update of local repository</h3><pre><code class="line-numbers language-bash">git fetch --all &amp;&amp;  git reset --hard origin/master &amp;&amp; git pull</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda</title>
      <link href="/2019/09/18/anaconda/"/>
      <url>/2019/09/18/anaconda/</url>
      
        <content type="html"><![CDATA[<h2 id="Install-Guide"><a href="#Install-Guide" class="headerlink" title="Install Guide"></a>Install Guide</h2><p>You probably need proxy: <a href="https://godliuyang.wang/2020/02/04/about-proxy/">About Proxy</a> </p><h3 id="1-Download-Anaconda"><a href="#1-Download-Anaconda" class="headerlink" title="1. Download Anaconda"></a>1. Download <code>Anaconda</code></h3><p>Click here to download <a href="https://www.anaconda.com/distribution/">Anaconda</a></p><h3 id="2-Install-Anaconda"><a href="#2-Install-Anaconda" class="headerlink" title="2. Install Anaconda"></a>2. Install <code>Anaconda</code></h3><pre><code class="line-numbers language-bash">bash ~/Downloads/Anaconda3-2019.07-Linux-x86_64.sh</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/3.png"></p><p>Press ENTER</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/4.png"></p><p>input yes </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/5.png"></p><p>Press ENTER<br>A few minutes later…….</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/6.png"></p><p>input yes</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/7.png"></p><p>successful installation.</p><p>You can use <code>conda -V</code> to check the version of anaconda.</p><h3 id="3-Bash-user"><a href="#3-Bash-user" class="headerlink" title="3. Bash user"></a>3. Bash user</h3><pre><code class="line-numbers language-bash">vim ~/.bashrc</code></pre><p>add the following line to your ~/.bashrc.</p><pre><code class="line-numbers language-bash">export PATH=&quot;/home/xupp/anaconda3/bin:$PATH&quot;</code></pre><p>Reboot your terminal.</p><h3 id="4-Fish-user"><a href="#4-Fish-user" class="headerlink" title="4. Fish user"></a>4. Fish user</h3><p>If your shell is <strong>fish</strong>, you probably need to configure your environment variable.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/8.png"></p><p>I use <code>set</code> command to do this.</p><pre><code class="line-numbers language-bash">set -xg</code></pre><p>Prints all global, exported variables.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/1.png"></p><p>I find the user name of anaconda path in PATH is wrong.<br>I don’t know why it is, but i know i should correct it.</p><pre><code class="line-numbers language-bash">set PATH[1] /home/kevin/anaconda3/bin</code></pre><p>it works.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/9.png"></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/10.png"></p><h2 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h2><h3 id="1-Create-Python-environment"><a href="#1-Create-Python-environment" class="headerlink" title="1. Create Python environment"></a>1. Create Python environment</h3><pre><code class="line-numbers language-bash">conda create --name python37 python=3.7</code></pre><h3 id="2-Check-Python-Environment-you-have-created"><a href="#2-Check-Python-Environment-you-have-created" class="headerlink" title="2. Check Python Environment you have created."></a>2. Check Python Environment you have created.</h3><pre><code class="line-numbers language-bash">conda info --envs</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/11.png"> </p><p>Where * indicates the current Python environment</p><h3 id="3-Modify-Python-environment"><a href="#3-Modify-Python-environment" class="headerlink" title="3. Modify Python environment"></a>3. Modify Python environment</h3><pre><code class="line-numbers language-bash">source activate python37</code></pre><p>and modify default Python environment</p><pre><code class="line-numbers language-bash">source deactivate</code></pre><h3 id="4-Delate-Python-environment"><a href="#4-Delate-Python-environment" class="headerlink" title="4. Delate Python environment"></a>4. Delate Python environment</h3><pre><code class="line-numbers language-bash">conda remove --name python37 --all</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/03/17/pandas-ji-chu/">Pandas 基础</a></li><li><a href="https://godliuyang.wang/2020/03/14/numpy-ji-chu/">Numpy 基础</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Anaconda3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro i3wm 高效率环境配置篇(持续更新)</title>
      <link href="/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/"/>
      <url>/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/</url>
      
        <content type="html"><![CDATA[<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/4.png"><br>Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版<br>使用它是因为 AUR软件仓库有着世界上最齐全的Linux软件，万物皆可 pacman ,arch的wiki绝对是我见过的最详细的linux发行版的”说明书”, 在这里基本能解决我所有的问题, 另，作为基于Arch的发行版，每日一 <code>sudo pacman -Syu</code>简直不要太爽啊！<br>有时间一定要尝试一下 原生Arch(有生之年系列，趁还折腾的动)</p><h2 id="1-系统安装"><a href="#1-系统安装" class="headerlink" title="1. 系统安装"></a>1. 系统安装</h2><h3 id="1-1-ISO文件下载"><a href="#1-1-ISO文件下载" class="headerlink" title="1.1 ISO文件下载"></a>1.1 ISO文件下载</h3><p><a href="https://www.manjaro.org/">Manjaro官网</a></p><p>Manjaro i3属于社区版本<br><a href="https://osdn.net/projects/manjaro-community/storage/i3/18.0.4/manjaro-i3-18.0.4-stable-x86_64.iso/">Download manjaro-i3-18.0.4-stable-x86_64.iso</a></p><h3 id="1-2-U盘启动盘制作"><a href="#1-2-U盘启动盘制作" class="headerlink" title="1.2 U盘启动盘制作"></a>1.2 U盘启动盘制作</h3><p>首先准备一个容量大于4G的U盘，在制作启动盘之前请先把里面的资料转存到别处，因为此项操作会格式化U盘且不可恢复。<br>刻录工具有很多，</p><ul><li><a href="http://cn.ezbsystems.com/dl2.php?file=uiso9_cn.exe">UltralISO</a></li><li><a href="http://cdimage.deepin.com/applications/deepin-boot-maker/windows/deepin-boot-maker.exe">深度启动盘制作工具</a> 深度科技，很简洁的一个工具</li><li><a href="https://github.com/pbatard/rufus/releases/download/v3.6/rufus-3.6.exe">Rufus</a></li></ul><p>按照软件的操作步骤制作启动盘<br>注：若遇到启动盘系统安装的过程中遇到启动盘不可用则使用 <strong>Rufus</strong> 使用DD镜像模式制作<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/1.png"></p><h3 id="1-3-系统安装"><a href="#1-3-系统安装" class="headerlink" title="1.3 系统安装"></a>1.3 系统安装</h3><p>安装过程很简单，参考下面这篇博客<br><a href="https://www.jianshu.com/p/e555a079f78a">Manjaro Linux i3 安装笔记</a></p><p>安装时语言选择  <strong>简体中文</strong>即可</p><h2 id="2-中文环境配置"><a href="#2-中文环境配置" class="headerlink" title="2. 中文环境配置"></a>2. 中文环境配置</h2><h3 id="2-1-更换Linux国内源"><a href="#2-1-更换Linux国内源" class="headerlink" title="2.1 更换Linux国内源"></a>2.1 更换Linux国内源</h3><p>Manjaro 默认的更新源在国外，没翻墙的宝宝无法更新，这里先换一下更新源</p><h4 id="2-1-1-更新镜像排名"><a href="#2-1-1-更新镜像排名" class="headerlink" title="2.1.1 更新镜像排名"></a>2.1.1 更新镜像排名</h4><pre><code class="line-numbers language-bash">sudo pacman-mirrors -i -c China -m rank //更新镜像排名</code></pre><p>之后自己选择几个镜像，推荐ustc和tuna的镜像源</p><pre><code class="line-numbers language-bash">sudo vim /etc/pacman.d/mirrorlist //查看选择的源sudo pacman -Syy  //更新数据源</code></pre><h4 id="2-1-2-设置Archlinuxcn源"><a href="#2-1-2-设置Archlinuxcn源" class="headerlink" title="2.1.2 设置Archlinuxcn源"></a>2.1.2 设置Archlinuxcn源</h4><pre><code class="line-numbers language-bash">sudo vim /etc/pacman.conf</code></pre><p>在文件末尾添加如下:</p><pre><code class="line-numbers language-bash">[archlinuxcn]SigLevel = Optional TrustedOnly#中科大源Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch#清华源Server = http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch[antergos]SigLevel = TrustAllServer = https://mirrors.ustc.edu.cn/antergos/$repo/$archServer = http://mirrors.tuna.tsinghua.edu.cn/antergos/$repo/$arch[arch4edu]SigLevel = TrustAllServer = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch</code></pre><h4 id="2-1-3-导入GPG-key"><a href="#2-1-3-导入GPG-key" class="headerlink" title="2.1.3 导入GPG key"></a>2.1.3 导入GPG key</h4><pre><code class="line-numbers language-bash">sudo pacman -Syy //更新数据源sudo pacman -S archlinuxcn-keyring //安装导入GPG keysudo pacman -S antergos-keyrin</code></pre><h4 id="2-1-4-更新系统"><a href="#2-1-4-更新系统" class="headerlink" title="2.1.4 更新系统"></a>2.1.4 更新系统</h4><pre><code class="line-numbers language-bash">sudo pacman -Syu</code></pre><h3 id="2-2-解决桌面中文显示方块问题"><a href="#2-2-解决桌面中文显示方块问题" class="headerlink" title="2.2 解决桌面中文显示方块问题"></a>2.2 解决桌面中文显示方块问题</h3><p>若遇到桌面时间中文部分显示为 <strong>方块</strong>     </p><pre><code class="line-numbers language-bash">sudo vim /usr/share/conky/conky_maia</code></pre><p>将 <strong>conky.text</strong> 的前四行字体改为 <strong>anti</strong> 即可</p><h3 id="2-3-中文输入法"><a href="#2-3-中文输入法" class="headerlink" title="2.3 中文输入法"></a>2.3 中文输入法</h3><p>先安装fcitx</p><pre><code class="line-numbers language-bash">sudo pacman -S fcitx fcitx-im fcitx-configtool</code></pre><p>安装完fcitx之后，创建.xprofile文件</p><pre><code class="line-numbers language-bash">vim ~/.xprofile</code></pre><p>在里面添加如下内容:</p><pre><code class="line-numbers language-bash">#fcitxexport GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&quot;@im=fcitx&quot;</code></pre><p>之后安装中文输入法，搜狗拼音貌似对arch的支持不太好，所以我们选择谷歌拼音</p><pre><code class="line-numbers language-bash">sudo pacman -S fcitx-googlepinyin</code></pre><p>之后在终端运行 <code>$ fcitx</code> 在图形化界面的配置文件中配置输入法即可，配置快捷键<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/2.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/3.png"></p><p>若中文输入法开机无法自启动，则执行如下操作</p><pre><code class="line-numbers language-bash">vim ~/.i3/config</code></pre><p>添加如下内容:</p><p><code>exec_always fcitx</code></p><h2 id="3-高效率软件以及配置"><a href="#3-高效率软件以及配置" class="headerlink" title="3. 高效率软件以及配置"></a>3. 高效率软件以及配置</h2><h3 id="3-1-软件"><a href="#3-1-软件" class="headerlink" title="3.1 软件"></a>3.1 软件</h3><h4 id="3-1-1-Alacritty"><a href="#3-1-1-Alacritty" class="headerlink" title="3.1.1 Alacritty"></a>3.1.1 Alacritty</h4><p>Alacritty 是一个免费的开源，快速，跨平台的终端仿真器，它使用GPU进行渲染，我使用tree命令跑了一下，确实速度快。kitty也是一款优秀的终端，不过它的配置稍麻烦，感兴趣的可以自行Google.</p><pre><code class="line-numbers language-bash">sudo pacman -S alacritty</code></pre><h4 id="3-1-2-fish-amp-oh-my-fish-omf"><a href="#3-1-2-fish-amp-oh-my-fish-omf" class="headerlink" title="3.1.2 fish &amp; oh-my-fish(omf)"></a>3.1.2 fish &amp; oh-my-fish(omf)</h4><ul><li>fish是一个智能且用户友好的命令行shell，适用于macOS，Linux和其他家族。fish包含语法突出显示，自动提示类型和精美的选项卡完成等功能，无需配置。<br>Terminal下默认的SHELL是bash, 但bash作为你经常使用的工具来说一点都不便捷,相信有很多人都用过另一款shell,它的名字是<strong>zsh</strong>，以及<strong>oh-my-zsh</strong>，我也用了一段时间的zsh，在用的过程中我发现它有时候运行贼慢，忍不了，而且配置虽说有oh-my-zsh管理，但终归不是傻瓜式工具，直到有一天我发现了 <strong>fish</strong>,官网号称是一个专为90后设计的shell。<br>安装很简单:</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S fish</code></pre><p>终端输入<code>fish</code>即可进入</p><ul><li>查看已经安装的shell</li></ul><pre><code class="line-numbers language-bash">cat /etc/shells</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/12.png"></p><ul><li>修改默认shell</li></ul><p>看一下上一步输出的<code>fish</code>的位置，然后执行</p><pre><code class="line-numbers language-bash">chsh -s usr/bin/fish</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/13.png"><br>之后重启终端,shell就默认为fish了<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/14.png"></p><p>配置文件的位置是<code>/home/kevin/.config/fish/functions/fish_prompt.fish</code>，可以在这里设置替换命令，提高效率，举个例子:<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/18.png"></p><ul><li>oh-my-fish是一个 Fishshell 框架，允许你安装扩展或更改你的 shell 外观的软件包。它简单易用，快速可扩展。使用 omf，你可以根据你的想法，很容易地安装主题，丰富你的外观和安装插件来调整你的 Fish shell。    </li><li>安装omf<br>在fish shell里执行</li></ul><pre><code class="line-numbers language-bash">curl -L https://get.oh-my.fish | fish</code></pre><ul><li>列出所有的安装包</li></ul><pre><code class="line-numbers language-bash">omf list</code></pre><p>这条命令会列出一安装的主题和插件</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/15.png"></p><ul><li>列出已安装主题</li></ul><pre><code class="line-numbers language-bash">omf theme</code></pre><ul><li>安装一个新主题<br>我现在用的主题叫 ays<pre><code class="line-numbers language-bash">omf install ays</code></pre></li><li>改变主题</li></ul><pre><code class="line-numbers language-bash">omf theme ays</code></pre><ul><li>卸载oh-my-fish</li></ul><pre><code class="line-numbers language-bash">omf destroy</code></pre><ul><li><p>Fish 运行Bash commands<br>例如 在fish 不能运行 time 命令，以下是解决办法    </p><ul><li><p>在 <code>fish/functions/</code> 目录下创建 <code>time.fish</code> 文件，在里面输入    </p><pre><code>function time --description &quot;alias time bash -c time&quot; bash -c &quot;time $argv&quot;;end</code></pre></li></ul></li></ul><p>其他具体功能见<a href="https://github.com/oh-my-fish/oh-my-fish">oh-my-fish</a></p><h4 id="3-1-3-Chromium"><a href="#3-1-3-Chromium" class="headerlink" title="3.1.3 Chromium"></a>3.1.3 Chromium</h4><p>安装方式:</p><pre><code class="line-numbers language-bash">sudo pacman -S chromium</code></pre><h4 id="3-1-4-nitrogen"><a href="#3-1-4-nitrogen" class="headerlink" title="3.1.4 nitrogen"></a>3.1.4 nitrogen</h4><p>一款可视化换壁纸的软件,当然<strong>feh</strong>也是一款优秀的壁纸切换软件，教程很多，这里不再说了</p><pre><code class="line-numbers language-bash">sudo pacman -S nitrogen</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/5.png"></p><h4 id="3-1-5-neofetch"><a href="#3-1-5-neofetch" class="headerlink" title="3.1.5 neofetch"></a>3.1.5 neofetch</h4><p>neofetch是一个个性化显示Linux系统信息的工具</p><pre><code class="line-numbers language-bash">sudo pacman -S neofetch</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/19.png"></p><h4 id="3-1-6-vim"><a href="#3-1-6-vim" class="headerlink" title="3.1.6 vim"></a>3.1.6 vim</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/6.png"></p><p>文本/代码编辑中最最最为优秀经典的上古神器,之后我会写一个调教Vim的教程</p><pre><code class="line-numbers language-bash">sudo pacman -S vim </code></pre><h4 id="3-1-7-albert"><a href="#3-1-7-albert" class="headerlink" title="3.1.7 albert"></a>3.1.7 albert</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/7.png"><br>一款软件/文件/搜索 启动器</p><pre><code class="line-numbers language-bash">sudo pacman -S albert</code></pre><p>第一次运行会提示你设置一下</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/8.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/9.png"></p><h4 id="3-1-8-iease-music"><a href="#3-1-8-iease-music" class="headerlink" title="3.1.8 iease-music"></a>3.1.8 iease-music</h4><p>网易云音乐最漂亮的第三方客户端！</p><pre><code class="line-numbers language-bash">sudo pacman -S iease-music</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/10.png"></p><h4 id="3-1-9-deepin-screenshot"><a href="#3-1-9-deepin-screenshot" class="headerlink" title="3.1.9 deepin-screenshot"></a>3.1.9 deepin-screenshot</h4><p>深度截图</p><pre><code class="line-numbers language-bash">sudo pacman -S deepin-screenshot</code></pre><h4 id="3-1-10-shadowsocks-qt5"><a href="#3-1-10-shadowsocks-qt5" class="headerlink" title="3.1.10 shadowsocks-qt5"></a>3.1.10 shadowsocks-qt5</h4><pre><code class="line-numbers language-bash">sudo pacman -S shadowsocks-qt5</code></pre><h4 id="3-1-11-thefuck"><a href="#3-1-11-thefuck" class="headerlink" title="3.1.11 thefuck"></a>3.1.11 thefuck</h4><p>自从用了”Thefuck”,妈妈再也不用担心我敲错命令了。<br>有了它，万物皆可fffffffffuck!</p><pre><code class="line-numbers language-bash">sudo pacman -S thefuck</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/11.png"></p><h4 id="3-1-12-compton"><a href="#3-1-12-compton" class="headerlink" title="3.1.12 compton"></a>3.1.12 compton</h4><p>设置窗口半透明+毛玻璃效果</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/16.png"></p><p>Manjaro i3 自带的有compton，不过这个只能做到半透明而没有毛玻璃效果，我使用的是<a href="https://github.com/tryone144/compton">Compton</a>,下面详细介绍一下安装过程</p><ol><li>卸载原有的compton</li></ol><pre><code class="line-numbers language-bash">sudo pacman -R compton</code></pre><p>若遇到依赖问题无法卸载，则</p><pre><code class="line-numbers language-bash">sudo pacman -Rc compton</code></pre><ol start="2"><li>clone仓库</li></ol><pre><code class="line-numbers language-bash">git clone git@github.com:liuyaanng/compton.git</code></pre><ol start="3"><li>安装</li></ol><p>具体内容参考<a href="https://github.com/liuyaanng/compton/blob/dual_kawase/README.md">README</a><br>安装前要确保下列依赖已经安装。<br>其实大部分都已经安装,只有个别没有，若下面安装不成功，则按提示把依赖装上即可，有问题也可以在issues上查看</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/17.png"></p><pre><code class="line-numbers language-bash">cd compton# Make the main programmake# Make the man pagemake docs# Installmake install</code></pre><ol start="4"><li>配置</li></ol><p>配置信息在<a href="">.config</a></p><h4 id="3-1-13-deepin-file-manager"><a href="#3-1-13-deepin-file-manager" class="headerlink" title="3.1.13 deepin-file-manager"></a>3.1.13 deepin-file-manager</h4><p>默认的 <code>pcmanfm</code> 竟然没有搜索功能，这不能忍啊<br>我使用 <code>deepin-file-manager</code> 来代替默认的 <code>pcmanfm</code></p><pre><code class="line-numbers language-bash">sudo pacman -S deepin-file-manager</code></pre><p>在配置文件里</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/20.png"></p><h3 id="3-2-i3的配置"><a href="#3-2-i3的配置" class="headerlink" title="3.2 i3的配置"></a>3.2 i3的配置</h3><p>i3的配置文件在 <code>~/.i3/config</code></p><p>里面的配置信息介绍的很详细,需要更详细的信息你可以阅读官方<a href="https://i3wm.org/docs/userguide.html">userguide</a></p><p> 首先在<code>Autoapplications</code>处添加自启动的应用</p><pre><code class="line-numbers language-bash">exec_always fcitxexec_always albert</code></pre><ul><li>把系统默认terminal换成<code>alacritty</code><br>在 <code>start a terminal</code>处将原来的代码注释掉，加上以下语句</li></ul><pre><code class="line-numbers language-bash">bindsym $mod+Return exec alacritty</code></pre><ul><li>设置软件启动快捷键</li></ul><p>在配置文件中添加</p><pre><code class="line-numbers language-bash">set $mod Mod4set $mod1 Mod1</code></pre><p>mod在这里设置的是键盘的<code>Super</code>键<br>mod1在这里设置的是<code>Alt</code>键</p><pre><code class="line-numbers language-bash">bindsym $mod+c exec chromiumbindsym $mod+p exec nitrogenbindsym $mod1+m exec iease-musicbindsym $mod1+Shift+a exec deepin-screenshot</code></pre><ul><li>窗口之间的间距通过i3-gaps来设置，若没有安装，则</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S i3-gaps</code></pre><p>在配置文件中加入</p><pre><code class="line-numbers language-bash">gaps inner 16gaps outer 0</code></pre><p>可以根据自己喜好调整数值</p><ul><li>xbacklight config</li></ul><p>install <code>xorg-xbacklight</code> first</p><pre><code class="line-numbers language-bash">sudo pacman -S xorg-xbacklight </code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h4 id="彻底解决蜂鸣问题"><a href="#彻底解决蜂鸣问题" class="headerlink" title="彻底解决蜂鸣问题"></a>彻底解决蜂鸣问题</h4><p>由于蜂鸣是由主板发出来的声音，故不能通过调节音量来消除此声音，要从源头上解决</p><ul><li>关闭终端下Tab键的蜂鸣提示</li></ul><pre><code class="line-numbers language-bash">sudo vim /etc/inputrc</code></pre><p>将 <code>set bell-style none</code> 前的注释去掉</p><ul><li>关闭vim中错误提示蜂鸣声</li></ul><pre><code class="line-numbers language-bash">vim .vim/vimrc</code></pre><p>在里面加入  <code>set vb t_vb= </code></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/">Arch Linux + i3wm详细配置篇</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manjaro </tag>
            
            <tag> linux </tag>
            
            <tag> i3wm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Face Recognition</title>
      <link href="/2019/08/10/face-recognition-with-opencv/"/>
      <url>/2019/08/10/face-recognition-with-opencv/</url>
      
        <content type="html"><![CDATA[<h1 id="Face-Recognition-with-OpenCV"><a href="#Face-Recognition-with-OpenCV" class="headerlink" title="Face Recognition with OpenCV"></a>Face Recognition with OpenCV</h1><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>My Particular Environment:<br>Ubuntu16.04 + OpenCV3.3.0 + OpenCV_contrib3.3.0</p><h2 id="1-Image-Acquisition-and-Face-Database-Creation"><a href="#1-Image-Acquisition-and-Face-Database-Creation" class="headerlink" title="1. Image Acquisition and Face Database Creation"></a>1. Image Acquisition and Face Database Creation</h2><h3 id="1-1-Image-Acquisition"><a href="#1-1-Image-Acquisition" class="headerlink" title="1.1 Image Acquisition"></a>1.1 Image Acquisition</h3><h4 id="1-1-1-Steps-and-methods"><a href="#1-1-1-Steps-and-methods" class="headerlink" title="1.1.1 Steps and methods"></a>1.1.1 Steps and methods</h4><ol><li>Open the camera and capture images;</li><li>Loading the face classifier;</li><li>Start face detection, frame the face part and display;</li><li>Under the condition that the face is detected, take a picture with one button;</li><li>For the face part, resize and write the image file in the specified directory;</li></ol><h4 id="1-1-2-Code"><a href="#1-1-2-Code" class="headerlink" title="1.1.2 Code"></a>1.1.2 Code</h4><pre><code class="line-numbers language-cpp">#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;#include &lt;stdio.h&gt;#include &lt;opencv2/face.hpp&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt; using namespace cv;using namespace std;using namespace cv::face;#define CV_COLOR_GREEN cv::Scalar(0, 255, 0)int resize_save(Mat&amp; faceIn, char* path, int  faceseq);//Input: current image, the path of file, the name or faceseq of images.//Output: None//Function: resize the current image to (92, 112), which is same to the train data.int get_face(char* path);//Input: the path of file.//Output: None//Function: Use face_cascade to detect if there are faces in the window, and save the faces through function reszie_save.int resize_save(Mat&amp; faceIn, char* path, int  faceseq)&#123;  string strname;  Mat faceOut;  bool ret;  if(faceIn.empty())&#123;    printf(&quot;FaceIn is empty.\n&quot;);    return -1;  &#125;  if(faceIn.cols &gt; 100)&#123;    resize(faceIn, faceOut, Size(92, 112));    //Resize and Keep a match with the train database.    strname = format(&quot;%s/%d.jpg&quot;, path, faceseq); //mkdir    ret = imwrite(strname, faceOut); //save image. Note the file suffix.    if(ret == false)&#123;      printf(&quot;Image write failed!\n&quot;);      printf(&quot;Please check filename[%s] is legal!\n&quot;, strname.c_str());      return -1;    &#125;    imshow(strname, faceOut);  &#125;  waitKey(20);  return 0;&#125;int get_face(char* path)&#123;  CascadeClassifier face_cascade;  VideoCapture camera;  int ret;  Mat frame;  //camera frame  vector&lt;Rect&gt; objects; //The faces coordinates.  Mat img_gary; //Gradation pictures.  Mat faceImg;  int faceNum = 1; //  char key;  camera.open(0);  if(!camera.isOpened())&#123;    cout &lt;&lt; &quot;Open camera failed.&quot; &lt;&lt; endl;    return -1;  &#125;  cout &lt;&lt; &quot;Open camera succeed. &quot; &lt;&lt; endl;  //Load the face cascadeclassifier.  ret = face_cascade.load(&quot;haarcascade_frontalface_alt2.xml&quot;);  if(!ret)&#123;    cout &lt;&lt; &quot;Load xml failed.&quot; &lt;&lt; endl;    return -1;  &#125;  cout &lt;&lt; &quot;Load xml succeed.&quot; &lt;&lt; endl;  while(1)&#123;    camera &gt;&gt; frame;    if(frame.empty())&#123;      continue;    &#125;    cvtColor(frame, img_gary, COLOR_BGR2GRAY); //Transform frame as the gradation picture, note imshow is still the original frame.    equalizeHist(img_gary, img_gary); //Histogram equalization, which is helpful to improve the quality of pictures.    //Face detection    face_cascade.detectMultiScale(img_gary, objects, 1.1,3 , 0, Size(50,50));    for(size_t i = 0; i &lt; objects.size(); i++)&#123;      rectangle(frame, objects[i], CV_COLOR_GREEN);    &#125;    imshow(&quot;Camera&quot;, frame);    key = waitKey(1);    switch (key)&#123;      case &#39;p&#39;: //tap &#39;P&#39; to save.        if(objects.size() == 1)&#123;          faceImg = frame(objects[0]);          ret = resize_save(faceImg, path, faceNum);          if(ret == 0)&#123;            cout &lt;&lt; &quot;resize_save succeed.\n&quot; &lt;&lt; endl;            faceNum++;          &#125;        &#125;        break;      case 27:   //switch to ESC        cout &lt;&lt; &quot;Esc ...&quot; &lt;&lt; endl;        return 0;      default:        break;    &#125;  &#125;&#125;int main(int argc, char* argv[])&#123;  if(argc != 2)      &#123;        printf(&quot;usage: %s &lt;path&gt;\n&quot;, argv[0]);        return -1;      &#125;  get_face(argv[1]);  return 0;&#125;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/4.jpg"><br>Note:    </p><ol><li>After the compilation is successful, the execution executable file must provide parameters, which are the directories for storing the face image, and it must be an existing directory.(E.g: ./program_name Img/s41)    </li><li>Press the “P” button to take a photo and save the face. Press the “Esc” button to exit.</li></ol><h3 id="1-2-Face-Database-Creation"><a href="#1-2-Face-Database-Creation" class="headerlink" title="1.2 Face Database Creation"></a>1.2 Face Database Creation</h3><p>The official document provides a download of the face database, and i use the <a href="http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html">AT&amp;T Facedatabase</a> to create my face database. I have updated this zip file to my github, you can download it from <a href="att_faces.zip">here</a> faster.<br>AT&amp;T Face Database is also known as the OCR face database, 40 people, 10 photos per person. The photos are token at different times, different lighting, different expressions(closed eyes, laughing or not laughing), different face details(with or without glasses). All images were captured on a dark , even background with a vertical face o the front(some with a slight rotation).<br>You can download the compressed package from the website, and first extract the att_faces folder. There are 40 folders under the folder, which named from “s1” to “s40”. Each folder has the same person’s photos with different expressions, and there are 10 face photos.<br>The format of these images is “.pgm”<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/2.png"></p><p>Note:<br>If you want to add your own photos to the face database through the program, the number of added pictures must be no less than 2.</p><h2 id="2-Face-Recognition-Model-training"><a href="#2-Face-Recognition-Model-training" class="headerlink" title="2. Face Recognition Model training"></a>2. Face Recognition Model training</h2><h3 id="2-1-Create-a-label-file-CSV"><a href="#2-1-Create-a-label-file-CSV" class="headerlink" title="2.1 Create a label file CSV"></a>2.1 Create a label file CSV</h3><p>With the face database data, we need to read it in the program, here we need to use csv file to read the image data in the face database.<br>The format of a csv file: image path name + label, such as /Img/s1/image.jpg;1<br>Assume the face image path is: /Img/s1/01..jpg<br>And we give this face image a label “1”, this label represents the person’s name. One person’s face image label must be the same.<br>You can create a csv file manually and then enter the data one by one. But if you use python, you don’t have to do this tedious and boring work.<br>The following is a piece of code which can write data in the CSV file automatically.</p><pre><code class="line-numbers language-python">#!/usr/bin/env pythonimport sysimport os.path# This is a tiny script to help you creating a CSV file from a face# database with a similar hierarchie:##  #  #  |-- s1#  |   |-- 1.pgm#  |   |-- ...#  |   |-- 10.pgm#  |-- s2#  |   |-- 1.pgm#  |   |-- ...#  |   |-- 10.pgm#  ...#  |-- s40#  |   |-- 1.pgm#  |   |-- ...#  |   |-- 10.pgm#if __name__ == &quot;__main__&quot;:    if len(sys.argv) != 2:        print &quot;usage: create_csv &lt;base_path&gt;&quot;        sys.exit(1)    BASE_PATH=sys.argv[1]            SEPARATOR=&quot;;&quot;    # This is output csv file.    fh = open(&quot;../at.csv&quot;,&#39;w&#39;)    for dirname, dirnames, filenames in os.walk(BASE_PATH):        for subdirname in dirnames:            subject_path = os.path.join(dirname, subdirname)            for filename in os.listdir(subject_path):                abs_path = &quot;%s/%s&quot; % (subject_path, filename)                print(&quot;%s%s%s&quot; % (abs_path, SEPARATOR, subdirname[1:]))                fh.write(abs_path)                fh.write(SEPARATOR)                fh.write(subdirname[1:])                fh.write(&quot;\n&quot;)    fh.close()</code></pre><p>You should set the image path parameter (absolute path) when running.(E.g: <strong>python filename.py /home/kevin/OpenCV/face_rec/Img</strong> ) and you can get a CSV file like this:<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/5.png"><br>This CSV file is created.</p><h3 id="2-2-Model-training"><a href="#2-2-Model-training" class="headerlink" title="2.2 Model training"></a>2.2 Model training</h3><p>This is the official example of OpenCV: <a href="https://docs.opencv.org/3.2.0/da/d60/tutorial_face_main.html">Click here</a><br>They offer three models: Eigenfaces, Fisherfaces and Local Binary Patterns Histograms(LBPH)    </p><p>Then I will train my own face database based on these models on the first step.</p><pre><code class="line-numbers language-cpp">static Mat norm_0_255(InputArray _src)&#123;  Mat src = _src.getMat();  Mat dst; //Create and return a normalized image matrix:  switch(src.channels()) &#123;    case 1:        cv::normalize(_src, dst, 0, 255, NORM_MINMAX, CV_8UC1);        break;    case 3:        cv::normalize(_src, dst, 0, 255, NORM_MINMAX, CV_8UC3);        break;    default:        src.copyTo(dst);        break;  &#125;  return dst;&#125;//load CSV filestatic void read_csv(const string&amp; filename, vector&lt;Mat&gt;&amp; images, vector&lt;int&gt;&amp; labels, char separator = &#39;;&#39;)&#123;  std::ifstream file(filename.c_str(), ifstream::in);    if (!file) &#123;        string error_message = &quot;No valid input file was given, please check the given filename.&quot;;        CV_Error(Error::StsBadArg, error_message);    &#125;    string line, path, classlabel;    while (getline(file, line)) &#123;        stringstream liness(line);        getline(liness, path, separator);        getline(liness, classlabel);        if(!path.empty() &amp;&amp; !classlabel.empty()) &#123;            images.push_back(imread(path, 0));            labels.push_back(atoi(classlabel.c_str()));        &#125;    &#125;&#125;void train_model(const string&amp; fn_csv)&#123;  // 2 containers to store image data and corresponding labels    vector&lt;Mat&gt; images;    vector&lt;int&gt; labels;    // load data    try    &#123;        read_csv(fn_csv, images, labels);    &#125;    catch (cv::Exception&amp; e)    &#123;        cerr &lt;&lt; &quot;Error opening file \&quot;&quot; &lt;&lt; fn_csv &lt;&lt; &quot;\&quot;. Reason: &quot; &lt;&lt; e.msg &lt;&lt; endl;        exit(1);    &#125;    if (images.size() &lt;= 1) &#123;        string error_message = &quot;This demo needs at least 2 images to work. Please add more images to your data set!&quot;;        CV_Error(CV_StsError, error_message);    &#125;    Mat testSample = images[images.size() - 1];    int testLabel = labels[labels.size() - 1];    images.pop_back();    labels.pop_back();    // The following lines create a feature face model for face recognition.     // Train it with images and tags read from a CSV file.     // Here is a complete PCA transform     //If you only want to keep 10 principal components, use the following code     // cv::EigenFaceRecognizer::create(10);     // cv::FisherFaceRecognizer::create(10);     //     // If you also want to initialize with a confidence threshold, use the following statement:     // cv::EigenFaceRecognizer::create(10, 123.0);     //     // If you use all features and use a threshold, use the following statement:     // cv::EigenFaceRecognizer::create(0, 123.0);     // cv::FisherFaceRecognizer::create(0, 123.0);    Ptr&lt;BasicFaceRecognizer&gt; model0 = EigenFaceRecognizer::create();    model0-&gt;train(images, labels);    model0-&gt;write(&quot;MyFacePCAModel.xml&quot;);    Ptr&lt;BasicFaceRecognizer&gt; model1 = FisherFaceRecognizer::create();    model1-&gt;train(images, labels);    model1-&gt;write(&quot;MyFaceFisherModel.xml&quot;);     Ptr&lt;LBPHFaceRecognizer&gt; model2 = LBPHFaceRecognizer::create();    model2-&gt;train(images, labels);    model2-&gt;write(&quot;MyFaceLBPHModel.xml&quot;);    // The test image is predicted below, predictedLabel is the predicted label result    int predictedLabel0 = model0-&gt;predict(testSample);    int predictedLabel1 = model1-&gt;predict(testSample);    int predictedLabel2 = model2-&gt;predict(testSample);    // There is also a way to get the result and get the threshold:    //      int predictedLabel = -1;    //      double confidence = 0.0;    //      model-&gt;predict(testSample, predictedLabel, confidence);    string result_message0 = format(&quot;Predicted class = %d / Actual class = %d.&quot;, predictedLabel0, testLabel);    string result_message1 = format(&quot;Predicted class = %d / Actual class = %d.&quot;, predictedLabel1, testLabel);    string result_message2 = format(&quot;Predicted class = %d / Actual class = %d.&quot;, predictedLabel2, testLabel);    cout &lt;&lt; result_message0 &lt;&lt; endl;    cout &lt;&lt; result_message1 &lt;&lt; endl;    cout &lt;&lt; result_message2 &lt;&lt; endl;    waitKey(0);&#125;int main(int argc, char* argv[])&#123;  if(argc != 2)      &#123;        printf(&quot;usage: %s &lt;csv_file&gt;\n&quot;, argv[0]);        return -1;      &#125;  string fn_csv = string(argv[1]);  train_model(fn_csv);  return 0;&#125;</code></pre><p>At this point, we have completed the training of the face model. And we get three files:     </p><p><code>MyFaceFisherModel.xml、MyFaceLBPHModel.xml、MyFacePCAModel.xml</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/6.png"><br>Note:    </p><ol><li><p>Changes to the API of the OpenCV3.3 Face Recognition Module</p><p>a. Facerec.hpp before opencv3.3</p><pre><code class="line-numbers language-cpp">#ifndef __OPENCV_FACEREC_HPP__#define __OPENCV_FACEREC_HPP__#include &quot;opencv2/face.hpp&quot;#include &quot;opencv2/core.hpp&quot;namespace cv &#123; namespace face &#123;// base for two classesclass CV_EXPORTS_W BasicFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setNumComponents */    CV_WRAP virtual int getNumComponents() const = 0;    // ----------- ...... -----------    CV_WRAP virtual cv::Mat getEigenValues() const = 0;    CV_WRAP virtual cv::Mat getEigenVectors() const = 0;    CV_WRAP virtual cv::Mat getMean() const = 0;&#125;;CV_EXPORTS_W Ptr&lt;BasicFaceRecognizer&gt; createEigenFaceRecognizer(int num_components = 0, double threshold = DBL_MAX);CV_EXPORTS_W Ptr&lt;BasicFaceRecognizer&gt; createFisherFaceRecognizer(int num_components = 0, double threshold = DBL_MAX);class CV_EXPORTS_W LBPHFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setGridX */    CV_WRAP virtual int getGridX() const = 0;    /** @copybrief getGridX @see getGridX */    CV_WRAP virtual void setGridX(int val) = 0;    // ----------- ...... -----------    CV_WRAP virtual cv::Mat getLabels() const = 0;&#125;;CV_EXPORTS_W Ptr&lt;LBPHFaceRecognizer&gt; createLBPHFaceRecognizer(int radius=1, int neighbors=8, int grid_x=8, int grid_y=8, double threshold = DBL_MAX);&#125;&#125; //namespace cv::face#endif //__OPENCV_FACEREC_HPP__</code></pre><ul><li><p>Comment section of the ninth line: <code>// base for two classes</code>,  This shows that BasicFaceRecognizer is the base class of two classes: EigenFaceRecognizer and FisherFaceRecognizer. With LBPHFaceRecognizer is irrelevant. Even the new API is still the case.</p></li><li><p>Method of creating three face recognizers.</p><pre><code class="line-numbers language-cpp">Ptr&lt;BasicFaceRecognizer&gt; model =  createEigenFaceRecognizer();Ptr&lt;BasicFaceRecognizer&gt; model =  createFisherFaceRecognizer();Ptr&lt;LBPHFaceRecognizer&gt; model  =  createLBPHFaceRecognizer();</code></pre></li></ul><p>b. Facerec.hpp after opencv3.3</p></li></ol><pre><code class="line-numbers language-cpp">#ifndef __OPENCV_FACEREC_HPP__#define __OPENCV_FACEREC_HPP__#include &quot;opencv2/face.hpp&quot;#include &quot;opencv2/core.hpp&quot;namespace cv &#123; namespace face &#123;// base for two classesclass CV_EXPORTS_W BasicFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setNumComponents */    CV_WRAP int getNumComponents() const;    // ----------- ...... -----------    CV_WRAP cv::Mat getEigenValues() const;    CV_WRAP cv::Mat getEigenVectors() const;    CV_WRAP cv::Mat getMean() const;    virtual void read(const FileNode&amp; fn);    virtual void write(FileStorage&amp; fs) const;    virtual bool empty() const;    using FaceRecognizer::read;    using FaceRecognizer::write;protected:    int _num_components;    double _threshold;    std::vector&lt;Mat&gt; _projections;    Mat _labels;    Mat _eigenvectors;    Mat _eigenvalues;    Mat _mean;&#125;;class CV_EXPORTS_W EigenFaceRecognizer : public BasicFaceRecognizer&#123;public:    CV_WRAP static Ptr&lt;EigenFaceRecognizer&gt; create(int num_components = 0, double threshold = DBL_MAX);&#125;;class CV_EXPORTS_W FisherFaceRecognizer : public BasicFaceRecognizer&#123;public:    CV_WRAP static Ptr&lt;FisherFaceRecognizer&gt; create(int num_components = 0, double threshold = DBL_MAX);&#125;;class CV_EXPORTS_W LBPHFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setGridX */    CV_WRAP virtual int getGridX() const = 0;    // ----------- ...... -----------    CV_WRAP virtual cv::Mat getLabels() const = 0;    CV_WRAP static Ptr&lt;LBPHFaceRecognizer&gt; create(int radius=1, int neighbors=8, int grid_x=8, int grid_y=8, double threshold = DBL_MAX);&#125;;&#125;&#125; //namespace cv::face#endif //__OPENCV_FACEREC_HPP__</code></pre><ul><li>Both EigenFaceRecognizer and FisherFaceRecognizer are inherited from BasicFaceRecognizer. However, the LBFPHaceRecognizer, like the BasicFaceRecognizer, inherits from FaceRecognizer.    </li><li>Method of creating three face recognizer</li></ul><pre><code class="line-numbers language-cpp">Ptr&lt;EigenFaceRecognizer&gt; model  = EigenFaceRecognizer::create();Ptr&lt;FisherFaceRecognizer&gt; model = FisherFaceRecognizer::create();Ptr&lt;LBPHFaceRecognizer&gt; model   = LBPHFaceRecognizer::create();</code></pre><h2 id="3-Identify-faces-in-the-video-stream-camera"><a href="#3-Identify-faces-in-the-video-stream-camera" class="headerlink" title="3. Identify faces in the video stream (camera)"></a>3. Identify faces in the video stream (camera)</h2><h3 id="3-1-Ready-to-work"><a href="#3-1-Ready-to-work" class="headerlink" title="3.1 Ready to work."></a>3.1 Ready to work.</h3><h4 id="3-1-1-Copy-the-training-file-obtained-in-the-second-step-to-the-current-folder"><a href="#3-1-1-Copy-the-training-file-obtained-in-the-second-step-to-the-current-folder" class="headerlink" title="3.1.1 Copy the training file obtained in the second step to the current folder."></a>3.1.1 Copy the training file obtained in the second step to the current folder.</h4><h4 id="3-1-2-The-process-or-method-of-Face-Recognition"><a href="#3-1-2-The-process-or-method-of-Face-Recognition" class="headerlink" title="3.1.2 The process or method of Face Recognition"></a>3.1.2 The process or method of Face Recognition</h4><p>This step has a similar part to the creation of a face recognition database.</p><ul><li>Open the camera</li><li>Loading face detector, face model</li><li>Scale the image (for efficiency)</li><li>Face recognition (compare to face model)</li><li>Label faces with rectangular wireframes and add text labels</li></ul><h4 id="3-2-Code"><a href="#3-2-Code" class="headerlink" title="3.2 Code"></a>3.2 Code</h4><pre><code class="line-numbers language-cpp">#include &lt;opencv2/opencv.hpp&gt;  #include &quot;opencv2/core.hpp&quot;#include &quot;opencv2/face.hpp&quot;#include &quot;opencv2/highgui.hpp&quot;#include &quot;opencv2/imgproc.hpp&quot;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace cv;using namespace cv::face;using namespace std;#define ROW_MIN        45int exitFlag = 0;int Recognition_And_Draw();int Recognition_And_Draw()&#123;  int ret = 0; //  double scale = 4; //Zoom factor  double fx = 1 / scale;  Mat frame;  //Video frame  VideoCapture cap(0);    //Open the camera  if(!cap.isOpened())&#123;    cout &lt;&lt; &quot;Open camera failed.\n&quot; &lt;&lt; endl;    return -1;  &#125;  //Load cascade classifier  CascadeClassifier cascade;  ret = cascade.load(&quot;haarcascade_frontalface_alt2.xml&quot;);  if(!ret)&#123;    printf(&quot;Load xml failed[ret = %d]. \n&quot;, ret);    return -1;  &#125;  cout &lt;&lt; &quot;Load xml succeed.&quot; &lt;&lt; endl;  // Loading trained face models  Ptr&lt;BasicFaceRecognizer&gt; modelPCA = EigenFaceRecognizer::create();    modelPCA-&gt;read(&quot;MyFacePCAModel.xml&quot;);    Ptr&lt;BasicFaceRecognizer&gt; modelFisher = FisherFaceRecognizer::create();  modelFisher-&gt;read(&quot;MyFaceFisherModel.xml&quot;);    Ptr&lt;LBPHFaceRecognizer&gt; modelLBPH = LBPHFaceRecognizer::create();    modelLBPH-&gt;read(&quot;MyFaceLBPHModel.xml&quot;);    while(!exitFlag)&#123;    cap &gt;&gt; frame;    if(frame.empty())      continue;    Mat facesImg;  //    vector&lt;Rect&gt; faces;  //Create a vector container for storing faces    Mat gary_img; //grayscale image    Mat scl_gary_img; //Scaled grayscale image    cvtColor(frame, gary_img, COLOR_BGR2GRAY); //Convert the original image to a grayscale image    resize(gary_img, scl_gary_img, Size(), fx, fx, INTER_LINEAR); //resize img    equalizeHist( scl_gary_img, scl_gary_img );  //face detection    cascade.detectMultiScale(scl_gary_img, faces, 1.1, 2, 0|CASCADE_SCALE_IMAGE,Size(30, 30));    printf(&quot;Face.size = %ld\n&quot;, faces.size());  //facesImg = scl_gary_img(faces[0]);    Mat face_resize;  //To prevent the picture is too small (that is, people too far away from the camera)    int predictPCA = 0;      int predictFisher = 0;      int predictLBPH = 0;    for(size_t i = 0; i &lt; faces.size(); i++)&#123;      Rect rectFace = faces[i];      facesImg = scl_gary_img(faces[i]);      if(facesImg.rows &gt;= ROW_MIN)&#123;        resize(facesImg, face_resize, Size(92, 112));      &#125;      else&#123;        printf(&quot;faceImg.rows[%d] &lt; %d \n&quot;, facesImg.rows, ROW_MIN);        continue;      &#125;      if(!face_resize.empty())&#123;        predictPCA = modelPCA-&gt;predict(face_resize);          predictFisher = modelFisher-&gt;predict(face_resize);          predictLBPH = modelLBPH-&gt;predict(face_resize);       &#125;      cout &lt;&lt; &quot;predictPCA   : &quot; &lt;&lt; predictPCA    &lt;&lt; endl;      cout &lt;&lt; &quot;predictFisher: &quot; &lt;&lt; predictFisher &lt;&lt; endl;      cout &lt;&lt; &quot;predictLBPH  : &quot; &lt;&lt; predictLBPH   &lt;&lt; endl;      rectangle(frame, Point(rectFace.x, rectFace.y) * scale, Point(rectFace.x + rectFace.width, rectFace.y + rectFace.height) * scale, Scalar(0, 255, 0), 2, 8);      if (predictPCA == 41)&#123;        putText(frame, &quot;Liuyang&quot;, Point(faces[i].x, faces[i].y) * scale, FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 0, 255), 2);      &#125;      else&#123;        putText(frame, &quot;X&quot;, Point(faces[i].x, faces[i].y) * scale, FONT_HERSHEY_SIMPLEX, 1.5, Scalar(0, 0, 255), 2);      &#125;  // if(faces.size() &lt;= 0)&#123;  //  cout &lt;&lt; &quot;There are no faces in the camera.\n&quot; &lt;&lt; endl; // &#125;    &#125;    imshow(&quot;frame&quot;, frame);      if (waitKey(1) == 27)&#123;                exitFlag = 1;                cout &lt;&lt; &quot;Esc...&quot; &lt;&lt; endl;                break;      &#125;  &#125;&#125;int main()&#123;  Recognition_And_Draw();  return 0;&#125;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/7.jpg"></p><p>Note:    </p><ol><li>This program supports multiple face recognition at the same time</li><li>Face recognition accuracy is not high, and it is susceptible to environmental factors such as light.</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/08/17/leetcode-easy-9/">LeetCode EASY_9</a></li><li><a href="https://godliuyang.wang/2020/03/30/scikit-image-guide/">scikit-image guide</a></li><li><a href="https://godliuyang.wang/2020/01/29/sort/">SORT</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
          <category> Face Recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
            <tag> python </tag>
            
            <tag> Face Recongnition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Enjoy PyTorch</title>
      <link href="/2019/08/07/enjoy-pytorch/"/>
      <url>/2019/08/07/enjoy-pytorch/</url>
      
        <content type="html"><![CDATA[<h1 id="Installing-PyTorch-with-Anaconda-and-Conda"><a href="#Installing-PyTorch-with-Anaconda-and-Conda" class="headerlink" title="Installing PyTorch with Anaconda and Conda"></a>Installing PyTorch with Anaconda and Conda</h1><p>My Particular Environment:</p><ul><li>OS: Ubuntu 16.04</li><li>Package Manager: conda</li><li>Python: 3.6</li><li>CUDA: None</li></ul><p>Getting started with PyTorch is very easy. The recommended best option is to use the Anaconda Pythob package manager.</p><ol><li><a href="https://www.anaconda.com/distribution/">Download and install Anaconda</a>(Go with the latest Python version)<br>You can download the <code>.sh</code> package from the Anaconda website, but it’s very slowly for me. So i find another choice.<br>You can find it in <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Tsinghua university open source mirror station</a>, which i download is <code>Anaconda3-5.2.0-Linux-x86_64.sh</code>. Or if you already get the “wget”, you can run this command in the terminal.<pre><code class="line-numbers language-bash">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.2.0-Linux-x86_64.sh</code></pre>Use <code>conda -V</code> to check the Version of Anaconda after open a new terminal.<br>If it isn’t work, try,<pre><code class="line-numbers language-bash">echo &#39;export PATH=&quot;~/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; ~/.bashrcsource ./bashrc</code></pre></li><li>Go to the Getting Started section on the <a href="https://pytorch.org/">Pytorch website</a>.</li><li>Specify the appropriate configuration options for your particular environment.<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Enjoy-PyTorch-Task1/1.png"></li><li>Run the presented command in the terminal to install Pytorch.<pre><code class="line-numbers language-bash">conda install pytorch-cpu torchvision-cpu -c pytorch</code></pre></li></ol><pre><code class="line-numbers language-python">import torchimport torch.nn as nnimport torchvisionimport torch.utils.data as Data# Hyper ParametersEPOCH = 1  BATCH_SIZE = 50LR = 0.001  DOWNLOAD_MNIST = True  # Mnisttrain_data = torchvision.datasets.MNIST(    root=&#39;./mnist/&#39;,      train=True,  # this is training data    transform=torchvision.transforms.ToTensor(),  # exchange PIL.Image or numpy.ndarray to torch.FloatTensor (C x H x W)    download=DOWNLOAD_MNIST,  )test_data = torchvision.datasets.MNIST(    root=&#39;./mnist/&#39;,    train=False)# BATCH_SIZEtrain_loader = Data.DataLoader(    dataset=train_data,    batch_size=BATCH_SIZE,    shuffle=True  )# test_datatest_x = torch.unsqueeze(test_data.test_data, dim=1).type(torch.FloatTensor)test_y = test_data.test_labels# cnnclass CNN(nn.Module):    def __init__(self):        super(CNN, self).__init__()        self.layer1 = nn.Sequential(            # (1, 28, 28)            nn.Conv2d(                in_channels=1,                out_channels=16,                kernel_size=5,                  stride=1,                  padding=2,                groups=1            ),            # (16, 28, 38)            nn.ReLU(),            nn.MaxPool2d(kernel_size=2)            # (16, 14, 14)        )        self.layer2 = nn.Sequential(            nn.Conv2d(                in_channels=16,                out_channels=32,                kernel_size=5,                stride=1,                padding=2            ),            nn.ReLU(),            nn.MaxPool2d(kernel_size=2)        )        self.layer3 = nn.Linear(32 * 7 * 7, 10)    def forward(self, x):        # print(x.shape)        x = self.layer1(x)        # print(x.shape)        x = self.layer2(x)        # print(x.shape)        x = x.view(x.size(0), -1)        # print(x.shape)        x = self.layer3(x)        # print(x.shape)        return xcnn = CNN()optimizer = torch.optim.Adam(cnn.parameters(), lr=LR)loss_function = nn.CrossEntropyLoss()for epoch in range(EPOCH):    for step, (b_x, b_y) in enumerate(train_loader):        output = cnn(b_x)        loss = loss_function(output, b_y)        optimizer.zero_grad()        loss.backward()        optimizer.step()print(&#39;finished training&#39;)test_out = cnn(test_x)predict_y = torch.argmax(test_out, 1).data.numpy()print(&#39;Accuracy in Test : %.4f%%&#39; % (sum(predict_y == test_y.data.numpy()) * 100/ len(predict_y)))</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/04/21/gpu-servers/">GPU servers</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> PyTorch Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA算法实现</title>
      <link href="/2019/08/07/pca-suan-fa-shi-xian/"/>
      <url>/2019/08/07/pca-suan-fa-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="PCA算法实例及C-实现"><a href="#PCA算法实例及C-实现" class="headerlink" title="PCA算法实例及C++实现"></a>PCA算法实例及C++实现</h1><h2 id="PCA算法"><a href="#PCA算法" class="headerlink" title="PCA算法"></a>PCA算法</h2><p>总结一下PCA的算法步骤：</p><p>设有m条n维数据。</p><ol><li>将原始数据按列组成n行m列矩阵X</li><li>将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</li><li>求出协方差矩阵 $C=\frac{1}{m}XX^\mathsf{T}$</li><li>求出协方差矩阵的特征值及对应的特征向量</li><li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</li><li>$Y = PX$即为降维到k维后的数据</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以<br>$$ \begin{pmatrix}<br>  -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>  -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \<br>\end{pmatrix} $$<br>为例，我们用PCA方法将这组二维数据其降到一维。</p><p>因为这个矩阵的每行已经是零均值，这里我们直接求协方差矩阵：<br>$$ C=\frac{1}{5}\begin{pmatrix}<br>  -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>  -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \<br>\end{pmatrix}\begin{pmatrix}<br>  -1 &amp; -2 \\<br>  -1 &amp; 0  \\<br>  0  &amp; 0  \\<br>  2  &amp; 1  \\<br>  0  &amp; 1 \<br>\end{pmatrix}=\begin{pmatrix}<br>  \frac{6}{5} &amp; \frac{4}{5} \\<br>  \frac{4}{5} &amp; \frac{6}{5} \<br>\end{pmatrix}$$<br>然后求其特征值和特征向量，具体求解方法不再详述，可以参考相关资料。求解后特征值为：<br>$$\lambda_1=2,\lambda_2=2/5$$<br>其对应的特征向量分别是：<br>$$c_1\begin{pmatrix}<br>  1 \\<br>  1<br>\end{pmatrix},c_2\begin{pmatrix}<br>  -1 \\<br>  1<br>\end{pmatrix}$$<br>其中对应的特征向量分别是一个通解， $c_1$和 $c_2$ 可取任意实数。那么标准化后的特征向量为：<br>$$\begin{pmatrix}<br>  1/\sqrt{2} \\<br>  1/\sqrt{2}<br>\end{pmatrix},\begin{pmatrix}<br>  -1/\sqrt{2} \\<br>  1/\sqrt{2}<br>\end{pmatrix}$$<br>因此我们的矩阵P是：<br>$$P=\begin{pmatrix}<br>  1/\sqrt{2}  &amp; 1/\sqrt{2}  \\<br>  -1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}$$<br>最后我们用P的第一行乘以数据矩阵，就得到了降维后的表示：<br>$$Y=\begin{pmatrix}<br>  1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}\begin{pmatrix}<br>  -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>  -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\end{pmatrix}=\begin{pmatrix}<br>  -3/\sqrt{2} &amp; -1/\sqrt{2} &amp; 0 &amp; 3/\sqrt{2} &amp; -1/\sqrt{2}<br>\end{pmatrix}$$<br>可以验证协方差矩阵C的对角化：<br>$$PCP^\mathsf{T}=\begin{pmatrix}<br>  1/\sqrt{2}  &amp; 1/\sqrt{2}  \\<br>  -1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}\begin{pmatrix}<br>  6/5 &amp; 4/5 \\<br>  4/5 &amp; 6/5<br>\end{pmatrix}\begin{pmatrix}<br>  1/\sqrt{2} &amp; -1/\sqrt{2}  \\<br>  1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}=\begin{pmatrix}<br>  2 &amp; 0  \\<br>  0 &amp; 2/5<br>\end{pmatrix}$$<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/02.png"></p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><p>因为要对一组图片信息进行训练，所以我写了一部分通过摄像头截取图片帧的代码，<code>get_img()</code>函数。这里提取了5个特征脸和一个均值脸</p><pre><code class="line-numbers language-cpp">#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#define img_num 300 //训练图片的张数using namespace cv;using namespace std;//通过摄像头保存要训练的图片//打开摄像头int get_img()&#123;  VideoCapture cap(0);  if(!cap.isOpened())  &#123;    return -1;  &#125;  Mat frame;  bool stop = false;  int i = 1;  while(!stop)&#123;    cap &gt;&gt; frame;    printf(&quot;%d\n&quot;, i);    if (frame.empty())      stop = true;    //string filename = format(&quot;%d.jpg&quot;, i);    char filename[20];    sprintf(filename, &quot;Img/%d.jpg&quot;, i);    imwrite(filename, frame);    i++;    imshow(&quot;frame&quot;, frame);    waitKey(30);    if(i &gt; img_num)      break;  &#125;return -1;&#125;//把图像归一化为0-255Mat norm_0_255(const Mat&amp; src)&#123;  Mat dst;  switch(src.channels())&#123;    case 1:        cv::normalize(src, dst, 0, 255, NORM_MINMAX, CV_8UC1);        break;    case 3:        cv::normalize(src, dst, 0, 255, NORM_MINMAX, CV_8UC3);        break;    default:        src.copyTo(dst);        break;  &#125;  return dst;&#125;//将给定的图像转化为行矩阵Mat asRowMatrix(const vector&lt;Mat&gt;&amp; src, int rtype, double alpha = 1, double beta = 0)&#123;  // 样本数量  size_t n = src.size();  //没有样本，返回空矩阵  if (n == 0)    return Mat();  //样本的维数  size_t d = src[0].total();  Mat data(n, d, rtype);  //拷贝数据  for (int i = 0; i &lt; n; i++)&#123;    if(src[i].empty())&#123;      string error_message = format(&quot;Image number %d was empty, please check your input data.&quot;, i);      CV_Error(CV_StsBadArg, error_message);    &#125;    //确保数据能被reshape    if(src[i].total() != d)&#123;      string error_message = format(&quot;Wrong number of elements in matrix #%d! Expected %d was %d.&quot;, i, d, src[i].total());      CV_Error(CV_StsBadArg, error_message);    &#125;    Mat xi = data.row(i);    //转化为1行，n列的格式    if(src[i].isContinuous())&#123;      src[i].reshape(1, 1).convertTo(xi, rtype, alpha, beta);    &#125;    else &#123;      src[i].clone().reshape(1, 1).convertTo(xi, rtype, alpha, beta);    &#125;  &#125;  return data;&#125;int main(int argc, const char* argv[])&#123;  vector&lt;Mat&gt; db;  //get_img();  for(int i=1; i&lt;img_num;i++)&#123;    string filename = format(&quot;Img/%d.jpg&quot;, i);    db.push_back(imread(filename, IMREAD_GRAYSCALE));  &#125;  // Build a matrix with the observations in row:    Mat data = asRowMatrix(db, CV_32FC1);    // PCA算法保持5主成分分量    int num_components = 5;    //执行pca算法    PCA pca(data, Mat(), CV_PCA_DATA_AS_ROW, num_components);    //copy  pca算法结果    Mat mean = pca.mean.clone();    Mat eigenvalues = pca.eigenvalues.clone();    Mat eigenvectors = pca.eigenvectors.clone();        //均值脸    imshow(&quot;avg&quot;, norm_0_255(mean.reshape(1, db[0].rows)));    //五个特征脸    imshow(&quot;pc1&quot;, norm_0_255(pca.eigenvectors.row(0)).reshape(1, db[0].rows));    imshow(&quot;pc2&quot;, norm_0_255(pca.eigenvectors.row(1)).reshape(1, db[0].rows));    imshow(&quot;pc3&quot;, norm_0_255(pca.eigenvectors.row(2)).reshape(1, db[0].rows));    imshow(&quot;pc4&quot;, norm_0_255(pca.eigenvectors.row(3)).reshape(1, db[0].rows));    imshow(&quot;pc5&quot;, norm_0_255(pca.eigenvectors.row(4)).reshape(1, db[0].rows));    while(1)        waitKey(0);    // Success!    return 0;&#125;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/01.png"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/05/pca-yuan-li-fen-xi/">PCA原理分析</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA原理分析</title>
      <link href="/2019/08/05/pca-yuan-li-fen-xi/"/>
      <url>/2019/08/05/pca-yuan-li-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>参考资料<br><a href="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/PCA.pdf">PCA原理分析</a></p><h1 id="PCA的数学原理"><a href="#PCA的数学原理" class="headerlink" title="PCA的数学原理"></a>PCA的数学原理</h1><p>PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。</p><h2 id="数据的向量表示以及降维问题"><a href="#数据的向量表示以及降维问题" class="headerlink" title="数据的向量表示以及降维问题"></a>数据的向量表示以及降维问题</h2><p>一般情况下，在数据挖掘和机器学习中，数据被表示为向量。例如某个外卖商家2018年全年的流量及交易记录可以看成是一组数据的集合，其中每一天的数据是一条记录。记录的格式如下:<br>(日期, 浏览量，访客数，下单数，成交数，成交金额)<br>其中”日期”是一个记录标志而非度量值，而数据挖掘关心的大多是度量值，因此如果我们忽略日期这个字段后，我们得到一组记录，每条记录可以被表示为一个五维向量，其中一条看起来大约是这个样子：<br>$$(1000, 580, 300, 240, 3000)^T$$<br>注意这里用了转置，习惯上使用列向量来表示一条记录。本文说到的向量默认都是列向量。    </p><p>我们当然可以对这一组五维向量进行分析和挖掘，不过很多机器学习算法的复杂度和数据的维数有着密切关系，甚至与维数呈指数级关联。当然，这里区区五维的数据，也许还无所谓，但是实际机器学习中处理成千上万甚至几十万维的情况也并不罕见，在这种情况下，机器学习的资源消耗是不可接受的，因此我们必须对数据进行降维。</p><p>降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。    </p><p>举一个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。<br>当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“ <strong>相关关系</strong>”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。<br>这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。    </p><p>上面给出的是降维的朴素思想描述，可以有助于直观理解降维的动机和可行性，但并不具有操作指导意义。例如，我们到底删除哪一列损失的信息才最小？亦或根本不是单纯删除几列，而是通过某些变换将原始数据变为更少的列但又使得丢失的信息最小？到底如何度量丢失信息的多少？如何根据原始数据决定具体的降维操作步骤？下面对降维问题进行数学化和形式化的讨论</p><h2 id="向量的表示及基变换"><a href="#向量的表示及基变换" class="headerlink" title="向量的表示及基变换"></a>向量的表示及基变换</h2><h3 id="内积与投影"><a href="#内积与投影" class="headerlink" title="内积与投影"></a>内积与投影</h3><p>下面先来看一个高中就学过的向量运算：内积。两个维数相同的向量的内积被定义为：</p><p>$$(a_1, a_2, \dots ,a_n)^T \cdot (b_1, b_2, \dots , b_n)^T = a_1b_1 + a_2b_2 + \dots + a_nb_n)$$<br>内积运算将两个向量映射为一个实数。其计算方式非常容易理解，但是其意义并不明显。下面我们分析内积的几何意义。假设A和B是两个n维向量，我们知道n维向量可以等价表示为n维空间中的一条从原点发射的有向线段，为了简单起见我们假设A和B均为二维向量,则 $A = (x_1,y_1)$, $B = (x_2,y_2)$. 则在二维平面上A和B可以用两条发自原点的有向线段表示，见下图：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/01.png"><br>好，现在我们从A点向B所在直线引一条垂线。我们知道垂线与B的交点叫做A在B上的投影，再设A与B的夹角是a，则投影的矢量长度为|A|cos(a),其中 $|A| = \sqrt{x_1^2 + y_1^2}$ 是向量A的模，也就是A线段的标量长度。<br>注意这里我们专门区分了矢量长度和标量长度，标量长度总是大于等于0，值就是线段的长度；而矢量长度可能为负，其绝对值是线段长度，而符号取决于其方向与标准方向相同或相反。<br>到这里还是看不出内积和这东西有什么关系，不过如果我们将内积表示为另一种我们熟悉的形式：<br>$$ A \cdot B = |A||B|cos(a)$$</p><p>现在事情似乎是有点眉目了：A与B的内积等于A到B的投影长度乘以B的模。再进一步，如果我们假设B的模为1，即让|B|=1，那么就变成了：<br>$$A \cdot B = |A|cos(a)$$<br>也就是说， <strong>设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度！</strong>这就是内积的一种几何解释，也是我们得到的第一个重要结论。在后面的推导中，将反复使用这个结论。</p><h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>下面我们继续在二维空间内讨论向量。上文说过，一个二维向量可以对应二维笛卡尔直角坐标系中从原点出发的一个有向线段。例如下面这个向量：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/02.png"><br>在代数表示方面，我们经常用线段终点的点坐标表示向量，例如上面的向量可以表示为(3,2)，这是我们再熟悉不过的向量表示。<br>不过我们常常忽略， <strong>只有一个(3,2)本身是不能够精确表示一个向量的</strong>。我们仔细看一下，这里的3实际表示的是向量在x轴上的投影值是3，在y轴上的投影值是2。也就是说我们其实隐式引入了一个定义：以x轴和y轴上正方向长度为1的向量为标准。那么一个向量(3,2)实际是说在x轴投影为3而y轴的投影为2。注意投影是一个矢量，所以可以为负。<br>更正式的说，向量(x,y)实际上表示线性组合：<br>$$x(1,0)^T + y(0,1)^T$$<br>不难证明所有二维向量都可以表示为这样的线性组合。此处(1,0)和(0,1)叫做二维空间中的一组基。<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/03.png"><br>所以， <strong>要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了</strong>。只不过我们经常省略第一步，而默认以(1,0)和(0,1)为基。<br>我们之所以默认选择(1,0)和(0,1)为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。    </p><p>例如，(1,1)和(-1,1)也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1，那么就可以方便的用向量点乘基而直接获得其在新基上的坐标了！实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为 $(\frac{1}{\sqrt 2},\frac{1}{\sqrt 2})$ 和 $(\frac{-1}{\sqrt 2},\frac{1}{\sqrt 2})$.<br>现在，我们想获得(3,2)在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算(3,2)和两个基的内积，不难得到新的坐标为 $(\frac{5}{\sqrt 2},\frac{-1}{\sqrt 2})$。下图给出了新的基以及(3,2)在新基上坐标值的示意图：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/05.png"><br>一要求就是线性无关，非正交的基也是可以的。不过因为正交基有较好的性质，所以一般使用的基都是正交的。</p><h3 id="基变换的矩阵表示"><a href="#基变换的矩阵表示" class="headerlink" title="基变换的矩阵表示"></a>基变换的矩阵表示</h3><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将(3,2)变换为新基上的坐标，就是用(3,2)与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换：<br>$$\begin{pmatrix}<br>1/ \sqrt 2 &amp; 1/ \sqrt 2 \\<br>-1/ \sqrt 2 &amp; 1/ \sqrt 2 \<br>\end{pmatrix}<br>\begin{pmatrix}<br>3 \\<br>2 \<br>\end{pmatrix} = \begin{pmatrix}<br>5 / \sqrt 2 \\<br>-1/ \sqrt 2 \<br>\end{pmatrix}$$</p><p>太漂亮了！其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标。可以稍微推广一下，如果我们有m个二维向量，只要将二维向量按列排成一个两行m列矩阵，然后用“基矩阵”乘以这个矩阵，就得到了所有这些向量在新基下的值。例如 $(1,1)，(2,2)，(3,3)$，想变换到刚才那组基上，则可以这样表示：</p><p>$$\begin{pmatrix}<br>1 / \sqrt 2 &amp; 1/ \sqrt 2 \\<br>-1 / \sqrt 2 &amp; 1/ \sqrt 2 \<br>\end{pmatrix}<br>\begin{pmatrix}<br>1 &amp; 2 &amp; 3 \\<br>1 &amp; 2 &amp; 3 \<br>\end{pmatrix} = \begin{pmatrix}<br>2 / \sqrt 2 &amp; 4 / \sqrt 2 &amp; 6 / \sqrt 2 \\<br>0 &amp; 0 &amp; 0 \<br>\end{pmatrix}$$</p><p>于是一组向量的基变换被干净的表示为矩阵的相乘。<br><strong>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果。</strong><br>数学表示为：<br>$$\begin{pmatrix}<br>p_1 \\<br>p_2 \\<br>\vdots \\<br>p_R \<br>\end{pmatrix}<br>\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \dots &amp; a_M \<br>\end{pmatrix} = \begin{pmatrix}<br>p_1a_1 &amp; p_1a_2 &amp; \dots &amp; p_1a_M \\<br>p_2a_1 &amp; p_2a_2 &amp; \dots &amp; p_2a_M \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>p_Ra_1 &amp; p_Ra_2 &amp; \dots &amp; p_Ra_M \<br>\end{pmatrix}$$<br>其中 $p_i$是一个行向量，表示第i个基， $a_j$是一个列向量，表示第j个原始数据记录。<br>特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。因此这种矩阵相乘的表示也可以表示降维变换。<br>最后，上述分析同时给矩阵相乘找到了一种物理解释： <strong>两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去</strong>。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学线性代数时对矩阵相乘的方法感到奇怪，但是如果明白了矩阵相乘的物理意义，其合理性就一目了然了。    </p><h3 id="协方差矩阵及优化目标"><a href="#协方差矩阵及优化目标" class="headerlink" title="协方差矩阵及优化目标"></a>协方差矩阵及优化目标</h3><p>上面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？<br>要完全数学化这个问题非常繁杂，这里我们用一种非形式化的直观方法来看这个问题。</p><p>为了避免过于抽象的讨论，我们仍以一个具体的例子展开。假设我们的数据由五条记录组成，将它们表示成矩阵形式：<br>$$ \begin{pmatrix}<br>1 &amp; 1 &amp;2 &amp; 4 &amp; 2 \\<br>1 &amp; 3 &amp; 3 &amp; 4 &amp; 4 \<br>\end{pmatrix}$$<br>其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。<br>我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：<br>$$ \begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \<br>\end{pmatrix}$$<br>我们可以看下五条数据在平面直角坐标系内的样子：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/06.png"><br>现在问题来了：如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？    </p><p>通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。    </p><p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。    </p><p>以上图为例，可以看出如果向x轴投影，那么最左边的两个点会重叠在一起，中间的两个点也会重叠在一起，于是本身四个各不相同的二维点投影后只剩下两个不同的值了，这是一种严重的信息丢失，同理，如果向y轴投影最上面的两个点和分布在x轴上的两个点也会重叠。所以看来x和y轴都不是最好的投影选择。我们直观目测，如果向通过第一象限和第三象限的斜线投影，则五个点在投影后还是可以区分的。<br>下面，我们用数学方法表述这个问题。</p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>上文说到，我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：<br>$$Var(a)=\frac{1}{m} \sum_{i=1}^{m}(a_i- \mu)^2$$<br>由于上面我们已经将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：<br>$$Var(a) = \frac{1}{m} \sum_{i=1}^{m}a_i^2$$<br>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。    </p><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。<br>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。<br>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：<br>$$Cov(a,b)=\frac{1}{m} \sum_{i=1}^{m}a_ib_i$$<br>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p><p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p><p>至此，我们得到了降维问题的优化目标：<strong>将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）</strong>。</p><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。</p><p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。于是我们来了灵感：</p><p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：</p><p>$$ X = \begin{pmatrix}<br>a_1 &amp; a_2 &amp; \dots &amp; a_m \\<br>b_1 &amp; b_2 &amp; \dots &amp; b_m \<br>\end{pmatrix}$$<br>然后我们用X乘以X的转置，并乘上系数 $\frac{1}{m}$：<br>$$\frac{1}{m} \begin{pmatrix}<br>\frac{1}{m} \sum_{i=1}^{m}a_i^2 &amp; \frac{1}{m} \sum_{i=1}^{m}a_ib_i \\<br>\frac{1}{m} \sum_{i=1}^{m}a_ib_i &amp; \frac{1}{m} \sum_{i=1}^{m}b_i^2 \<br>\end{pmatrix}$$</p><p>奇迹出现了！这个矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p><p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：</p><p><strong>设我们有m个n维数据记录，将其按列排成n乘m的矩阵X，设 $C = \frac{1}{m}XX^T$,则C是一个对称矩阵，其对角线分别个各个字段的方差，而第i行j列和j行i列元素相同，表示i和j两个字段的协方差。</strong></p><h3 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h3><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p><p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：<br>$$\begin{align}<br>D &amp;= \frac{1}{m}YY^T \\<br>  &amp;= \frac{1}{m}(PX)(PX)^T \\<br>  &amp;= \frac{1}{m}PXX^T P^T \\<br>  &amp;= P(\frac{1}{m}XX^T)P^T \\<br>  &amp;= PCP^T<br>\end{align}$$</p><p>现在事情很明白了！我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了寻找一个矩阵P，满足 $PCP^T$ 是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件。<br>现在所有焦点都聚焦在了协方差矩阵对角化问题上，有时，我们真应该感谢数学家的先行，因为矩阵对角化在线性代数领域已经属于被玩烂了的东西，所以这在数学上根本不是问题。</p><p>由上文知道，协方差矩阵C是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：</p><ol><li>实对称矩阵不同特征值对应的特征向量必然正交</li><li>设特征向量λ重数为r，则必然存在r个线性无关的特征向量对应于λ，因此可以将这r个特征向量单位正交化。<br>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为 $e_1,e_2,\dots,e_n,$ 我们将其按列组成矩阵：<br>$$E = \begin{pmatrix}<br>e_1 &amp; e_2 &amp; \dots &amp; e_n \<br>\end{pmatrix}$$<br>则对协方差矩阵C有如下结论：<br>$$E_TCE = \Lambda = \begin{pmatrix}<br>\lambda_1 &amp; &amp; &amp; \\<br>&amp; \lambda_2 &amp; &amp; \\<br>&amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; \lambda_n \<br>\end{pmatrix}$$<br>其中 $Lambda$为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。</li></ol><p>以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p><p>到这里，我们发现我们已经找到了需要的矩阵P：<br>$$P = E^T$$</p><p>P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照Λ中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Face Detection</title>
      <link href="/2019/08/03/face-detection/"/>
      <url>/2019/08/03/face-detection/</url>
      
        <content type="html"><![CDATA[<h1 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h1><h2 id="OpenCV模块"><a href="#OpenCV模块" class="headerlink" title="OpenCV模块"></a>OpenCV模块</h2><ul><li>core：简洁核心模块，基本函数，基本数据结构</li><li>imgproc：图像处理模块，线性和非线性图像滤波，几何图像转换，颜色空间转换，直方图等。</li><li>video：视频分析模块，运动估计，背景消除，物体跟踪算法</li><li>calib3d：基本多视角几何算法，单体和立体相机的标定，对象姿势估计，双目立体匹配算法和元素的三维重建</li><li>features2d：包含了显著特征检测算法，描述算子和算子匹配算法</li><li>objdetect：物体检测和一些预定义的物体的检测（如人脸，眼睛，杯子，人，汽车等)</li><li>ml：多种机器学习算法，如K均值，支持向量机和神经网络</li><li>highgui：简单易用接口，有视频捕捉，图像和视频编码功能，简单UI接口，iOS的是其中一个子集</li><li>gpu：GPU加速算法，iOS不可用</li><li>ocl：OpenCL通用算法，iOS不可用</li><li>其它辅助模块，如用户贡献的算法</li></ul><h2 id="人脸检测-1"><a href="#人脸检测-1" class="headerlink" title="人脸检测"></a>人脸检测</h2><h2 id="检测图片中的人脸"><a href="#检测图片中的人脸" class="headerlink" title="检测图片中的人脸"></a>检测图片中的人脸</h2><p>在OpenCV中，主要使用两种特征进行人脸检测，Haar特征和LBP特征，下面使用的是LBP特征。<br>实现人脸检测主要依赖于detectMultiScale()函数</p><pre><code class="line-numbers language-cpp">CV_WRAP virtual void detectMultiScale( const Mat&amp; image,  CV_OUT vector&lt;Rect&gt;&amp; objects,  double scaleFactor=1.1,  int minNeighbors=3, int flags=0,  Size minSize=Size(),  Size maxSize=Size() );</code></pre><p>各参数含义如下：<br><strong>const Mat&amp; image</strong>: 需要被检测的图像（灰度图）。<br><strong>vector<Rect>&amp; objects</strong>: 保存被检测出的人脸位置坐标序列。<br><strong>double scaleFactor</strong>: 每次图片缩放的比例。<br><strong>int minNeighbors</strong>: 每一个人脸至少要检测到多少次才算是真的人脸。<br><strong>doubleint flags</strong>： 决定是缩放分类器来检测，还是缩放图像。<br><strong>Size()</strong>: 表示人脸的最大最小尺寸。</p><p>具体实现代码如下:</p><pre><code class="line-numbers language-cpp">#include&lt;opencv2/highgui/highgui.hpp&gt;#include&lt;opencv2/imgproc/imgproc.hpp&gt;#include&lt;opencv2/objdetect/objdetect.hpp&gt;#include&lt;iostream&gt;#include&lt;opencv2/core.hpp&gt;using namespace std;using namespace cv;#define CV_COLOR_GREEN cv::Scalar(0, 255, 0)CascadeClassifier faceCascade;int main(int argc, char* argv[])&#123; Mat img; CascadeClassifier faceDetector(&quot;lbpcascade_frontalface.xml&quot;);//读取分类器 img = imread(argv[1]);  //读取检测的图片原图 vector&lt;Rect&gt; objects;  //存放检测的对象 faceDetector.detectMultiScale(img, objects);  //执行检测 for (int i = 0; i &lt; objects.size(); i++) //遍历检测到的脸 &#123;  rectangle(img, objects[i], CV_COLOR_RED);  //画出检测到的脸 &#125; imshow(&quot;result&quot;, img);  //显示结果 waitKey(0); return 0;&#125;</code></pre><p>检测结果:<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/2.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/3.png"></p><h3 id="检测视频中的人脸"><a href="#检测视频中的人脸" class="headerlink" title="检测视频中的人脸"></a>检测视频中的人脸</h3><p>原理就是对视频逐帧处理，1s大约分为30帧。</p><pre><code class="line-numbers language-cpp">#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;#define CV_COLOR_GREEN cv::Scalar(0, 255, 0)CascadeClassifier faceCascade;int main(int argc, char** argv)&#123;  //打开摄像头  VideoCapture cap(0);  if(!cap.isOpened())  &#123;    return -1;  &#125;  //读取分类器  CascadeClassifier faceDetector(&quot;lbpcascade_frontalface.xml&quot;);  vector&lt;Rect&gt; objects;  Mat frame;  Mat edges;  bool stop = false;  while(!stop)&#123;    cap &gt;&gt; frame;    if (frame.empty())      stop = true;    double scaleFactor=1.1;    int minNeighbors = 3;    //int flags = 1;    //cvtColor(frame, edges, CV_BGR2GRAY);    //GaussianBlur(edges, edges, Size(7,7), 1.5, 1.5);    faceDetector.detectMultiScale(frame, objects,scaleFactor, minNeighbors);    for(int i = 0; i &lt; objects.size(); i++)&#123;      rectangle(frame, objects[i], CV_COLOR_GREEN);      rectangle(edges, objects[i], CV_COLOR_GREEN);    &#125;    //imshow(&quot;edge&quot;, edges);    imshow(&quot;frame&quot;, frame);    if (waitKey(30) &gt;= 0)      stop = true;  &#125;  return 0;&#125;</code></pre><p>识别结果:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/4.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/5.png"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
          <category> 人脸检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Face_Detection </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Local Binary Patterns</title>
      <link href="/2019/08/01/local-binary-patterns/"/>
      <url>/2019/08/01/local-binary-patterns/</url>
      
        <content type="html"><![CDATA[<h1 id="LBP算法"><a href="#LBP算法" class="headerlink" title="LBP算法"></a>LBP算法</h1><p>LBP（Local Binary Patterns，局部二值模式）是一种能够有效地度量和提取图像局部纹理信息的算子，具有旋转不变性和灰度不变性等显著的优点。它是人脸识别中一种提取特征的重要方法，具有对光照不敏感的特性，但是对姿态和表情的鲁棒性不强。</p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>纹理是由于物体表面物理属性不同所引起的能够表示某个特定表面特征的灰度或颜色信息。纹理反映了图像灰度模式的空间分布，包含了图像的表面信息及其周围环境的关系。</p><h2 id="基本的LBP算子"><a href="#基本的LBP算子" class="headerlink" title="基本的LBP算子"></a>基本的LBP算子</h2><p>局部二值模式是一种灰度范围内的纹理描述方式。最初的LBP算子定义在一个3×3的窗口，以窗口中心像素点为阈值，将相邻的像素的灰度值与其进行比较，若周围的像素值大于中心点的值，则将该像素位置标记为1,否则为0.这样一个3×3邻域内的8个点可产生一个8-bit的无符号数，再按其位置赋予不同权重求和得一整数，即可得到该窗口的 <strong>LBP</strong> 值，并用这个数反映该区域的纹理信息。<br>对比度分量C是邻域中所有大于和等于中心点像素的均值与所有小于中心点像素的均值之差。<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779ca87257597.jpg"></p><p>基本的LBP算子最大的缺陷是只覆盖了一个固定半径范围内的小区域，改进的LBP算子，将3×3邻域扩展到任意邻域，用圆形邻域代替了正方形邻域，该算子允许在半径为R的圆形邻域内有任意多个像素点。</p><ul><li>一个局部区域的纹理分布可假设为局部区域内像素灰度的联合分布密度<br>$$T = t(g_c,g_0, ….,g_{p-1})$$<br>$g_c$表示局部区域的中心点的灰度值,$g_p(p=0,1,…,p)$对应中心点周围等距分布的P个点</li><li>采用 <strong>双线性插算法</strong> 对没有完全落在像素位置的点计算灰度值。邻域内的$g_p$点的坐标可以表示为:<br>$$(x_p,y_p) = (x_c + Rcos(\frac{2\pi}{P}),y_c - Rsin(\frac{2\pi}{P}))$$<br>$(x_c,y_c)$表示中心点的坐标</li><li>将中心点$g_c$的值从邻域像素的灰度值$g_p$中减去，则局部区域的纹理可以用中心点和中心点与周边像素值之差的联合分布来表示:<br>$$T = t(g_c,g_0-g_c,….,g_{p-1}-g_c)$$</li><li>假设中心像素点$g_c$与周边点像素$g_p$的差值$g_p-g_c(p=0,1,…P)$独立于中心点$g_c$，则<br>$$T\approx t(g_c)(g_0-g_c,…,g_{p-1}-g_c)$$</li><li>实际上，$t(g_c)$只是描述了整个图像的亮度分布情况，而和图像的局部纹理无关，它不能为纹理分析提供任何有价值的信息<br>$$T\approx t(g_0-g_c,…,g_{p-1}-g_c)$$</li><li>差值的联合分布具有灰度平移不变性，即邻域中所有P+1个像素同时加上或减去某个值，其表征的纹理不变。</li><li>为了达到尺度不变的目的，只考虑差值的符号<br>$$T\approx t(s(g_0-g_c),…,s(g_p-g_c))$$</li></ul><p>$$s(x)=\begin{cases}<br>1 , \quad &amp;x &gt; 0  \\<br>0 , &amp;x \geqslant 0<br>\end{cases}<br>$$</p><p>上式得到了一个8位的二进制数，再对像素按不同位置用$2^p$进行加权求和，这样得到了一个与邻域像素点相关的唯一的 <strong>LBP</strong> 值，这个值称为 <strong>模式</strong>。这个值描述的是以$(x_c,y_c)$为中心的局部区域的纹理，可以表示为<br>$$LBP(x_c,y_c) = \sum_{p=0}^{P-1}s(g_p - g_c)2^P$$<br>上式意味着差值的符号转化成一个P-bit的二进制数，进而转化成为一个取值范围为0-$2^p$的离散的LBP值，或者说转化为一种LBP模式。</p><ul><li>局部区域的灰度分布或纹理，可以用这个LBP值或LBP模式近似描述为:<br>$$T\approx t(LBP(x_c,y_c))$$<br>LBP算子对于任何单调的灰度变化具有鲁棒性，用符号$LBP_P^R$表示在半径为R的圆形邻域内有P个像素点$g_p(p=0,1,…,P)$的LBP算子<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779b84ac47631.jpg"></li></ul><h2 id="LBP等价模式"><a href="#LBP等价模式" class="headerlink" title="LBP等价模式"></a>LBP等价模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当某个局部二进制模式所对应的循环二进制数从０到１或从１到０最多有两次跳变时，该局部二进制模式所对应的二进制就称为一个等价模式类。比如00000000,11111111,10001111都是等价类。</p><h3 id="检验方法"><a href="#检验方法" class="headerlink" title="检验方法"></a>检验方法</h3><p>检验某种模式是否是等价模式的简单办法是将其和其移动一位后的二进制模式按位相减的绝对值求和<br>$$U(G_p) = |s(g_{p-1}-g_c)-s(g_0-g_c)|+\sum_{p=1}^{P-1}|s(g_p-g_c)-s(g_{p-1}-g_c)$$<br>若某种模式计算得到的 $U(G_p)$小于或等于２，则将其归于等价模式<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779c949196019.jpg"></p><h2 id="旋转不变的LBP算子"><a href="#旋转不变的LBP算子" class="headerlink" title="旋转不变的LBP算子"></a>旋转不变的LBP算子</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>不断旋转圆形邻域得到一系列的初始定义的LBP值，取其最小值作为该邻域的LBP值，用公式表示为:<br>$$LBP_{P,R}^{ri} = min(ROR(LBP_{P,R}^{ri},i)|i=0,1,…,P-1)$$<br>$LBP^{ri}$表示旋转不变的LBP算子，$ROR(x,i)$函数为旋转函数，表示将x循环右移i(i&lt;P)位。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>对于图像旋转，表现的更为鲁棒，并且LBP模式的种类进一步减少，使纹理识别更加容易。</li><li>丢失了方向信息<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779b8fed91298.jpg"></li></ul><h2 id="旋转不变的的等价模式"><a href="#旋转不变的的等价模式" class="headerlink" title="旋转不变的的等价模式"></a>旋转不变的的等价模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将等价模式类进行旋转得到旋转不变的等价模式</p><p>$$LBP_{P,R}^{riu2} = \begin{cases}<br>\sum_{P=0}^{P-1}s(g_p-g_c), &amp; U(G_p) \leq 2 \\<br>P + 1, &amp; U(G_p) &gt;2<br>\end{cases}<br>$$</p><p>其中$U(G_p)$表示0到1或1到0跳变的次数，$LBP^{riu2}$被称为旋转不变的等价模式</p><h2 id="几种LBP算子的维数比较"><a href="#几种LBP算子的维数比较" class="headerlink" title="几种LBP算子的维数比较"></a>几种LBP算子的维数比较</h2><table><thead><tr><th align="center">LBP</th><th align="center">原始模式数</th><th align="center">等价模式</th><th align="center">旋转不变等价模式</th></tr></thead><tbody><tr><td align="center">$LBP_P^R$</td><td align="center">$2^P$</td><td align="center">$P(P-1) + 2$</td><td align="center">$P+1$</td></tr><tr><td align="center">$LBP_8^1$</td><td align="center">256</td><td align="center">58(+1)</td><td align="center">9</td></tr><tr><td align="center">$LBP_{16}^2$</td><td align="center">65536</td><td align="center">242(+1)</td><td align="center">17</td></tr><tr><td align="center">$LBP_{24}^3$</td><td align="center">16777216</td><td align="center">554(+1)</td><td align="center">25</td></tr></tbody></table><h1 id="LBP特征实现"><a href="#LBP特征实现" class="headerlink" title="LBP特征实现"></a>LBP特征实现</h1><h2 id="原始LBP特征"><a href="#原始LBP特征" class="headerlink" title="原始LBP特征"></a>原始LBP特征</h2><pre><code class="line-numbers language-cpp">//Original_LBPMat get_original_LBP_feature(Mat img)&#123;  Mat result;  result.create(img.rows - 2, img.cols -2, img.type());  result.setTo(0);  for (int i = 1; i &lt; img.rows - 1; i++)&#123;    for (int j = 1; j &lt; img.cols -1; j++)&#123;      uchar center = img.at&lt;uchar&gt;(i, j);      uchar lbpcode = 0;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j - 1) &gt;= center) &lt;&lt; 7;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j) &gt;= center) &lt;&lt; 6;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j + 1) &gt;= center) &lt;&lt; 5;      lbpcode |= (img.at&lt;uchar&gt;(i, j -1) &gt;= center) &lt;&lt; 4;      lbpcode |= (img.at&lt;uchar&gt;(i, j + 1) &gt;= center) &lt;&lt; 3;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j - 1) &gt;= center) &lt;&lt; 2;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j) &gt;= center) &lt;&lt; 1;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j + 1) &gt;= center) &lt;&lt; 0;      result.at&lt;uchar&gt;(i - 1, j - 1) = lbpcode;    &#125;  &#125;  return result;&#125;</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/31/5d4161dac5f0b23887.png"></p><h2 id="圆形LBP特征"><a href="#圆形LBP特征" class="headerlink" title="圆形LBP特征"></a>圆形LBP特征</h2><pre><code class="line-numbers language-cpp">//Circular_LBP_featureMat get_circular_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  //循环处理每个像素  for(int i=radius;i&lt;img.rows-radius;i++)  &#123;      for(int j=radius;j&lt;img.cols-radius;j++)      &#123;          //获得中心像素点的灰度值          uchar center = img.at&lt;uchar&gt;(i,j);          uchar lbpCode = 0;          for(int k=0;k&lt;neighbors;k++)          &#123;              //根据公式计算第k个采样点的坐标，这个地方可以优化，不必每次都进行计算radius*cos，radius*sin              float x = i + static_cast&lt;float&gt;(radius * \                  cos(2.0 * CV_PI * k / neighbors));              float y = j - static_cast&lt;float&gt;(radius * \                  sin(2.0 * CV_PI * k / neighbors));                //根据取整结果进行双线性插值，得到第k个采样点的灰度值                //1.分别对x，y进行上下取整                int x1 = static_cast&lt;int&gt;(floor(x));                int x2 = static_cast&lt;int&gt;(ceil(x));                int y1 = static_cast&lt;int&gt;(floor(y));                int y2 = static_cast&lt;int&gt;(ceil(y));                //将坐标映射到0-1之间                float tx = x - x1;                float ty = y - y1;                //根据0-1之间的x，y的权重计算公式计算权重                float w1 = (1-tx) * (1-ty);                float w2 =    tx  * (1-ty);                float w3 = (1-tx) *    ty;                float w4 =    tx  *    ty;                //3.根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(x1,y1) * w1 + img.at&lt;uchar&gt;(x1,y2) *w2 + img.at&lt;uchar&gt;(x2,y1) * w3 +img.at&lt;uchar&gt;(x2,y2) *w4;                //通过比较获得LBP值，并按顺序排列起来                lbpCode |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;            result.at&lt;uchar&gt;(i-radius,j-radius) = lbpCode;        &#125;    &#125;  return result;&#125;</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/08/01/5d42b5d2e345026549.png"></p><p>第一幅图设置半径为4,第二幅图设置半径为1,可以看到半径越小处理的越精细。</p><h2 id="旋转不变LBP特征"><a href="#旋转不变LBP特征" class="headerlink" title="旋转不变LBP特征"></a>旋转不变LBP特征</h2><pre><code class="line-numbers language-cpp">//Rotation_Invariant_LBP_featureMat get_rotation_invariant_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  for(int k=0;k&lt;neighbors;k++)    &#123;        //计算采样点对于中心点坐标的偏移量rx，ry        float rx = static_cast&lt;float&gt;(radius * cos(2.0 * CV_PI * k / neighbors));        float ry = -static_cast&lt;float&gt;(radius * sin(2.0 * CV_PI * k / neighbors));        //为双线性插值做准备        //对采样点偏移量分别进行上下取整        int x1 = static_cast&lt;int&gt;(floor(rx));        int x2 = static_cast&lt;int&gt;(ceil(rx));        int y1 = static_cast&lt;int&gt;(floor(ry));        int y2 = static_cast&lt;int&gt;(ceil(ry));        //将坐标偏移量映射到0-1之间        float tx = rx - x1;        float ty = ry - y1;        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关        float w1 = (1-tx) * (1-ty);        float w2 =    tx  * (1-ty);        float w3 = (1-tx) *    ty;        float w4 =    tx  *    ty;        //循环处理每个像素        for(int i=radius;i&lt;img.rows-radius;i++)        &#123;            for(int j=radius;j&lt;img.cols-radius;j++)            &#123;                //获得中心像素点的灰度值                uchar center = img.at&lt;uchar&gt;(i,j);                //根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(i+x1,j+y1) * w1 + img.at&lt;uchar&gt;(i+x1,j+y2) *w2 + img.at&lt;uchar&gt;(i+x2,j+y1) * w3 +img.at&lt;uchar&gt;(i+x2,j+y2) *w4;                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得                result.at&lt;uchar&gt;(i-radius,j-radius) |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;        &#125;    &#125;    //进行旋转不变处理    for(int i=0;i&lt;result.rows;i++)    &#123;        for(int j=0;j&lt;result.cols;j++)        &#123;            uchar currentValue = result.at&lt;uchar&gt;(i,j);            uchar minValue = currentValue;            for(int k=1;k&lt;neighbors;k++)        //循环左移            &#123;                uchar temp = (currentValue&gt;&gt;(neighbors-k)) | (currentValue&lt;&lt;k);                if(temp &lt; minValue)                &#123;                    minValue = temp;                &#125;            &#125;            result.at&lt;uchar&gt;(i,j) = minValue;        &#125;    &#125;    return result;&#125;</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/08/01/5d42b5d30749958722.png"></p><p>第一幅图neighbors值设置为8,第二幅设置为6,可以看出neighbors值越大，得到的LBP特征亮度越高。</p><h2 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h2><pre><code class="line-numbers language-cpp">#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;//Original_LBPMat get_original_LBP_feature(Mat img)&#123;  Mat result;  result.create(img.rows - 2, img.cols -2, img.type());  result.setTo(0);  for (int i = 1; i &lt; img.rows - 1; i++)&#123;    for (int j = 1; j &lt; img.cols -1; j++)&#123;      uchar center = img.at&lt;uchar&gt;(i, j);      uchar lbpcode = 0;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j - 1) &gt;= center) &lt;&lt; 7;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j) &gt;= center) &lt;&lt; 6;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j + 1) &gt;= center) &lt;&lt; 5;      lbpcode |= (img.at&lt;uchar&gt;(i, j -1) &gt;= center) &lt;&lt; 4;      lbpcode |= (img.at&lt;uchar&gt;(i, j + 1) &gt;= center) &lt;&lt; 3;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j - 1) &gt;= center) &lt;&lt; 2;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j) &gt;= center) &lt;&lt; 1;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j + 1) &gt;= center) &lt;&lt; 0;      result.at&lt;uchar&gt;(i - 1, j - 1) = lbpcode;    &#125;  &#125;  return result;&#125;//Circular_LBP_featureMat get_circular_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  //循环处理每个像素  for(int i=radius;i&lt;img.rows-radius;i++)  &#123;      for(int j=radius;j&lt;img.cols-radius;j++)      &#123;          //获得中心像素点的灰度值          uchar center = img.at&lt;uchar&gt;(i,j);          uchar lbpCode = 0;          for(int k=0;k&lt;neighbors;k++)          &#123;              //根据公式计算第k个采样点的坐标，这个地方可以优化，不必每次都进行计算radius*cos，radius*sin              float x = i + static_cast&lt;float&gt;(radius * \                  cos(2.0 * CV_PI * k / neighbors));              float y = j - static_cast&lt;float&gt;(radius * \                  sin(2.0 * CV_PI * k / neighbors));                //根据取整结果进行双线性插值，得到第k个采样点的灰度值                //1.分别对x，y进行上下取整                int x1 = static_cast&lt;int&gt;(floor(x));                int x2 = static_cast&lt;int&gt;(ceil(x));                int y1 = static_cast&lt;int&gt;(floor(y));                int y2 = static_cast&lt;int&gt;(ceil(y));                //将坐标映射到0-1之间                float tx = x - x1;                float ty = y - y1;                //根据0-1之间的x，y的权重计算公式计算权重                float w1 = (1-tx) * (1-ty);                float w2 =    tx  * (1-ty);                float w3 = (1-tx) *    ty;                float w4 =    tx  *    ty;                //3.根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(x1,y1) * w1 + img.at&lt;uchar&gt;(x1,y2) *w2 + img.at&lt;uchar&gt;(x2,y1) * w3 +img.at&lt;uchar&gt;(x2,y2) *w4;                //通过比较获得LBP值，并按顺序排列起来                lbpCode |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;            result.at&lt;uchar&gt;(i-radius,j-radius) = lbpCode;        &#125;    &#125;  return result;&#125;//Rotation_Invariant_LBP_featureMat get_rotation_invariant_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  for(int k=0;k&lt;neighbors;k++)    &#123;        //计算采样点对于中心点坐标的偏移量rx，ry        float rx = static_cast&lt;float&gt;(radius * cos(2.0 * CV_PI * k / neighbors));        float ry = -static_cast&lt;float&gt;(radius * sin(2.0 * CV_PI * k / neighbors));        //为双线性插值做准备        //对采样点偏移量分别进行上下取整        int x1 = static_cast&lt;int&gt;(floor(rx));        int x2 = static_cast&lt;int&gt;(ceil(rx));        int y1 = static_cast&lt;int&gt;(floor(ry));        int y2 = static_cast&lt;int&gt;(ceil(ry));        //将坐标偏移量映射到0-1之间        float tx = rx - x1;        float ty = ry - y1;        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关        float w1 = (1-tx) * (1-ty);        float w2 =    tx  * (1-ty);        float w3 = (1-tx) *    ty;        float w4 =    tx  *    ty;        //循环处理每个像素        for(int i=radius;i&lt;img.rows-radius;i++)        &#123;            for(int j=radius;j&lt;img.cols-radius;j++)            &#123;                //获得中心像素点的灰度值                uchar center = img.at&lt;uchar&gt;(i,j);                //根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(i+x1,j+y1) * w1 + img.at&lt;uchar&gt;(i+x1,j+y2) *w2 + img.at&lt;uchar&gt;(i+x2,j+y1) * w3 +img.at&lt;uchar&gt;(i+x2,j+y2) *w4;                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得                result.at&lt;uchar&gt;(i-radius,j-radius) |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;        &#125;    &#125;    //进行旋转不变处理    for(int i=0;i&lt;result.rows;i++)    &#123;        for(int j=0;j&lt;result.cols;j++)        &#123;            uchar currentValue = result.at&lt;uchar&gt;(i,j);            uchar minValue = currentValue;            for(int k=1;k&lt;neighbors;k++)        //循环左移            &#123;                uchar temp = (currentValue&gt;&gt;(neighbors-k)) | (currentValue&lt;&lt;k);                if(temp &lt; minValue)                &#123;                    minValue = temp;                &#125;            &#125;            result.at&lt;uchar&gt;(i,j) = minValue;        &#125;    &#125;    return result;&#125;int main(int argc, char* argv[])&#123;  Mat src = imread(argv[1], 0);  Mat dst = get_original_LBP_feature(src);  Mat odst1 = get_circular_LBP_feature(src, 1, 8);  //Mat odst4 = get_circular_LBP_feature(src, 4, 8);  Mat rif8 = get_rotation_invariant_LBP_feature(src, 1, 8);  Mat rif6 = get_rotation_invariant_LBP_feature(src, 1, 6);  imshow(&quot;原始图片&quot;, src);  imshow(&quot;原始LBP&quot;, dst);  imshow(&quot;圆形LBP&quot;, odst1);  //imshow(&quot;圆形LBP4&quot;, odst4);  imshow(&quot;旋转不变LBP&quot;, rif8);  //imshow(&quot;旋转不变LBP6&quot;, rif6);  waitKey(0);  return 0;&#125;</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> c++ </tag>
            
            <tag> LBP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>High-quality-ellipse-detection</title>
      <link href="/2019/07/29/high-quality-ellipse-detection/"/>
      <url>/2019/07/29/high-quality-ellipse-detection/</url>
      
        <content type="html"><![CDATA[<h1 id="High-quality-ellipse-detection"><a href="#High-quality-ellipse-detection" class="headerlink" title="High-quality-ellipse-detection"></a>High-quality-ellipse-detection</h1><p>个人环境:Matlab 2019a、VS2017、Opencv3.4.4，64位Windows操作系统</p><h2 id="OpenCV环境配置请看这篇"><a href="#OpenCV环境配置请看这篇" class="headerlink" title="OpenCV环境配置请看这篇"></a>OpenCV环境配置请看这篇</h2><p><a href="https://godliuyang.wang/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/">OpenCV入坑指南:环境搭建篇</a></p><h2 id="MatLab和C-混合编程环境配置"><a href="#MatLab和C-混合编程环境配置" class="headerlink" title="MatLab和C++混合编程环境配置"></a>MatLab和C++混合编程环境配置</h2><p>Matlab的安装这里不再说    </p><ol><li>在命令行里输入 <code>mex -setup</code>，选择vs就行了</li><li>执行 <code>mex -setup C++</code>完成配置<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/2.png"></li></ol><h2 id="下载Github文件"><a href="#下载Github文件" class="headerlink" title="下载Github文件"></a>下载Github文件</h2><p>download Zip即可</p><h2 id="导入依赖文件"><a href="#导入依赖文件" class="headerlink" title="导入依赖文件"></a>导入依赖文件</h2><p>将 <strong>D:\OpenCV\opencv\build\x64\vc15\lib</strong>下的 <strong>opencv_world344.lib</strong>文件复制到你的Matlab安装路径下的 <strong>microsoft</strong>文件夹下,我的是 <strong>D:\MATLAB\R2019a\extern\lib\win64\microsoft</strong></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/3.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/4.png"></p><h2 id="在Matlab中导入文件"><a href="#在Matlab中导入文件" class="headerlink" title="在Matlab中导入文件"></a>在Matlab中导入文件</h2><h2 id="在命令行执行以下命令"><a href="#在命令行执行以下命令" class="headerlink" title="在命令行执行以下命令"></a>在命令行执行以下命令</h2><p>注意作者的命令为:</p><pre><code class="line-numbers language-matlab">mex generateEllipseCandidates.cpp -IF:\OpenCV\opencv2.4.9\build\include -IF:\OpenCV\opencv2.4.9\build\include\opencv -IF:\OpenCV\opencv2.4.9\build\include\opencv2 -LF:\OpenCV\opencv2.4.9\build\x64\vc11\lib -IF:\Matlab\settlein\extern\include -LF:\Matlab\settlein\extern\lib\win64\microsoft -lopencv_core249 -lopencv_highgui249 -lopencv_imgproc249 -llibmwlapack.lib</code></pre><p>把OpenCV和Matlab的相关文件的路径改成你的安装路径<br>我这里版本号为OpenCV3.4.4,安装路径如下,<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/5.png"><br>故修改为<code>D:\OpenCV\opencv\build...</code>,<br>由于OpenCV3.4.4只有 <strong>opencv_world344.lib</strong> 这一个lib文件，故将 <code>LF:\Matlab\settlein\extern\lib\win64\microsoft -lopencv_core249 -lopencv_highgui249 -lopencv_imgproc249 -llibmwlapack.lib</code>　修改为 <code>LD:\Matlab\R2019a\extern\lib\win64\microsoft -lopencv_world344 -llibmwlapack.lib</code></p><p>完整的命令为:</p><pre><code class="line-numbers language-matlab">mex generateEllipseCandidates.cpp -ID:\OpenCV\opencv\build\include -ID:\OpenCV\opencv\build\include\opencv -ID:\OpenCV\opencv\build\include\opencv2 -LD:\OpenCV\opencv\build\x64\vc15\lib -ID:\Matlab\R2019a\include -LD:\Matlab\R2019a\extern\lib\win64\microsoft -lopencv_world344 -llibmwlapack.lib</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/6.png"><br>编译成功之后生成<code>generateEllipseCandidates.mexw64</code>文件<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/7.png"><br>之后再运行<code>LCS_ellipse.m</code><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/8.png"></p><p>##　报错解决办法</p><ol><li>如图<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/9.png"><br>在.cpp文件中添加</li></ol><pre><code class="line-numbers language-cpp">using namespace std</code></pre><ol start="2"><li>如图</li></ol><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/10.png"><br>缺少lib文件，检查一下是不是配置出错了</p><p>参考文献:</p><ol><li><a href="https://github.com/AlanLuSun/High-quality-ellipse-detection">Arc-support Line Segments Revisited: An Efficient and High-quality Ellipse Detection</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ellipse function</title>
      <link href="/2019/07/28/ellipse-function/"/>
      <url>/2019/07/28/ellipse-function/</url>
      
        <content type="html"><![CDATA[<h1 id="High-quality-ellipse-detection"><a href="#High-quality-ellipse-detection" class="headerlink" title="High-quality-ellipse-detection"></a>High-quality-ellipse-detection</h1><p>高精度椭圆检测<br>参考<a href="https://github.com/AlanLuSun/High-quality-ellipse-detection">High-quality-ellipse-detection</a></p><p>关于椭圆检测的部分，实在是看不懂，我只做了得到椭圆参数绘制椭圆的部分</p><h2 id="OpenCV椭圆绘制"><a href="#OpenCV椭圆绘制" class="headerlink" title="OpenCV椭圆绘制"></a>OpenCV椭圆绘制</h2><h3 id="ellipse函数"><a href="#ellipse函数" class="headerlink" title="ellipse函数"></a>ellipse函数</h3><p>语法</p><pre><code>void cvEllipse( CvArr* img, CvPoint center, CvSize axes, double angle,                double start_angle, double end_angle, CvScalar color,                int thickness=1, int line_type=8, int shift=0 );</code></pre><p>参数:<br>img:图像。<br>center:椭圆圆心坐标。<br>axes:轴的长度。<br>angle:偏转的角度。<br>start_angle:圆弧起始角的角度。<br>end_angle:圆弧终结角的角度。<br>color:线条的颜色。<br>thickness:线条的粗细程度。<br>line_type:线条的类型,见CVLINE的描述。<br>shift:圆心坐标点和数轴的精度。    </p><p>C++代码实现</p><pre><code class="line-numbers language-cpp">#include&lt;opencv2/opencv.hpp&gt;#include&lt;opencv2/core/core.hpp&gt; // 核心组件#include&lt;opencv2/highgui/highgui.hpp&gt;  // GUI#include&lt;opencv2/imgproc/imgproc.hpp&gt;  // 图像处理using namespace cv;using namespace std;// 定义存储椭圆参数的数据结构struct Ellipse &#123;    int x0, y0, a, b;    double alpha;&#125;;int drawEllipse(Ellipse ellipses_para, Mat im);int drawEllipse(Ellipse ellipses_para, Mat im) &#123;// Draw Ellipse after detection//x0 - x coordinate of the center of the ellipse//y0 - y coordinate of the center of the ellipse//a - length of semimajor axis//b - length of semiminor axis//alpha - angle of orientation of semimajor axis    if (im.empty()) &#123;        printf(&quot;imread error!&quot;);        return -1;    &#125;    int x0, y0, a, b;    double alpha;    int thickness = 3;    int lineType = 8;    x0 = ellipses_para.x0;    y0 = ellipses_para.y0;    a = ellipses_para.a;    b = ellipses_para.b;    alpha = ellipses_para.alpha;    ellipse(im, Point(x0, y0), Size(a, b), alpha, 0, 360, Scalar(255, 255, 0), thickness, lineType);    imshow(&quot;原图&quot;, im);    waitKey();&#125;int main() &#123;    Ellipse ellipses_para;    Mat im = imread(&quot;11.bmp&quot;);    /*test        ellipses_para.x0 = 100;    ellipses_para.y0 = 100;    ellipses_para.a = 90;    ellipses_para.b = 60;    ellipses_para.alpha = 80.0;*/    drawEllipse(ellipses_para, im);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆形检测</title>
      <link href="/2019/07/26/yuan-xing-jian-ce/"/>
      <url>/2019/07/26/yuan-xing-jian-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="基于霍夫变换的圆形检测"><a href="#基于霍夫变换的圆形检测" class="headerlink" title="基于霍夫变换的圆形检测"></a>基于霍夫变换的圆形检测</h1><h2 id="霍夫变换的原理"><a href="#霍夫变换的原理" class="headerlink" title="霍夫变换的原理"></a>霍夫变换的原理</h2><p>Hough 变换就是利用图像全局特征将边缘像素连接起来组成区域封闭边界，它将图像空间转换到参数空间，在参数空间对点进行描述，达到检测图像边缘的目的。该方法把所有可能落在边缘上的点进行统计计算，根据对数据的统计结果确定属于边缘的程度。Hough 变换的实质就是对图像进行坐标变换，把平面坐标变换为参数坐标，使变换的结果更易识别和检测。<br>具体原理: <a href="https://godliuyang.wang/2019/07/26/huo-fu-bian-huan/">霍夫变换</a></p><hr><h3 id="对霍夫变换圆形检测的原理的理解"><a href="#对霍夫变换圆形检测的原理的理解" class="headerlink" title="对霍夫变换圆形检测的原理的理解:"></a>对霍夫变换圆形检测的原理的理解:</h3><p>已知圆的一般方程为:<br>$$(x-a)^2 + (y-b)^2 = r^2 $$<br>其中(a,b)代表圆心，r是圆的半径<br>依旧是把图像空间转换成参数空间，这里是将X-Y平面转化成a-b-r参数空间，则在图像空间中的一个过(x,y)点的圆，对应参数空间中高度变化的三维锥面。<br><img loading="lazy" src="https://i.loli.net/2019/07/26/5d3ab8c50fc2a28962.jpg"><br>同理，过图像空间的任意一点的圆都对应于参数空间的一个三维锥面，因此，过图像空间上同一圆的点，对应的参数空间中的三维锥面，在r平面必然相交于一点(a,b,r)，这样通过这一点就可以得到一个圆的参数。<br><img loading="lazy" src="https://i.loli.net/2019/07/26/5d3ab8c4d635d79647.jpg"><br>这里霍夫变换的圆检测就是在这三个参数组成的三维空间内进行的<br>换一种理解思路:在笛卡尔坐标下的圆的方程已给出，在极坐标系下，假设圆心为$(x_0,y_0)$,圆上的点可以表示为:<br>$$x = x_0 + rcos\theta, y = y_0 + rsin\theta$$<br>对于一个圆，假如中心像素点$(x_0,y_0)$，半径r已知，那么旋转360°，圆上的所有点就可以求得。同样，假如圆上的所有点，半径r已知，旋转360°，则会得到一个累加的极值点，那么这个点就是圆心了。</p><hr><p>理论上霍夫变换可以检测任何形状，但复杂的形状需要的参数就多，霍夫空间的维数就多，因此在程序实现上所需的内存空间以及运行效率上都不利于把标准霍夫变换应用于实际复杂图形的检测中。所以一些改进的霍夫变换就相继提出，它们的基本原理就是尽可能减小霍夫空间的维数。</p><p>在OpenCV中，HoughCircles函数实现了圆形检测，它使用的算法也是改进的霍夫变换——2-1霍夫变换（21HT）。也就是把霍夫变换分为两个阶段，从而减小了霍夫空间的维数。第一阶段用于检测圆心，第二阶段从圆心推导出圆半径。<br>检测圆心的原理是圆心是它所在圆周所有法线的交汇处，因此只要找到这个交点，即可确定圆心，该方法所用的霍夫空间与图像空间的性质相同，因此它仅仅是二维空间。检测圆半径的方法是从圆心到圆周上的任意一点的距离（即半径）是相同，只要确定一个阈值，只要相同距离的数量大于该阈值，我们就认为该距离就是该圆心所对应的圆半径，该方法只需要计算半径直方图，不使用霍夫空间。圆和半径知道了，圆自然就能求得。</p><p>21HT的具体步骤:<br>第一阶段：检测圆心</p><p>1.1、对输入图像边缘检测；</p><p>1.2、计算图形的梯度，并确定圆周线，其中圆周的梯度就是它的法线；</p><p>1.3、在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心；</p><p>1.4、在霍夫空间的4邻域内进行非最大值抑制；</p><p>1.5、设定一个阈值，霍夫空间内累加和大于该阈值的点就对应于圆心。</p><p>第二阶段：检测圆半径</p><p>2.1、计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量；</p><p>2.2、设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小；</p><p>2.3、对保留下来的距离进行排序；</p><p>2.4、找到距离相同的那些值，并计算相同值的数量；</p><p>2.5、设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径；</p><p>2.6、对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径。</p><p>HoughCircles函数的原型为：<br><code>void HoughCircles (InputArray image,OutputArray circles, int method, double dp, double minDist,double param1=100, double param2=100, int minRadius=0,int maxRadius=0 )</code><br>image为输入图像，要求是灰度图像<br>circles为输出圆向量，每个向量包括三个浮点型的元素——圆心横坐标，圆心纵坐标和圆半径<br>method为使用霍夫变换圆检测的算法，Opencv2.4.9只实现了2-1霍夫变换，它的参数是CV_HOUGH_GRADIENT<br>dp为第一阶段所使用的霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2时霍夫空间是输入图像空间的一半，以此类推<br>minDist为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认为它们是同一个圆心<br>param1为边缘检测时使用Canny算子的高阈值<br>param2为步骤1.5和步骤2.5中所共有的阈值<br>minRadius和maxRadius为所检测到的圆半径的最小值和最大值</p><h3 id="霍夫变换椭圆检测的实现"><a href="#霍夫变换椭圆检测的实现" class="headerlink" title="霍夫变换椭圆检测的实现"></a>霍夫变换椭圆检测的实现</h3><p>运行环境: vs2017 + Opencv3.4<br>由于HoughCircles函数是调用Canny函数进行边缘检测，OpenCV的Canny函数不包括平滑滤波，所以先对原图进行滤波处理，在这里使用的是高斯模糊</p><pre><code class="line-numbers language-cpp">#include &quot;opencv2/core/core.hpp&quot;#include &quot;opencv2/highgui/highgui.hpp&quot;#include &quot;opencv2/imgproc/imgproc.hpp&quot;#include &lt;iostream&gt;using namespace cv;using namespace std;int main( int argc, char** argv )&#123;     Mat src, gray;    src=imread(&quot;coins.jpg&quot;);    if( !src.data )          return -1;      cvtColor( src, gray, CV_BGR2GRAY );    //高斯模糊平滑    GaussianBlur( gray, gray, Size(9, 9), 2, 2 );    vector&lt;Vec3f&gt; circles;    //霍夫变换    HoughCircles( gray, circles, CV_HOUGH_GRADIENT, 1, gray.rows/20, 100, 60, 0, 0 );    //在原图中画出圆心和圆    for( size_t i = 0; i &lt; circles.size(); i++ )    &#123;        //提取出圆心坐标        Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));        //提取出圆半径        int radius = cvRound(circles[i][2]);        //圆心        circle( src, center, 3, Scalar(0,255,0), -1, 8, 0 );        //圆        circle( src, center, radius, Scalar(0,0,255), 3, 8, 0 );   &#125;    imshow( &quot;霍夫变换检测圆图&quot;, src );    waitKey(0);    return 0;&#125;</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/26/5d3abf54a4c3b88169.jpg"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>霍夫变换</title>
      <link href="/2019/07/26/huo-fu-bian-huan/"/>
      <url>/2019/07/26/huo-fu-bian-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h1><h2 id="介绍与应用场景"><a href="#介绍与应用场景" class="headerlink" title="介绍与应用场景"></a>介绍与应用场景</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2">霍夫变换</a>(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。霍夫变换运用两个坐标空间之间的变换将在一个空间中具有相同形状的曲线或直线映射到另一个坐标空间的一个点上形成峰值，从而把检测任意形状的问题转化为统计峰值问题。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>考虑点$(x_i,y_i)$及通过这个点的线,有无穷多的线通过点$(x_i,y_i)$，针对a和b的一些值，满足斜截式$y_i = ax_i + b$的所有线都通过该点。该公式也可以写为$b = -ax_i + y_i$，考虑ab平面(即<strong>参数空间</strong>)对固定点$(x_i,y_i)$得到一条线的方程。另外，第二个点$(x_j,y_j)$也有一条在参数空间中与之相关的线，这条线和与$(x_i,y_i)$<strong>相关</strong>的线交于点$(a’,b’)$，其中$a’$是斜率，$b’$是在<strong>xy平面</strong>上包含点$(x_i,y_i)$和$(x_j,y_j)$的线的截距。在<strong>参数空间</strong>中，这条线包含的所有点都有相交于$(a’,b’)$点的直线。<br>简单理解，直线由两个点$A(x_1,y_1)$和$B(x_2,y_2)$定义，在参数空间中，两条直线的唯一公共点是在原图像空间中表示连接点A和B的唯一存在的直线<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d38129f0e9f156720.jpg"><br>因此，给定很多点，判断这些点是否共线的问题，经由霍夫变换之后，变成判断一堆曲线(每一个点在$(r, \theta)$平面上代表一条曲线)是否 在 $(r,\theta)$平面上相交于同一点的问题<br>另外用法线表示法:<br>$$xcos\theta + ysin\theta = \rho$$<br>水平线的$\theta$=0,$\rho$等于正的x的截距，垂直线的$\theta=90$度，$\rho$等于正的y的截距<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d382004e2bab23873.jpg"></p><p>在坐标(i, j)的单元位置，累加器的值是 A(i, j)，对应于参数空间坐标$(\rho_i,\theta_j)$的正方形。最初， 这些单元位置为零。然后，对于每个图像平面上的非背景点$(x_k,y_k)$(就是 xy 平面)，我们令 θ 等 于在 θ 轴上允许的细分值，并通过公式$\rho = x_kcos\theta+y_ksin\theta$解出相应的 ρ 值。然后，得到的 ρ 值四 舍五入为最接近的 ρ 轴上允许的单元值。相应的累加器单元增加一个增量。在这个过程的最后， 累加单元 A(i, j)中的值 Q 就意味着 xy 平面上位于线$xcos\theta_j+ysin\theta_j = \rho_i$上的点有 Q 个。在$\rho\theta$平面上，细分的数目决定了这些点的共线的精确度。累加器数组在工具箱中叫做霍夫变换矩阵，简称霍夫变换。</p><h2 id="MATLAB工具箱函数"><a href="#MATLAB工具箱函数" class="headerlink" title="MATLAB工具箱函数"></a>MATLAB工具箱函数</h2><h3 id="hough函数"><a href="#hough函数" class="headerlink" title="hough函数"></a>hough函数</h3><p>默认语法</p><pre><code class="line-numbers language-matlab">[H, theta, rho] = hough(f)</code></pre><p>H是霍夫变换矩阵，theta和rho是$\theta$和$\rho$的值<br>下面这个例子可以加深对霍夫变换的理解</p><pre><code class="line-numbers language-matlab">f = zeros(101,101);f(1,1) = 1;f(101,1) = 1;f(1,101) = 1;f(101, 101) = 1;f(51, 51) = 1;% H = hough(f);[H, theta, rho] = hough(f);imshow(H, [],&#39;XData&#39;, theta,&#39;YData&#39;, rho, &#39;InitialMagnification&#39;, &#39;fit&#39;)axis on, axis normalxlabel(&#39;\theta&#39;),ylabel(&#39;\rho&#39;)</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d381e6cd3ce994397.jpg"><br>观察图可以看打到三条曲线在+45度和-45度处的交点指出:f中有两组三个共线的点。两条曲线在$(\rho,\theta)$ = (0,-90)、(-100,-90)、(0,0)、(100,0)处的交点指出:有4组位于<strong>垂直线</strong>和<strong>水平线</strong>上的公共点</p><h3 id="houghpeaks函数"><a href="#houghpeaks函数" class="headerlink" title="houghpeaks函数"></a>houghpeaks函数</h3><p>寻找指定的峰值数<br>默认语法</p><pre><code class="line-numbers language-matlab">peaks = houghpeaks(H, NumPeaks)</code></pre><p>H是霍夫变换矩阵</p><h3 id="houghlines函数"><a href="#houghlines函数" class="headerlink" title="houghlines函数"></a>houghlines函数</h3><p>决定线的起点和终点<br>默认语法</p><pre><code class="line-numbers language-matlab">lines = houghlines(f, theta, rho, peaks)</code></pre><p>输出lines是结构数组，长度等于找到的线段。结构中的每个元素可以看成一条线，并含有下列字段:    </p><ol><li>point1:两元素向量[r1,c1]，指定了线段终点的行列坐标。</li><li>point2:两元素向量[r2,c2]，指定了线段其他终点的行列坐标。</li><li>theta:与线相关的霍夫变换的以度计量的角度。</li><li>rho:与线相关的霍夫变换的$\rho$轴位置。</li></ol><h3 id="MATLAB使用霍夫变换检测和连接线"><a href="#MATLAB使用霍夫变换检测和连接线" class="headerlink" title="MATLAB使用霍夫变换检测和连接线"></a>MATLAB使用霍夫变换检测和连接线</h3><pre><code class="line-numbers language-matlab">f = imread(&#39;timg1.jpg&#39;);f = rgb2gray(f);BW = edge(f,&#39;canny&#39;);[H ,theta, rho] = hough(BW, &#39;ThetaResolution&#39;, 0.2);imshow(H, [],&#39;XData&#39;, theta,&#39;YData&#39;, rho, &#39;InitialMagnification&#39;, &#39;fit&#39;)axis on, axis normalxlabel(&#39;\theta&#39;),ylabel(&#39;\rho&#39;)peaks = houghpeaks(H, 5);hold onplot(theta(peaks( :, 2)), rho(peaks(:, 1)),...    &#39;linestyle&#39;, &#39;none&#39;, &#39;marker&#39;, &#39;s&#39;, &#39;color&#39;, &#39;w&#39;);lines = houghlines(f, theta, rho, peaks);figure, imshow(f), hold onfor k = 1:length(lines)    xy = [lines(k).point1 ; lines(k).point2];    plot(xy(:,1), xy(:,2), &#39;LineWidth&#39;, 4, &#39;color&#39;, &#39;red&#39;);end</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d381d8d80bff63571.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d381de2778c421022.jpg"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV入坑指南:环境搭建篇</title>
      <link href="/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/"/>
      <url>/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h2 id="什么是OpenCV"><a href="#什么是OpenCV" class="headerlink" title="什么是OpenCV"></a>什么是OpenCV</h2><p><a href="https://opencv.org/about/">OpenCv</a>是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。<br>OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。该库也有大量的Python、Java and MATLAB/OCTAVE（版本2.5）的接口。这些语言的API接口函数可以通过在线文档获得。如今也提供对于C#、Ch、Ruby,GO的支持。</p><h2 id="OpenCV可以来做什么"><a href="#OpenCV可以来做什么" class="headerlink" title="OpenCV可以来做什么"></a>OpenCV可以来做什么</h2><p>使用OpenCV，你几乎可以做任何你能够想到的计算机视觉任务。    </p><ol><li><p>内置数据结构和输入/输出(In-build data structures and input/output)</p></li><li><p>图像处理操作(Image processing operations)</p></li><li><p>构建图形用户界面(Build GUI)</p></li><li><p>视频分析(Video analysis)</p></li><li><p>3D重建(3D reconstruction)</p></li><li><p>特征提取(Feature extraction)</p></li><li><p>目标检测(Object detection)</p></li><li><p>机器学习(Machine learning)</p></li><li><p>计算摄影(Computational photography)</p></li><li><p>形状分析(Shape analysis)</p></li><li><p>光流算法(Optical flow algorithms)</p></li><li><p>人脸和目标识别(Face and object recognition)</p></li><li><p>表面匹配(Surface matching)</p></li><li><p>文本检测和识别(Text detection and recognition)</p></li></ol><hr><h1 id="Microsoft-Visual-Studio"><a href="#Microsoft-Visual-Studio" class="headerlink" title="Microsoft Visual Studio"></a>Microsoft Visual Studio</h1><p>宇宙最强IDE(逃),不多说了</p><hr><h1 id="OpenCV-VS学习-装×-环境搭建"><a href="#OpenCV-VS学习-装×-环境搭建" class="headerlink" title="OpenCV + VS学习(装×)环境搭建"></a>OpenCV + VS学习(装×)环境搭建</h1><p>工欲善其事，必先利其器。当你准备好入坑OpenCV时，你首先要把学习环境搭建起来，光是这一关不知道劝退了多少人，我在搭建的过程中也是踩了很多坑，也遇到了各种各样刁钻的问题，现在总结一下，给自己踩过的雷做一下记录，也希望能够帮到即将入坑的你们。</p><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>为什么把这个放到第一个呢？因为这是我遇到并纠结了一天的问题！我在网上查找教程的时候很多人都没有标注这个问题，当然也是自己蠢，在所有的配置都配置完成之后，还是不能正常跑程序，又重新安装重新配置，反复好几次，都快怀疑人生了，最后才发现是版本号不对。废话不多说，下面是OpenCV版本和VS版本的对应表，选择的时候一定要擦亮眼睛。我选择的环境是VS2017+OpenCV3.4.4    </p><table><thead><tr><th align="center">Visual Studio 版本</th><th align="center">VC 版本</th></tr></thead><tbody><tr><td align="center">VS 6</td><td align="center">vc6</td></tr><tr><td align="center">VS 2003</td><td align="center">vc7</td></tr><tr><td align="center">VS 2005</td><td align="center">vc8</td></tr><tr><td align="center">VS 2008</td><td align="center">vc9</td></tr><tr><td align="center">VS 2010</td><td align="center">vc10</td></tr><tr><td align="center">VS 2013</td><td align="center">vc12</td></tr><tr><td align="center">VS 2015</td><td align="center">vc14</td></tr><tr><td align="center">VS 2017</td><td align="center">vc15</td></tr></tbody></table><p>OpenCV对VC版本的支持情况(不全)</p><table><thead><tr><th align="center">OpenCV 2.4.10</th><th align="center">vc10、vc11、vc12</th></tr></thead><tbody><tr><td align="center">OpenCV 2.4.13</td><td align="center">vc11、vc12</td></tr><tr><td align="center">OpenCV 3.4.0</td><td align="center">vc14、vc15</td></tr><tr><td align="center">OpenCv 3.4.1</td><td align="center">vc14、vc15</td></tr></tbody></table><h2 id="VS2017安装"><a href="#VS2017安装" class="headerlink" title="VS2017安装"></a>VS2017安装</h2><p>我的VS安装的时间太久了，网上教程一大堆，给你们挑一篇吧，这里就不再多说了</p><h2 id="OpenCV3-4-4下载与安装"><a href="#OpenCV3-4-4下载与安装" class="headerlink" title="OpenCV3.4.4下载与安装"></a>OpenCV3.4.4下载与安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li>官网下载<br>OpenCV官网给我们提供了下载，不过下载速度嘛～自求多福<br><a href="https://opencv.org/releases/">OpenCV下载</a>,里面有各个版本可以选择</li><li>OpenCV下载驿站<br><a href="https://blog.csdn.net/oMoDao1/article/details/80276834">OpenCV各版本汇总下载</a><br>感谢这位大哥的总结</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>找一个你能记住名字的路径安装进去就OK了，一定要记住这个路径，非常重要<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0f7a6db16095.png"></p><h2 id="系统环境变量配置"><a href="#系统环境变量配置" class="headerlink" title="系统环境变量配置"></a>系统环境变量配置</h2><ol><li>找到此电脑</li><li>依次找到 属性-&gt;高级-&gt;环境变量,找到系统变量里的Path，双击进去编辑，如图所示，添加的路径 <strong>“D:\OpenCV\opencv\bulid\x64\vc15\bin”</strong>,把”D:\OpenCV&quot;替换成你的安装路径即可</li></ol><p><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0f9cd5286868.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0fa09f948672.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0fa634780591.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0fa37ce25025.png"></p><p>到这就完成了系统环境的配置了</p><h2 id="一些文件的配置"><a href="#一些文件的配置" class="headerlink" title="一些文件的配置"></a>一些文件的配置</h2><p>这一步的目的是为了解决以后可能会出现的关于缺少.dll的问题</p><p>将 <strong>“D:\OpenCV\opencv\bulid\x64\vc15\bin”</strong> 里面的三个 <strong>.dll</strong> 文件复制到 <strong>C:\Windows“</strong> 目录下的 <strong>System32</strong>和 <strong>SysWOW64</strong>目录下</p><p><img loading="lazy" src="https://i.loli.net/2019/07/28/5d3d5857adbe920715.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/28/5d3d5857bd82f79652.png"></p><h2 id="VS2017配置"><a href="#VS2017配置" class="headerlink" title="VS2017配置"></a>VS2017配置</h2><ol><li>新建一个空项目</li><li>进入属性管理器  视图-&gt;其他窗口-&gt;属性管理器<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f6359d16629.png"></li><li>选择Debug | x64 的 Microsoft.Cpp.x64.user<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156ecb8ad31557.png" alt="8.png"></li><li>选择VC++目录，对包含目录和库目录进行配置<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f2e22b74192.png"><ul><li>在包含目录里添加 <strong>D:\OpenCV\opencv\bulid\include</strong>,<strong>D:\OpenCV\opencv\bulid\include\opencv</strong>,<strong>D:\OpenCV\opencv\bulid\include\opencv2</strong><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f2132f35424.png"></li><li>在库目录里添加 <strong>D:\OpenCV\opencv\bulid\x64\vc15\lib</strong><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f492f430904.png"></li></ul></li><li>选择 链接器-&gt;输入-&gt;附加依赖项,<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f13aac74119.png" alt="12.png"><br>在里面添加 <strong>opencv_world344d.lib</strong>，这个lib文件根据你的OpenCV版本号灵活变动<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f0828190561.png"></li><li>点击应用，确定即可<br>到这里，OpenCV的所有配置工作已经完成了，要注意的是解决方案那一栏要换成x64(因为我们一直在配置的就是x64)<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156ee8b6668598.png"><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>这是一段读取并显示本地图片的代码，测试一下你的OpenCV环境是否配置好</li></ol><pre><code class="line-numbers language-cpp">#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;int main()&#123;    Mat img = imread(&quot;1.bmp&quot;);    namedWindow(&quot;图片&quot;);    imshow(&quot;图片&quot;, img);    waitKey(6000);    return 0;&#125;</code></pre><p>运行结果如下：<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c15857414f57549.png"></p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><ol><li>导入包的时候不报错，但运行程序时出现一下错误<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f55e6b74341.png" alt="15.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f39a4e29681.png" alt="16.png"><br>出现这个问题，目前已知的有两个原因    <ul><li>imread函数读不到图片，即你的图片路径写的有问题<br>这里给出两种基本的路径书写形式    <ol><li>绝对路径<br>Mat img = imread(“D:\Pictures\1.bmp”);<br>一定要注意这里是双斜杠</li><li>图片路径<br>Mat img = imread(“1.bmp”);<br>使用这个的前提是图片的位置在你的工程目录下</li></ol></li><li>链接器的附加依赖项配置的有问题<br>在Debug模式下，附加依赖项添加的是 <strong>opencv_world344d.lib</strong><br>在Release模式下，附加依赖项添加的是 <strong>opencv_world344.lib</strong><br>有些教程是两个都添加，这是不对的，一定要注意。</li></ul></li></ol><hr><h1 id="MacOS-安装opencv-python"><a href="#MacOS-安装opencv-python" class="headerlink" title="MacOS 安装opencv-python"></a>MacOS 安装opencv-python</h1><h3 id="1-首先安装xcode"><a href="#1-首先安装xcode" class="headerlink" title="1. 首先安装xcode"></a>1. 首先安装xcode</h3><pre><code class="line-numbers language-bash">xcode-select --install </code></pre><h3 id="2-安装opencv-python"><a href="#2-安装opencv-python" class="headerlink" title="2. 安装opencv-python"></a>2. 安装opencv-python</h3><pre><code class="line-numbers language-bash">pip install opencv-python</code></pre><p>这默认将安装<code>opencv-python 4.2</code>, 但在 <strong>catalina</strong> 貌似不可用</p><p>所以我选择了安装低版本的opencv-python</p><pre><code class="line-numbers language-bash">pip install opencv-python==4.1.2.30</code></pre><p>或者选择安装</p><pre><code class="line-numbers language-bash">pip install opencv-python-headless</code></pre><p>这个原因未知</p><p>好了，教程到此结束，<br>接下来你就可以放心地去玩耍了，Enjoy Your OpenCV!</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割</title>
      <link href="/2019/07/24/tu-xiang-fen-ge/"/>
      <url>/2019/07/24/tu-xiang-fen-ge/</url>
      
        <content type="html"><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><hr><blockquote><p>整体等于部分之和<br>                —–欧几里德</p></blockquote><hr><p>图像分割把图像细分为它的组成要素或物体，细分的水平取决于要解决的问题。<br>单色分割的分割算法通常是基于图像亮度值的两个基本特征:不连续性和相似性。第一类，方法是基于亮度的突变来分割一幅图像，比如边缘;第二类，主要方法是根据事先定义好的准则把图像分割成相似的区域</p><h2 id="点、线和基本边缘检测"><a href="#点、线和基本边缘检测" class="headerlink" title="点、线和基本边缘检测"></a>点、线和基本边缘检测</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol><li>边缘像素是图像中灰度突变的像素，边缘是连接的边缘像素的集合</li><li>一条线可以视为一条边缘线段，该线段两侧的背景灰度要么远亮于该线像素的灰度，要么远暗于该线像素的灰度。孤立点可视为一条线，只是长度和宽度都是一个像素</li><li>局部变化检测可以用微分(一阶微分和二阶微分)    <ul><li>对于一阶导数的任何近似，约定:<ul><li>在恒定灰度区域必须为0</li><li>在灰度台阶和或斜坡开始处必须不为0</li><li>在沿灰度斜坡点处也必须不为0</li></ul></li><li>类似的对于二阶导数的近似<ul><li>在恒定灰度区域必须为0</li><li>在灰度台阶或斜坡开始除和结束处必须不为0</li><li>沿灰度斜坡必须为0</li></ul></li><li>一维函数展开为关于x的泰勒级数,结果差分<br>$$ \frac{\partial f}{\partial x}=f’(x)=f(x+1)-f(x)$$<br>二阶导数<br>$$ \frac{\partial ^2 f}{\partial ^2 x}=f’’(x)=f(x+1)+f(x-1)-2f(x)$$<ul><li>可以得出结论:<ul><li>一阶导数通常在图像中产生较粗的边缘</li><li>二阶导数对精细细节，如细线、孤立点和噪声有较强的响应</li><li>二阶导数在灰度斜坡和灰度台阶过渡处会产生双边缘响应</li><li>二阶导数的符号可用于确定边缘的过程是从亮到暗还是从暗到亮</li></ul></li><li>计算图像中每个像素位置的一阶导数和二阶导数的可选择方法是空间滤波器。模板在该区域中心点处的响应为<br>$$R = w_1z_1 + w_2z_2 + … + w_9z_9 = \sum_{k=1}^{9}w_kz_k$$</li></ul></li></ul></li></ol><table><thead><tr><th align="center">$w_1$</th><th align="center">$w_2$</th><th align="center">$w_3$</th></tr></thead><tbody><tr><td align="center">$w_4$</td><td align="center">$w_5$</td><td align="center">$w_6$</td></tr><tr><td align="center">$w_7$</td><td align="center">$w_8$</td><td align="center">$w_9$</td></tr></tbody></table><p>这是一个普通的3×3空间滤波器掩模</p><h3 id="孤立点检测"><a href="#孤立点检测" class="headerlink" title="孤立点检测"></a>孤立点检测</h3><ul><li>点的检测应以二阶导数为基础，这意味着使用laplace<br>$$\triangledown ^2f(x,y) = \frac{\partial ^2 f}{\partial x^2} + \frac{\partial ^2 f}{\partial y^2}$$<br>偏微分之后可求得laplace为<br>$$\triangledown ^2f(x,y) = f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$<br>点检测laplace模板</li></ul><table><thead><tr><th align="center">1</th><th align="center">1</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-8</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>如果在某点处的该模板的响应的绝对值超过了一个指定的阈值，那么就说在模板中心位置(x,y)处的该点已经被检测到。在输出图像中，这样的点被标注为1,所有其他点被标注为0<br>$$g(x,y)=\begin{cases}<br>1,\quad |R(x,y)| \geqq T\<br>0, \quad 其他<br>\end{cases}<br>$$</p><ul><li>MATLAB实现</li></ul><pre><code class="line-numbers language-matlab">f = imread(&#39;moon.jpg&#39;);f = rgb2gray(f);w = [-1 -1 -1; -1 8 -1; -1 -1 -1];g = abs(imfilter(f, w));T = max(g(:));g = g &gt;= T;figure(1);subplot(1,2,1)imshow(f)subplot(1,2,2)imshow(g)</code></pre><p>结果：<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37b3a82234833730.jpg"></p><h3 id="线检测"><a href="#线检测" class="headerlink" title="线检测"></a>线检测</h3><p>可以预期，二阶导数将导致更强的响应，并产生比一阶导数更细的线</p><p>线检测模板</p><ul><li>水平</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">-1</td><td align="center">-1</td><td align="center">-1</td></tr></tbody></table><ul><li>+45度</li></ul><table><thead><tr><th align="center">2 -</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">-1</td><td align="center">-1</td><td align="center">2</td></tr></tbody></table><ul><li>垂直</li></ul><table><thead><tr><th align="center">-1</th><th align="center">2</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr></tbody></table><ul><li>-45度</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">2</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">2</td><td align="center">-1</td><td align="center">-1</td></tr></tbody></table><p>对于恒定的背景，当线通过模板的中间一行时可能产生更大的响应。<br>每个模板的系数之和为0,这表示在恒定亮度区域内，模板的响应为0.</p><ul><li>MATLAB实现检测指定方向上的线</li></ul><pre><code class="line-numbers language-matlab">clcclearf = imread(&#39;11111.jpg&#39;);f = rgb2gray(f);figure(1);subplot(2,3,1)imshow(f);w = [-1, 2, -1; -1 2 -1; -1 2 -1];% g = imfilter(tofloat(f),w);g = imfilter(f,w);subplot(2,3,2)imshow(g, [ ]);gtop = g(1:120, 1:120);% gtop = pixeldup(gtop, 4);subplot(2,3,3)imshow(gtop, [ ]);gbot = g(end - 119:end, end - 119:end);% gbot = pixeldup(gbot, 4);subplot(2,3,4)imshow(gbot, [ ]);g = abs(g);subplot(2,3,5)imshow(g, [])T = max(g(:));g = g &gt;= T;subplot(2,3,6);imshow(g)</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37b3a815b7125153.jpg"><br>可能会用到的M函数pixeldup</p><pre><code class="line-numbers language-matlab">function B=pixeldup(A,m,n)%pixeldup用来重复像素的，在水平方向复制m倍，在垂直方向复制n倍，m，n必须为整数，n没有赋值默认为m%检查输入参数个数if nargin&lt;2    error(&#39;At least two inputs are required.&#39;);    endif nargin==2    n=m;    endu=1:size(A,1);%产生一个向量，其向量中元素的个数为A的行数%复制向量中每个元素m次m=round(m);%防止m为非整数u=u(ones(1,m),:);u=u(:);%在垂直方向重复操作v=1:size(A,2);n=round(n);v=v(ones(1,n),:);v=v(:);B=A(u,v);</code></pre><p><strong>慎用tofloat函数</strong></p><h3 id="基本边缘检测"><a href="#基本边缘检测" class="headerlink" title="基本边缘检测"></a>基本边缘检测</h3><h4 id="边缘模型"><a href="#边缘模型" class="headerlink" title="边缘模型"></a>边缘模型</h4><ul><li>台阶模型<br>在一个像素的距离上发生两次灰度级间理想的过渡</li><li>斜坡模型<br>数字图像存在被模糊或有噪声的边缘，这时的边缘被建模成一个更接近灰度斜坡的剖面，斜坡的斜度与边缘的模糊程度成反比</li><li>屋顶模型<br>通过一个区域的线的模型，屋顶边缘的基底(宽度)由该线的宽度和尖锐度决定<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d382004cd3e437707.jpg"></li></ul><p>结合前面提到的一阶导数和二阶导数的性质，可以得出结论:</p><ol><li>一阶导数的幅值可用于检测图像中的某个点处是否存在一个边缘</li><li>二阶导数的符号可用于确定一个边缘像素位于该边缘的暗的一侧还是亮的一侧</li><li>对图像的每个边缘，二阶导数生成两个值</li><li>二阶导数的零交叉点可用于定位粗边缘的中心</li></ol><ul><li>执行边缘检测的三个步骤:    <ol><li>为降噪对图像进行平滑处理</li><li>边缘点的检测</li><li>边缘定位</li></ol></li></ul><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><h5 id="梯度概念"><a href="#梯度概念" class="headerlink" title="梯度概念"></a>梯度概念</h5><p>梯度是一个可以确定图像f的(x,y)位置处的边缘方向和强度的工具，用 $\triangledown f$来表示，用 <strong>向量</strong>来定义</p><p>$$\triangledown f = \begin{bmatrix} g_x \ g_y \ \end{bmatrix} = \begin{bmatrix} \frac{\partial f}{\partial x} \ \frac{\partial f}{\partial x} \end{bmatrix}$$</p><h5 id="梯度性质"><a href="#梯度性质" class="headerlink" title="梯度性质"></a>梯度性质</h5><ol><li><p>梯度向量大小。<br>$\triangledown f$的大小为M(x,y)<br>$$\triangledown f = mag(\triangledown f)=[g_x^2+g_y^2]^{<br>1/2}= [(\partial f/\partial x)^2+(\partial f/\partial y)^2]^{1/2}$$<br>这是梯度向量方向变化率的值。其中$g_x$,$g_y$和M(x,y)都是和原图像大小相同的图像。称M(x,y)为梯度图像。</p></li><li><p>梯度向量的方向<br>$$\alpha (x,y) = tan^{-1}(\frac{g_x}{g_y})$$<br>同理，　$\alpha(x,y)$也是由$g_x$和$g_y$阵列创建的尺寸相同的图像。<br>任意点(x,y)处的一个边缘的方向与该点处梯度向量的方向$\alpha(x,y)$正交。<br>梯度向量有时也称为边缘法线</p></li><li><p>梯度指出f在(x,y)处的最大变化率的方向</p></li></ol><h5 id="梯度算子"><a href="#梯度算子" class="headerlink" title="梯度算子"></a>梯度算子</h5><h6 id="一维模板"><a href="#一维模板" class="headerlink" title="一维模板"></a>一维模板</h6><p>$$g_x = \frac{\partial f(x,y)}{\partial x} = f(x+1,y) - f(x,y)$$<br>和<br>$$g_y = \frac{\partial f(x,y)}{\partial y} = f(x,y+1)-f(x,y)$$</p><h6 id="二维模板"><a href="#二维模板" class="headerlink" title="二维模板"></a>二维模板</h6><p>罗伯特交叉梯度算子(Roberts),ROberts算子以求对角像素之差为基础:<br>$$g_x = \frac{\partial f}{\partial x} = (z_9 - z_5)$$<br>和<br>$$g_y = \frac{\partial f}{\partial y} = (z_8 - z_6)$$</p><h6 id="3×3模板"><a href="#3×3模板" class="headerlink" title="3×3模板"></a>3×3模板</h6><ol><li><p>Prewitt算子<br>$$g_x = (z_7 + z_8 + z_9)-(z_1 + z_2 + z_3)$$<br>和<br>$$g_y = (z_3 + z_6 + z_9) - (z_1 + z_4 + z_7)$$</p></li><li><p>Sobel算子</p></li></ol><p>$$g_x = (z_7 + 2z_8 + z_9)-(z_1 +2 z_2 + z_3)$$<br>和<br>$$g_y = (z_3 + 2z_6 + z_9) - (z_1 +2 z_4 + z_7)$$</p><p>在中心位置处使用2可以平滑图像</p><p>注意:所有模板中的系数之和为0，这意味着恒定灰度的响应为0.</p><h4 id="使用函数edge的边缘检测"><a href="#使用函数edge的边缘检测" class="headerlink" title="使用函数edge的边缘检测"></a>使用函数edge的边缘检测</h4><ul><li>语法</li></ul><pre><code class="line-numbers language-matlab">[g,t] = edge(f, &#39;method&#39;, parameters);</code></pre><p>f是输入图像，method是边缘检测方法，parameters是附加参数</p><h4 id="边缘检测算子"><a href="#边缘检测算子" class="headerlink" title="边缘检测算子"></a>边缘检测算子</h4><p>图像邻域如下图所示:</p><table><thead><tr><th align="center">$z_1$</th><th align="center">$z_2$</th><th align="center">$z_3$</th></tr></thead><tbody><tr><td align="center">$z_4$</td><td align="center">$z_5$</td><td align="center">$z_6$</td></tr><tr><td align="center">$z_7$</td><td align="center">$z_8$</td><td align="center">$z_9$</td></tr></tbody></table><h5 id="Sobel边缘检测算子"><a href="#Sobel边缘检测算子" class="headerlink" title="Sobel边缘检测算子"></a>Sobel边缘检测算子</h5><ul><li>Sobel边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-2</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><p>$$g_x=(z_7+2z_8+z_9)-(z_1+2z_2+z_3)$$</p><table><thead><tr><th align="center">-1</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">-2</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_y = (z_3+2z_6+z_9)-(z_1+2z_4+z_7)$$<br>每一行和每一列的中心像素用2来加权以提供平滑</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;sobel&#39;, T, dir);</code></pre><p>f是输入的图像，T是指定的阀值，dir是指定的检测边缘的首选方向:’horizontal’,’vertical’,’both’(默认值)<br>t是可选的，T未指定，则t自动设置</p><h5 id="Prewitt边缘检测算子"><a href="#Prewitt边缘检测算子" class="headerlink" title="Prewitt边缘检测算子"></a>Prewitt边缘检测算子</h5><ul><li>Prewitt边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>$$g_x = (z_7 + z_8 + z_9)-(z_1 + z_2 + z_3)$$</p><table><thead><tr><th align="center">-1</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_y = (z_3 + z_6 + z_9) - (z_1 + z_4 + z_7)$$</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;prewitt&#39;, T ,dir);</code></pre><p>计算简单，但容易产生噪声</p><h5 id="Roberts边缘检测算子"><a href="#Roberts边缘检测算子" class="headerlink" title="Roberts边缘检测算子"></a>Roberts边缘检测算子</h5><ul><li>Roberts边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_x = z_9 - z_5$$</p><table><thead><tr><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>$$g_y = z_8 - z_6$$</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;roberts&#39;, T , dir);</code></pre><h5 id="LoG检测算子"><a href="#LoG检测算子" class="headerlink" title="LoG检测算子"></a>LoG检测算子</h5><ul><li>LoG</li></ul><p>考虑高斯函数<br>$$G(x,y) = e^{-\frac{x^2 + y^2}{2\sigma ^2}}$$<br>$\sigma$是标准差。这是平滑函数，如果和图像卷积，会使图像变模糊，模糊程度由$\sigma$决定<br>这个函数的Laplace算法是:<br>$$\triangledown^2G(x,y) = \frac{\partial ^2 G(x,y)}{\partial x^2}+\frac{\partial ^2 G(x,y)}{\partial y^2} = [\frac{x^2 + y^2-2\sigma ^2}{\sigma ^4}]^{e^{-\frac{x^2 + y^2}{2\sigma ^2}}}$$</p><p>用$\triangledown ^2G(x,y)$卷积(滤波)这幅图像与先用平滑函数对图像卷积，再对结果进行Laplace变换的结果是一样的<br>用$\triangledown ^2G(x,y)$卷积图像，可以得到两个效果:平滑图像(因而减少了噪声);计算Laplace，从而产生双边缘图像，然后在双边缘之间定位由发现的零交叉组成的边缘</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;log&#39;, T , sigma);</code></pre><p>sigma默认值是2</p><h5 id="零交叉检测算子"><a href="#零交叉检测算子" class="headerlink" title="零交叉检测算子"></a>零交叉检测算子</h5><ul><li>基于LoG，卷积使用特殊的滤波函数H来完成</li><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;zerocross&#39;, T , H);</code></pre><h5 id="Canny检测算子"><a href="#Canny检测算子" class="headerlink" title="Canny检测算子"></a>Canny检测算子</h5><ul><li>edge函数中最强的边缘检测算子</li><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;canny&#39;, T , sigma);</code></pre><h4 id="MATLAB实现"><a href="#MATLAB实现" class="headerlink" title="MATLAB实现"></a>MATLAB实现</h4><ul><li>几种边缘检测算法的比较(Sobel,LoG,Canny)</li></ul><pre><code class="line-numbers language-matlab">f = imread(&#39;timg1.jpg&#39;); imshow(f),title(&#39;currect image&#39;);f = rgb2gray(f);%Default Output[gSobel_default,ts] = edge(f, &#39;sobel&#39;);[gLoG_default, tlog] = edge(f, &#39;log&#39;);[gCanny_default, tc] = edge(f,&#39;canny&#39;);%Best OutputgSobel_best = edge(f,&#39;sobel&#39;,0.165);gLoG_best = edge(f,&#39;log&#39;,0.008, 2.25);gCanny_best = edge(f,&#39;canny&#39;,[0.05, 0.4], 1.5);figure,imshow(f),title(&#39;Gary images&#39;);figure,imshow(gSobel_default),title(&#39;gSobel default&#39;);figure,imshow(gSobel_best),title(&#39;gSobel best&#39;);figure,imshow(gLoG_default),title(&#39;gLoG default&#39;);figure,imshow(gLoG_best),title(&#39;gLoG best&#39;);figure,imshow(gCanny_default),title(&#39;gCanny default&#39;);figure,imshow(gCanny_best),title(&#39;gCanny best&#39;);</code></pre><p>其中最佳输出的阀值是根据得到的ts,tlog,tc的值来确定的<br>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b4bec1777947.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b5886d994031.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b3ad9b270352.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b573bae72055.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b61724d14715.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b51df2874618.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b65663011930.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b3e566366232.jpg"><br>综合结果来看，Canny边缘检测算子可以得到最好的结果</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo大坑</title>
      <link href="/2019/07/22/hexo-da-keng/"/>
      <url>/2019/07/22/hexo-da-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="坑一、Template-render-error-模板渲染错误"><a href="#坑一、Template-render-error-模板渲染错误" class="headerlink" title="坑一、Template render error 模板渲染错误"></a>坑一、Template render error 模板渲染错误</h2><p>写了一下午博文，高高兴兴地hexo g却发现报错了！<br><code>INFO  Start processing FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Nunjucks Error:  [Line 2, Column 6] unexpected token: &#125;&#125;  at formatNunjucksError (/home/kevin/blog/node_modules/hexo/lib/extend/tag.js:102:13)     at Promise.fromCallback.catch.err (/home/kevin/blog/node_modules/hexo/lib/extend/tag.js:124:34)     at tryCatcher (/home/kevin/blog/node_modules/bluebird/js/release/util.js:16:23)     at Promise._settlePromiseFromHandler (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:517:31)     at Promise._settlePromise (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:574:18)     at Promise._settlePromise0 (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:619:10)     at Promise._settlePromises (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:695:18)     at _drainQueueStep (/home/kevin/blog/node_modules/bluebird/js/release/async.js:138:12)     at _drainQueue (/home/kevin/blog/node_modules/bluebird/js/release/async.js:131:9)     at Async._drainQueues (/home/kevin/blog/node_modules/bluebird/js/release/async.js:147:5)     at Immediate.Async.drainQueues [as _onImmediate] (/home/kevin/blog/node_modules/bluebird/js/release/async.js:17:14)     at processImmediate (internal/timers.js:443:21)</code></p><p>原因是nunjucks模板标签导致MD文件解析报错的问题，我试验了一下，在md文档中出现<code>双大括号</code>,<code>左大括号+#</code>,<code>左大括号+%</code>等都会报错(原谅我这么打，因为我打出来符号的话这篇博客就发不出来了)，下面是一位大神的<a href="http://xcoding.tech/2018/08/08/hexo/%E5%A6%82%E4%BD%95%E4%BB%8E%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3hexo%E4%B8%8D%E5%85%BC%E5%AE%B9%7B%7B%7D%7D%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/">解决办法</a>，他提供了几种解决办法，讲的很详细，可以参考一下</p><p>我觉得有点麻烦就没采用(说多了就是菜～),下面是我的办法:</p><ol><li>既然出现上面的内容就会报错，那就尽量避免出现呗…(说的都是废话)</li><li>使用<code>\lbrace</code>代替<code>\&#123;</code>,使用<code>\rbrace</code>代替<code>\&#125;</code><br>推荐大神的解决办法，一劳永逸，以后就不用管了</li></ol><h2 id="坑二、Markdown的空行"><a href="#坑二、Markdown的空行" class="headerlink" title="坑二、Markdown的空行"></a>坑二、Markdown的空行</h2><p>在写表格的时候要把表格体前后各空一行，不然你写的表格是这样式儿的，崩溃啊！<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/hexo%E5%A4%A7%E5%9D%91/1.png"></p><p>有可能是hexo解析的问题，我在使用markdown-preview的时候看的是正常的</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2020/09/15/cdn-for-blog/">CDN_for_blog</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形态学图像处理</title>
      <link href="/2019/07/22/xing-tai-xue-tu-xiang-chu-li/"/>
      <url>/2019/07/22/xing-tai-xue-tu-xiang-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="形态学图像处理"><a href="#形态学图像处理" class="headerlink" title="形态学图像处理"></a>形态学图像处理</h1><p>从这里开始过渡，从输入输出都是图像，过渡到图像分析方法，输出以某种方法来描述图像的内容。</p><h2 id="集合理论基础"><a href="#集合理论基础" class="headerlink" title="集合理论基础"></a>集合理论基础</h2><p>令Z为整数集合，用于产生的数字图像的抽样处理可以看做是把xy平面分割成网格状，其中每个网格的<strong>中心坐标</strong>是来自笛卡尔积$Z^2$中的一对元素。在集合理论中，如果(x,y)是来自$Z^2$的整数,f是分配给每个不同坐标的对(x,y)的亮度值的映射，那么函数f(x,y)被成为数字图像。如果亮度值也为整数，那么这幅图像就变成了二维图像。<br>集合的基本操作:$\in$,$\notin$,$\cup$,$\cap$,+,-.除了这些基本操作，形态学操作还需要两个算子，他们特别针对元素均为像素坐标的集合</p><ol><li>集合的反射$\hat{B}$<br>$$ \hat{B} = {w|w=-b,b\in B}$$</li><li>点z=($z_1$,$z_2$)集合的平移${(A)}_z$<br>$$ (A)_z = {c|c=a+z,a\in A}$$<h3 id="二值图像、集合及逻辑算子"><a href="#二值图像、集合及逻辑算子" class="headerlink" title="二值图像、集合及逻辑算子"></a>二值图像、集合及逻辑算子</h3>形态学理论把二值图像看成是前景(1值)像素的集合,集合的元素属于$Z^2$如果A和B都是二值图像，那么$C=A\cup B$也是二值图像<br>$$C(x,y)=\begin{cases}<br>1,\quad A(x,y)或B(x,y)为1,或者两者均为1\<br>0 \quad 其他<br>\end{cases}<br>$$<h3 id="在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算"><a href="#在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算" class="headerlink" title="在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算"></a>在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算</h3></li></ol><table><thead><tr><th>集合运算</th><th align="center">二值图像的MATLAb语句</th><th>名称</th></tr></thead><tbody><tr><td>$A\cap B$</td><td align="center">A &amp; B</td><td>与</td></tr><tr><td>$A\cup B$</td><td align="center">A $\rvert$ B</td><td>或</td></tr><tr><td>$A^c$</td><td align="center">~B</td><td>非</td></tr><tr><td>$A-B$</td><td align="center">A &amp;~ B</td><td>差</td></tr></tbody></table><h2 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h2><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀是使图像中的目标”生长”或”变粗”的操作。程度由一种被称为<strong>结构元</strong>的形状来控制<br>A被B膨胀，表示为$A \oplus B$,作为集合操作<br>$$ A\oplus B={ z|\hat{B}_z\cap A\not= \emptyset}$$<br>约定: $A \oplus B$ 的第一个操作数是图像，第二个操作数是结构元，结构元通常比图像小的多。<br><img loading="lazy" src="https://i.loli.net/2019/07/22/5d35670a79cd611294.jpg"></p><ul><li>工具箱函数imdilate(A, B)来执行膨胀</li></ul><pre><code class="line-numbers language-matlab">f = imread(&#39;1111.jpg&#39;);B = [0 1 0; 1 1 1; 0 1 0];%自定义结构元D = imdilate(f, B);subplot(1,2,1),imshow(f);title(&#39;原图&#39;)subplot(1,2,2),imshow(D);title(&#39;膨胀后的图&#39;)</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/22/5d3564132fa1741100.jpg"></p><h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p>腐蚀”收缩”或”细化”二值图像中的物体。像膨胀一样，收缩的方法和程度由结构元控制。<br>A被B腐蚀表示为$A\ominus B$,定义为:<br>$$ A\ominus B = {z| (B)_z\subseteq A} = {z| (B)_z\cap A^c = \emptyset}$$<br><img loading="lazy" src="https://i.loli.net/2019/07/23/5d36cefa2813d95731.jpg"></p><p>工具箱函数imerode(A,B)来执腐蚀</p><pre><code class="line-numbers language-matlab">f = imread(&#39;tig.jpg&#39;);B = [0 1 0; 1 1 1; 0 1 0];%自定义结构元R = imerode(f, B);subplot(1,2,1),imshow(f);title(&#39;原图&#39;)subplot(1,2,2),imshow(R);title(&#39;腐蚀后的图&#39;)</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/22/5d356b5f7eed962952.jpg"></p><h3 id="结构元"><a href="#结构元" class="headerlink" title="结构元"></a>结构元</h3><p>strel函数，用来构造各种大小和形状的结构元</p><pre><code class="line-numbers language-matlab">se = strel(shape, parameters);</code></pre><p>shape是希望形状的字符串，parameters是描述形状信息的参数列表<br><img loading="lazy" src="https://i.loli.net/2019/07/22/5d35670a85b4f22579.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/22/5d35670a63e2817742.jpg"><br>注意生成的se含有两项</p><ol><li>se.Neighborhood:[ ×  logical ]</li><li>se.Demensionality: 2</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>频域滤波器及其应用</title>
      <link href="/2019/07/20/pin-yu-lu-bo-qi-ji-qi-ying-yong/"/>
      <url>/2019/07/20/pin-yu-lu-bo-qi-ji-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="频域滤波器"><a href="#频域滤波器" class="headerlink" title="频域滤波器"></a>频域滤波器</h1><h2 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h2><h3 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h3><p>在以原点为圆心，以$D_0$为半径的圆内无衰减通过所有频率，而在圆外切断所有频率的二维低通滤波器，称为理想低通滤波器(ILPF)，定义为<br>$$y=\begin{cases}<br>1,\quad D(x,y)\leq 0\<br>0, \quad D(x,y) &gt; 0<br>\end{cases}$$<br>$D_0$是一个常数，D(u,v)是频率域中心点(u,v)与频率矩形中心的距离，即<br>$$ D(u,v)=\lbrack{(u-\frac{P}{2})^2+(v-\frac{Q}{2})^2}\rbrack^\frac{1}{2} $$<br>过渡点称为<strong>截止频率</strong><br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f0cb755202.jpg"></p><h3 id="布特沃斯低通滤波器"><a href="#布特沃斯低通滤波器" class="headerlink" title="布特沃斯低通滤波器"></a>布特沃斯低通滤波器</h3><p>截止频率位于距原点$D_0$处的n阶布特沃斯低通滤波器(BLPF)的传递函数的定义为:<br>$$H(u,v)=\frac{1}{1+{[D(u,v)/D_0]}^{2n}}$$<br>截止频率点是当D(u,v) = $D_0$时的点<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f101518273.jpg"></p><h3 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a>高斯低通滤波器</h3><p>二维形式:<br>$$H(u,v) = e^{-D^2(u,v)/2{D_0}^2} $$<br>$D_0$ 是截止频率<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f163e99741.jpg"></p><h3 id="使用低通滤波器平滑图像"><a href="#使用低通滤波器平滑图像" class="headerlink" title="使用低通滤波器平滑图像"></a>使用低通滤波器平滑图像</h3><h4 id="1-高斯低通滤波器"><a href="#1-高斯低通滤波器" class="headerlink" title="1. 高斯低通滤波器"></a>1. 高斯低通滤波器</h4><pre><code class="line-numbers language-matlab">f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);[f, revertclass] = tofloat(f);PQ = paddedsize(size(f));[U, V] = dftuv(PQ(1), PQ(2));D = hypot(U, V);D0 = 0.05*PQ(2);F = fft2(f, PQ(1), PQ(2));H = exp(-(D .^ 2)/(2 * (D0^2))); %高斯低通滤波器g = dftfilt(f, H);g = revertclass(g);figure, imshow(fftshift(H));figure, imshow(log(1 + abs(fftshift(F))), [])figure, imshow(g);</code></pre><p>滤波结果：<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d02f5468855048.jpg"></p><p>除了之前说的几个M函数外，还需要用到<code>dftfilt()</code>函数</p><pre><code class="line-numbers language-matlab">function g=dftfilt(f,H)%DFTFILT Performs frequency domain filtering.%   G=DFTFILT(F,H) filters F in the frequency domain using the%   filter transfer function H. The output, G, is the filtered%   image, which has the same size as F. DFTFILT automatically pads%   F to be the same size as H. Function PADDEDSIZE can be used%   to determine an appropriate size for H.%%   DFTFILT assumes that F is real and that H is a real, uncentered,%   circularly-symmetric filter function.%Obtain the FFT of the padded input.F=fft2(f,size(H,1),size(H,2));%Perform filtering.g=real(ifft2(H.*F));%Crop to original size.g=g(1:size(f,1),1:size(f,2));</code></pre><h4 id="2-Butterworth滤波"><a href="#2-Butterworth滤波" class="headerlink" title="2. Butterworth滤波"></a>2. Butterworth滤波</h4><p>该函数输入为灰度图像，自由设置截止频率$D_0$和BLPF的阶数n，输出为滤波后的图像(已归一化到[0,255])</p><pre><code class="line-numbers language-matlab">function [image_out] = Bfilter(image_in, D0, N)% Butterworth滤波器，在频率域进行滤波% 输入为需要进行滤波的灰度图像，Butterworth滤波器的截止频率D0，阶数N% 输出为滤波之后的灰度图像[m, n] = size(image_in);P = 2 * m;Q = 2 * n;fp = zeros(P, Q);%对图像填充0,并且乘以(-1)^(x+y) 以移到变换中心for i = 1 : m    for j = 1 : n        fp(i, j) = double(image_in(i, j)) * (-1)^(i+j);    endend% 对填充后的图像进行傅里叶变换F1 = fft2(fp);% 生成Butterworth滤波函数，中心在(m+1,n+1)Bw = zeros(P, Q);a = D0^(2 * N);for u = 1 : P    for v = 1 : Q        temp = (u-(m+1.0))^2 + (v-(n+1.0))^2;        Bw(u, v) = 1 / (1 + (temp^N) / a);    endend%进行滤波G = F1 .* Bw;% 反傅里叶变换gp = ifft2(G);% 处理得到的图像image_out = zeros(m, n, &#39;uint8&#39;);gp = real(gp);g = zeros(m, n);for i = 1 : m    for j = 1 : n        g(i, j) = gp(i, j) * (-1)^(i+j);    endendmmax = max(g(:));mmin = min(g(:));range = mmax-mmin;for i = 1 : m    for j = 1 : n        image_out(i,j) = uint8(255 * (g(i, j)-mmin) / range);    endendend</code></pre><p>测试BLPF的阶数为2,截止频率分别为10,40,80,150,450</p><pre><code class="line-numbers language-matlab">clear all;close all;clc;image1 = imread(&#39;2.jpg&#39;);image2 = Bfilter(image1, 10, 2);image3 = Bfilter(image1, 40, 2);image4 = Bfilter(image1, 80, 2);image5 = Bfilter(image1, 150, 2);image6 = Bfilter(image1, 450, 2);% 显示图像subplot(2,3,1), imshow(image1), title(&#39;原图像&#39;);subplot(2,3,2), imshow(image2), title(&#39;D0 = 10, n = 2&#39;);subplot(2,3,3), imshow(image3), title(&#39;D0 = 40, n = 2&#39;);subplot(2,3,4), imshow(image4), title(&#39;D0 = 80, n = 2&#39;);subplot(2,3,5), imshow(image5), title(&#39;D0 = 150, n = 2&#39;);subplot(2,3,6), imshow(image6), title(&#39;D0 = 450, n = 2&#39;);</code></pre><p>滤波结果如下:<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d02f43bc610556.jpg"><br>分析结果:    </p><ol><li>模糊的平滑过渡是截止频率增大的函数</li><li>滤波后输出三副连续的色图，原因是rgb图像的分三次呈现<br>一副彩图是由三色组成,红绿蓝三色，图像读取到matlab后，有三个参数m × n × 3, 代表的是三色叠加，处理之后的图将三色展开分别呈现了，所以才会出现三副连续的色图<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d80a09a9124012.jpg"></li></ol><p>换成彩色图可以明显看到<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d80a3073491464.jpg"></p><h2 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h2><p>图像的锐化可以在频率与通过高通滤波器来实现<br>一个高通滤波器可以由一个低通滤波器来实现:<br>$$H_{HP}(u,v)=1-H_{LP}(u,v)$$<br>被低通滤波器衰减的频率可以通过高通滤波器</p><h3 id="理想高通滤波器"><a href="#理想高通滤波器" class="headerlink" title="理想高通滤波器"></a>理想高通滤波器</h3><p>二维理想高通滤波器可以定义为<br>$$ H(u,v)=\begin{cases}<br>1,\quad D(u,v)\leq D_0\<br>0,\quad D(u,v)&gt;D_0<br>\end{cases}<br>$$<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1c410443073.jpg"></p><h3 id="布特沃斯高通滤波器"><a href="#布特沃斯高通滤波器" class="headerlink" title="布特沃斯高通滤波器"></a>布特沃斯高通滤波器</h3><p>截止频率为$D_0$的n阶布特沃斯高通滤波器(BHPF)的定义为:<br>$$ H(u,v)=\frac{1}{1+[D_0/D(u,v)]^{2n}}$$<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1c376281237.jpg"></p><h3 id="高斯高通滤波器"><a href="#高斯高通滤波器" class="headerlink" title="高斯高通滤波器"></a>高斯高通滤波器</h3><p>截止频率处在距频率矩形中心距离为$D_0$的高斯高通滤波器(GHPF)的传递函数如下:<br>$$H(u,v)=1-e^{-D^2(u,v)/2D_0^2}$$<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1c3f7954220.jpg"></p><h3 id="使用高通滤波器锐化图像"><a href="#使用高通滤波器锐化图像" class="headerlink" title="使用高通滤波器锐化图像"></a>使用高通滤波器锐化图像</h3><p>使用高通滤波器来锐化图像，与平滑图像类似，只是将低通滤波器换成了高通滤波器，具体步骤不再赘述</p><pre><code class="line-numbers language-matlab">f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);[f, revertclass] = tofloat(f);PQ = paddedsize(size(f));[U, V] = dftuv(PQ(1), PQ(2));D = hypot(U, V);D0 = 0.05*PQ(1);F = fft2(f, PQ(1), PQ(2));H = hpfilter(&#39;gaussian&#39;,PQ(1), PQ(2), D0);g = dftfilt(f, H);g = revertclass(g);figure(1)subplot(2,2,1);imshow(f,[]);title(&#39;原图像&#39;)subplot(2,2,2);imshow(fftshift(H));title(&#39;高斯高通滤波器&#39;);subplot(2,2,3);imshow(log(1 + abs(fftshift(F))), [])title(&#39;滤波后图像谱&#39;);subplot(2,2,4);imshow(g);title(&#39;滤波后图像&#39;);</code></pre><p>同样这里需要的是高通滤波函数hpfilter()</p><pre><code class="line-numbers language-matlab">function [H] = hpfilter(type,M,N,D0,n)%HPFILTER Computes freq. domain highpass filters%        THIS IS NOT A STANDARD MATLAB FUNCTION%        H = hpfilter (type,M,N,D0,n) creates the%        transfer function of a highpass filter, H, of%        the specified type and size MxN. Possible%        values for type, D0, and n are:%%        &#39;ideal&#39;                Ideal highpass filter with%                        cutoff frequency D0. If%                        supplied, n is ignored.%        &#39;btw&#39;                Butterworth highpass filter%                        of order n, and cutoff D0.%        &#39;gaussn&#39;            Gaussian highpass filter with%                        cutoff (standard deviation)D0.%                        If supplied, n is ignored.%        M and N should be even numbers for DFT%        filtering.%%        Class support: double, uint8, uint16%        The output is of class double%       The transfer function Hhp of a highpass filter%       is 1 - Hlp, where Hlp is the transfer function of%       the corresponding lowpass filter.  Thus, we can%       use function lpfilter to generate highpass filters%       If filter is btw, make sure that n is provided%       Otherwise, pass n=1 as an arbitrary value to%       prevent error messageif nargin == 4    n = 1; %default value of nendHlp = lpfilter(type,M,N,D0,n);H = 1 - Hlp;%       End of function</code></pre><p>锐化结果:</p><ol><li>IHPF<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341eae3a6b123891.jpg"></li><li>BHPF<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f13e453488.jpg"></li><li>GHPF<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341eae4fa8d96779.jpg"></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>频域滤波</title>
      <link href="/2019/07/19/pin-yu-lu-bo/"/>
      <url>/2019/07/19/pin-yu-lu-bo/</url>
      
        <content type="html"><![CDATA[<h1 id="频域滤波"><a href="#频域滤波" class="headerlink" title="频域滤波"></a>频域滤波</h1><ol><li>对图像平滑的低通滤波</li><li>对图像锐化的高通滤波</li><li>去除周期的选择性滤波</li></ol><h2 id="二维傅里叶变换"><a href="#二维傅里叶变换" class="headerlink" title="二维傅里叶变换"></a>二维傅里叶变换</h2><ul><li><p>二维傅里叶变换:<br>$$ F(u,v)=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x,y)e^{-j2\pi(ux + vy)},\mathrm{d}x \mathrm{d}y $$</p></li><li><p>二维傅里叶逆变换：<br>$$ f(x,y) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(u,v)e^{j2\pi(ux + vy)},dxdy $$</p></li></ul><h2 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h2><p>f(x,y)代表一幅大小为M×N的图像，其中x=0,1,……,M-1,y=0,1,…..,N-1,DFT如下</p><p>$$ F(u,v)=\int_{x=0}^{M-1} \int_{y=0}^{N-1} f(x,y)e^{-j2\pi(\frac{ux}{M}+\frac{vy}{N})},\mathrm{d}x \mathrm{d}y $$</p><p>IDFT：</p><p>$$ f(x,y)=\frac{1}{MN}\int_{x=0}^{M-1} \int_{y=0}^{N-1} F(u,v)e^{j2\pi(\frac{ux}{M}+\frac{vy}{N})},\mathrm{d}x \mathrm{d}y $$</p><p>这里的F(u,v)被称为展开的傅里叶级数</p><p>频域原点出的变换的值F(0,0)称为傅里叶变换的直流(dc)分量，F(0,0)等于f(0,0)平均值的MN倍。要注意的是在MATLAB中索引是从1开始的而不是从0开始的</p><h2 id="MATLAB实现对图像的Fourier变换和逆变换"><a href="#MATLAB实现对图像的Fourier变换和逆变换" class="headerlink" title="MATLAB实现对图像的Fourier变换和逆变换"></a>MATLAB实现对图像的Fourier变换和逆变换</h2><ul><li>Fourier变换，f为原图像</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; F = fft2(f);</code></pre><ul><li>Fourier谱</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; S = abs(F);</code></pre><p>该函数计算的是数组中每个元素的幅值( $ \sqrt{r^2+i^2} $ )<br>可以在这里观察到4个角的亮点，这就是周期特性的结果，不便观察</p><ul><li>将交换的原点移动到频域矩形的中心</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; Fc = fftshift(F)</code></pre><p>频谱范围大，不便观察</p><ul><li>取模，缩放</li></ul><pre><code class="line-numbers language-matlab">S2 = log(1 + abs(Fc));</code></pre><ul><li>Fourier逆变换</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; f = ifft2(F);</code></pre><p>下面是完整代码</p><pre><code class="line-numbers language-matlab">img=imread(&#39;moon.jpg&#39;);subplot(2,2,1);    imshow(img);    title(&#39;原图&#39;);f=rgb2gray(img);    %对于RGB图像必须做的一步，也可以用im2double函数F=fft2(f);          %Fourier变换F1=log(abs(F)+1);   %取模,缩放subplot(2,2,2);    imshow(F1,[]);    title(&#39;傅里叶变换频谱图&#39;);Fs=fftshift(F);      %将频谱图中零频率成分移动至频谱图中心S=log(abs(Fs)+1);    %取模并进行缩放subplot(2,2,3);    imshow(S,[]);    title(&#39;频移后的频谱图&#39;);fr=real(ifft2(ifftshift(Fs)));  %频率域反变换到空间域，并取实部ret=im2uint8(mat2gray(fr));    %更改图像类型subplot(2,2,4);    imshow(ret);    title(&#39;逆傅里叶变换&#39;);</code></pre><p>结果<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d3043778b4e114553.jpg"><br>如果使用<code>&gt;&gt; f = im2double(img)</code>进行处理，则会出现以下结果<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d304377bcc9554917.jpg"></p><ul><li>分析    </li></ul><ol><li>图像Fourier变换之后立即imshow会报错<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d3043779bef722309.jpg"><br>这是因为经过fourier变换之后的图像矩阵为复数矩阵，包含实部和虚部，此时进行<code>abs(f)</code>取复数矩阵的模，再显示。</li><li><code>rgb2gray()</code>和<code>im2double()</code>的使用<br>这一点要特别注意，对于RGB图像，<code>imread()</code>是已三维矩阵的形式来存储的，要先进行类型转换，否则会出现空白    </li><li><code>rgb2gray()</code>转换为灰度图像,得到的图像呈灰色基调，见‘结果’</li><li><code>im2double()</code>转换成双精度图像，得到的图像呈白色基调，见‘结果’<br>其他图像处理结果<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d304377bd0c676784.jpg"></li></ol><p><img loading="lazy" src="https://i.loli.net/2019/07/18/5d304377b0b2610307.jpg"><br>可以看到Fourier逆变换处理之后的图片为原图的灰度图片。</p><h2 id="对图像Fourier变换的意义分析"><a href="#对图像Fourier变换的意义分析" class="headerlink" title="对图像Fourier变换的意义分析"></a>对图像Fourier变换的意义分析</h2><p>对于一个图像，其频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间的梯度。设f为一个能量有限的模拟信号，其傅里叶变换代表f的频谱。从纯粹的数学意义上来看，Fourier变换是将一个函数转换成一系列的周期函数来进行处理的。从物理角度来看，Fourier变换是将图像从空间域转换到频率域，逆变换是将图像从频率域转换到空间域。也就是说，Fourier变换是将图像的灰度分布函数变换成图像的频率分布函数。<strong>这里要注意是灰度分布函数</strong>,下面还会说到。</p><p>Fourie逆变换是将图像的频率分布函数转换成灰度分布函数(原始图像的灰度分布函数),图像的概念前边说过，用一个二维矩阵来表示空间上的各点，z=f(x,y)，但空间是三维的，因此空间上的物体在另一个维度上的关系必须由梯度来表示。</p><p>Fourier频谱图上的明暗点，意义是指图像上的某一点与邻域点差异的强弱，即梯度的大小。</p><p>对频谱移频到原点之后，可以看出图像的频率分布是以原点为圆心，对称分布的.</p><h2 id="DFT滤波"><a href="#DFT滤波" class="headerlink" title="DFT滤波"></a>DFT滤波</h2><h3 id="滤波步骤"><a href="#滤波步骤" class="headerlink" title="滤波步骤"></a>滤波步骤</h3><ol><li>用函数<code>tofloat</code>把输入图像转换成浮点图像<pre><code class="line-numbers language-matlab">&gt;&gt; [f, revertclass] = tofloat(f);</code></pre></li><li>用函数<code>paddedsize</code>来获得填充参数<pre><code class="line-numbers language-matlab">&gt;&gt; PQ = paddedsize(size(f));</code></pre></li><li>得到有填充的Fourier变换<pre><code class="line-numbers language-matlab">&gt;&gt; F = fft2(f,PQ(1), PQ(2));</code></pre></li><li>生成大小为PQ(1)×PQ(2)的滤波函数H,函数类型要满足如下图所示,<br><img loading="lazy" src="https://i.loli.net/2019/07/19/5d318dcf343b438405.jpg"><br>如果是类似这样的<br><img loading="lazy" src="https://i.loli.net/2019/07/19/5d318dcf4915275796.jpg">    <pre><code class="line-numbers language-matlab">&gt;&gt; H = lpfilter(&#39;gaussian&#39;,PQ(1),PQ(2),2*sig);</code></pre>在使用滤波器之前，要先<code>H = fftshift(H)</code></li><li>用滤波器乘以FFT变换<pre><code class="line-numbers language-matlab">&gt;&gt; G = H .* F;</code></pre></li><li>获得G的逆Fourier变换<pre><code class="line-numbers language-matlab">&gt;&gt; g = ifft2(G);</code></pre></li><li>修剪左上部矩形为原始大小<pre><code class="line-numbers language-matlab">&gt;&gt; g = g(1:size(f, 1), 1:size(f, 2));</code></pre></li><li>把滤波后的图像变换为输入图像的类<pre><code class="line-numbers language-matlab">&gt;&gt; g = revertclass(g);</code></pre><h3 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h3></li></ol><pre><code class="line-numbers language-matlab">f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);%未填充的滤波[M,N] = size(f);[f, revertclass] = tofloat(f);F = fft2(f);sig = 10;H = lpfilter(&#39;gaussian&#39;, M, N, sig);G = H.*F;g = ifft2(G);g = revertclass(g);figure(1);subplot(1,2,1);imshow(g)title(&#39;未填充的滤波&#39;);%已填充的滤波PQ = paddedsize(size(f));Fp = fft2(f,PQ(1),PQ(2));Hp = lpfilter(&#39;gaussian&#39;,PQ(1),PQ(2),2*sig);Gp = Hp.*Fp;gp = ifft2(Gp);gpc = gp(1:size(f,1),1:size(f,2));gpc = revertclass(gpc);subplot(1,2,2);imshow(gpc);title(&#39;已填充的滤波&#39;);</code></pre><p>这里展示了不填充滤波和填充滤波的两种情况，结果<br><img loading="lazy" src="https://i.loli.net/2019/07/19/5d318dcf1e88071166.jpg"><br>可以观察到未填充滤波处理后图像的垂直边缘未模糊</p><p>涉及到的函数    </p><ul><li>paddedsize函数</li></ul><pre><code class="line-numbers language-matlab">function PQ = paddedsize(AB, CD, PARAM)if nargin == 1PQ = 2*AB;elseif nargin == 2 &amp; ~ischar(CD) %如果CD不为字符串PQ = AB + CD -1;PQ = 2 *ceil(PQ / 2);elseif nargin == 2 %如果CD处为字符串m = max(AB);P = 2^nextpow2(2*m); %取2的整数次幂PQ = [P, P];elseif nargin == 3m = max([AB CD]);P = 2^nextpow2(2*m);PQ = [P, P];elseerror(&#39;wrong number of inputs.&#39;)end</code></pre><ul><li>lpfilter函数</li></ul><pre><code class="line-numbers language-matlab">function [ H, D ] = lpfilter( type,M,N,D0,n )%LPFILTER creates the transfer function of a lowpass filter.%   Detailed explanation goes here%use function dftuv to set up the meshgrid arrays needed for computing%the required distances.[U, V] = dftuv(M,N);%compute the distances D(U,V)D = sqrt(U.^2 + V.^2);%begin filter computationsswitch type    case &#39;ideal&#39;        H = double(D &lt;= D0);    case &#39;btw&#39;        if nargin == 4            n = 1;        end        H = 1./(1+(D./D0).^(2*n));    case &#39;gaussian&#39;        H = exp(-(D.^2)./(2*(D0^2)));    otherwise        error(&#39;Unkown filter type&#39;);end</code></pre><ul><li>dftuv函数</li></ul><pre><code class="line-numbers language-matlab">function [ U,V ] = dftuv( M, N )%DFTUV 实现频域滤波器的网格函数%   Detailed explanation goes hereu = 0:(M - 1);v = 0:(N - 1);idx = find(u &gt; M/2); %找大于M/2的数据u(idx) = u(idx) - M; %将大于M/2的数据减去Midy = find(v &gt; N/2);v(idy) = v(idy) - N;[V, U] = meshgrid(v, u);</code></pre><ul><li>总结：</li></ul><ol><li>图像平滑之后，变得更柔和，但也会更模糊    </li><li>会出现的问题:图像的边缘部分往往也处于高频，会被滤除</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空间滤波</title>
      <link href="/2019/07/17/kong-jian-lu-bo/"/>
      <url>/2019/07/17/kong-jian-lu-bo/</url>
      
        <content type="html"><![CDATA[<h1 id="空间滤波基础"><a href="#空间滤波基础" class="headerlink" title="空间滤波基础"></a>空间滤波基础</h1><h2 id="滤波的原理："><a href="#滤波的原理：" class="headerlink" title="滤波的原理："></a>滤波的原理：</h2><p>空间滤波是采用滤波处理的图像增强的方法，理论基础是空间卷积和空间相关，目的是改善图片质量</p><h2 id="线性空间滤波"><a href="#线性空间滤波" class="headerlink" title="线性空间滤波"></a>线性空间滤波</h2><ul><li>移动滤波的模板w称为滤波器</li><li>相关 与 卷积：<br>相关是指模板w按下图所示的方式进行图像数组的处理。在原理上，卷积是相同的处理过程，只不过在w通过之前先将它选旋转180度<br><img loading="lazy" src="https://i.loli.net/2019/07/16/5d2d9d9ea213761403.jpg"><br>相关与卷积操作说明<br><img loading="lazy" src="https://i.loli.net/2019/07/16/5d2d9dffdbc4911045.jpg"><br>需要注意的地方：    </li></ul><ol><li>相关是滤波器位移的函数</li><li>滤波器w与一个只包含一个1其余全是0的函数相关，得到的是旋转了180度的滤波器w，将这个函数称之为<strong>离散单位冲激</strong><br>结论: 一个函数与离散单位冲激相关，在该冲激位置产生这个函数的一个翻转版本<br>一个函数与离散单位冲激相关激卷积，得到的是在该冲激处的这个函数的拷贝，这个复制的性质称为筛选<br>这种定义推广到图像如下图所示<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2e77c7afba429201.jpg"><br>为了便于表达，以公式形式总结两种形式</li></ol><ul><li>大小为m×n的滤波模板w(x,y)与函数f(x,y)的相关<pre><code>   ![](https://i.loli.net/2019/07/17/5d2e78e52323950837.jpg)</code></pre></li><li>大小为m×n的滤波模板w(x,y)与函数f(x,y)的卷积<br>$$w(x,y)\bigstar f(x,y)=\sum_{s=-a}^{a}\sum_{t=-b}^{b}w(s,t)f(x+s,y+t)$$</li></ul><ul><li><p>Matlab的实现:<br>工具箱使用imfilter来实现线性空间滤波，语法如下:</p><pre><code class="line-numbers language-matlab">g = imfilter(f, w, filtering_mode, boundary_options, size_options)</code></pre><p>默认值为相关，若想执行卷积操作，有以下两种做法：</p><pre><code class="line-numbers language-matlab">g = imfilter(f, w, &#39;conv&#39;)</code></pre><p>或者使用<code>rot90(w, 2)</code>来将w旋转180度</p><pre><code class="line-numbers language-matlab">g = imfilter(f, rot90(w, 2))</code></pre><p>f是输入图像，w为滤波模板，g为滤波结果<br>其他参数如下<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2e84e556ad615011.jpg"><br>使用matlab实现为</p><pre><code class="line-numbers language-matlab">f = imread(&#39;filter.jpg&#39;);F = im2double(f);imshow(F);title(&#39;current image&#39;);w = ones(31);gd = imfilter(F, w);figure,imshow(gd, [ ]);title(&#39;Default&#39;);gr = imfilter(F, w, &#39;replicate&#39;);figure,imshow(gr, [ ]);title(&#39;replicate&#39;);gs = imfilter(F, w, &#39;symmetric&#39;);figure,imshow(gs, [ ]);title(&#39;symmetric&#39;);gc = imfilter(F, w, &#39;circular&#39;);figure,imshow(gc, [ ]);title(&#39;circular&#39;);g = imfilter(f, w, &#39;replicate&#39;);figure,imshow(g, [ ]);title(&#39;replicate unit8&#39;);</code></pre><p>这里开始读取的filter.jpg为uint8格式，故在处理之前先使用<code>im2double</code>将其转化为double类型以提高精度<br>滤波结果如下<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2e8517ac67e80281.jpg"></p></li></ul><h2 id="非线性空间滤波："><a href="#非线性空间滤波：" class="headerlink" title="非线性空间滤波："></a>非线性空间滤波：</h2><p>线性空间滤波基于计算乘积和，即线性操作，非线性空间滤波基于涉及邻域像素内的非线性操作，例如，使每个中心点的响应等于邻域内像素最大值的操作可以称为是非线性滤波操作      </p><ul><li>Matlab工具</li></ul><ol><li>nlfilter：直接执行二维操作</li><li>coldilt：按列组织数据，更多采用</li></ol><h2 id="标准的-空间滤波器"><a href="#标准的-空间滤波器" class="headerlink" title="标准的 空间滤波器"></a>标准的 <strong>空间滤波器</strong></h2><h3 id="线性空间滤波器"><a href="#线性空间滤波器" class="headerlink" title="线性空间滤波器"></a>线性空间滤波器</h3><ul><li><p>可以使用fspecial实现，生成滤波器w</p><pre><code class="line-numbers language-matlab">w = fspecial(&#39;type&#39;, parameters)</code></pre><p>  ‘type’表示滤波器的类型，’parameters’进一步定义指定的滤波器<br>  应用参数如下：<br>  <img loading="lazy" src="https://i.loli.net/2019/07/17/5d2eba0f5055d41026.jpg"><br>  <img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ec9491164776894.jpg"></p></li><li><p>Laplace滤波器的实现</p><ul><li><p>原理：<br>图像f(x,y)的laplace算子：<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ec90e6a75162149.jpg"><br>Laplace算子增强公式：<br>$$g(x,y) = f(x,y)+c[\triangledown ^2 f(x,y)]$$<br>注意：如果模板的中心系数为正，c为1;如果为负，c为0.</p><pre><code class="line-numbers language-matlab">fspecial(&#39;laplacian&#39;, alpha)</code></pre><p>可以实现更为一般的laplace模板</p></li></ul><ul><li><p>下面是用laplace滤波器增强图像的例子：<br>首先设置滤波器</p><pre><code class="line-numbers language-matlab">&gt;&gt; w = fspecial(&#39;laplacian&#39;, 0);</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed6fcca83142276.jpg"></p><p>输入的图像为unit8类，</p><pre><code class="line-numbers language-matlab">&gt;&gt; g1 = imfilter(f, w, &#39;replicate&#39;);&gt;&gt; imshow(g1);</code></pre><p>得到结果，但存在问题，所有像素都是正的。原因：滤波器的中心参数为负值，为了解决这一问题，可以在滤波前将f转换为浮点数</p><pre><code class="line-numbers language-matlab">&gt;&gt; ff = tofloat(f);&gt;&gt; g2 = imfilter(ff, w, &#39;replicate&#39;);&gt;&gt; imshow(g2);</code></pre><p>这里tofloat为M-IPT函数，实现代码如下：</p><pre><code class="line-numbers language-matlab">function [out,revertclass] = tofloat(inputimage)%Copy the book of Gonzalesidentify = @(x) x;tosingle = @im2single;table = &#123;&#39;uint8&#39;,tosingle,@im2uint8&#39;uint16&#39;,tosingle,@im2uint16&#39;logical&#39;,tosingle,@logical&#39;double&#39;,identify,identify&#39;single&#39;,identify,identify&#125;;classIndex = find(strcmp(class(inputimage),table(:,1)));if isempty(classIndex)error(&#39;不支持的图像类型&#39;);endout = table&#123;classIndex,2&#125;(inputimage);revertclass = table&#123;classIndex,3&#125;;</code></pre><p>导入workspace即可</p><p>最后用原始图像减去laplace图像来恢复失去的灰度层次(因为中心参数为负值)</p><pre><code class="line-numbers language-matlab">&gt;&gt; g = ff - g2;imshow(g);</code></pre><p>可以看到结果比原图象要清晰<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed69eaa47174206.jpg"></p></li></ul></li></ul><h3 id="非线性空间滤波器"><a href="#非线性空间滤波器" class="headerlink" title="非线性空间滤波器"></a>非线性空间滤波器</h3><ul><li>函数ordfilt2计算统计排序(order-statistic filter)滤波器(也叫做rank filter,即排序滤波器)<br>语法为：</li></ul><pre><code class="line-numbers language-matlab">g = ordfilt2(f, order, domain)</code></pre><p>用邻域集合中的第order个元素去替换f中的每个元素的值来生成图像g，domain是由0和1组成的大小为m×n的矩阵，规定了在计算中使用的邻域中像素点的位置</p><ul><li>中值滤波器，最著名的统计排序滤波器，对应第50个百分位，对应奇数的m和n</li></ul><pre><code class="line-numbers language-matlab">g = ordfilt2(f, (m*n + 1)/2, ones(m, n));</code></pre><ul><li>这里提供了一个专门的二维中值滤波器:</li></ul><pre><code class="line-numbers language-matlab">g = medfilt2(f, [m, n], padopt)</code></pre><p>  padopt规定了三个可能的边缘填充选项:</p><ol><li>‘zeros’,默认值</li><li>‘symmetric’,f按照镜像反射方式对称地沿边缘扩展</li><li>‘indexed’，f属于double类，用1填充;否则用0填充</li></ol><ul><li><p>中值滤波增强图像:<br>首先给图像添加黑白噪点发生概率为0.2的’椒盐噪声’</p><pre><code class="line-numbers language-matlab">&gt;&gt; fn = imnoise(f, &#39;salt &amp; pepper&#39;, 0.2)</code></pre><p>对带噪图像进行中值滤波处理</p><pre><code class="line-numbers language-matlab">&gt;&gt; gm = medfilt2(fn)</code></pre><p>注意，在这里出现了错误，==A应为二维==<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed759e608448713.jpg"></p><p>原因:中值滤波medfilt2,输入的图像应为二维矩阵，实际输入的为imread读取的图像加上噪声，通常是三维RGB图，是三维矩阵<br>解决办法:先用rgb2gray(f)将图像转换为灰度矩阵图像</p><pre><code class="line-numbers language-matlab">&gt;&gt; fn2 = rgb2gray(fn);&gt;&gt; gm = medfilt2(fn2);&gt;&gt; imshow(gm);</code></pre><p>减弱外圈黑点</p><pre><code class="line-numbers language-matlab">&gt;&gt; gms = medfilt2(fn2, &#39;symmetric&#39;);</code></pre></li></ul><p><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed7776b71a55041.jpg"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital Image Processing</title>
      <link href="/2019/07/15/digital-image-processing/"/>
      <url>/2019/07/15/digital-image-processing/</url>
      
        <content type="html"><![CDATA[<h2 id="Digital-Image-Processing-notes"><a href="#Digital-Image-Processing-notes" class="headerlink" title="Digital Image Processing notes:"></a>Digital Image Processing notes:</h2><ul><li><p>图像处理的步骤：</p><ol><li>图像获取 包括图像预处理</li><li>图像滤波与增强 使之适用于 <strong>特定应用</strong></li><li>图像复原 倾向于以图像退化的数学或概率模型为基础</li><li>彩色图像处理</li><li>压缩 减少图像存储量或降低传输图像带宽 </li><li>形态学处理</li><li>图像分割</li><li>目标识别<h3 id="数字图像基础"><a href="#数字图像基础" class="headerlink" title="数字图像基础"></a>数字图像基础</h3></li></ol></li><li><p>灰度概念<br>  灰度是表明图像明暗的数值，即黑白图像中点的颜色深度，范围一般是0-255,白色为255,黑色为0,归一化处理之后[0,1],0代表黑色，1代表白色。</p></li><li><p>图像取样与量化</p><ul><li>对坐标值数字化称为取样，对幅度值数字化称为量化</li></ul></li><li><p>数字的图像表示<br>  将连续图像取样表示为一个二维阵列 $f(x,y)$</p><ol><li>函数图表示：用x和y两个坐标轴来表示空间位置，第三个坐标为f(灰度)值，即 $f(x,y,z)$，</li><li>一般的表示：显示的是 $f(x,y)$在监视器或照片上的情况，每个点的灰度与该点处的f值成正比，例如归一化[0,1],三个等间隔点分别为0,0.5,1</li><li>矩阵： 将 $f(x,y)$的值打印成矩阵<br>注意坐标为右手笛卡尔系</li></ol></li><li><p>对比度： 最高和最低的灰度级的差</p></li><li><p>典型灰度级：<br>$$2^k$$<br>称为一副’k bit图像’</p></li><li><p>图像内插</p><ul><li>最邻近内插</li><li>双线性内插</li><li>双三次内插</li></ul></li><li><p>图像处理的算术操作</p><ul><li>图片相加  平均 -&gt; 降噪</li><li>图片相减  增强图像差别</li><li>图片想乘除  校正阴影</li></ul></li><li><p>灰度变换</p><ul><li>s = T(r)</li><li>Matlab中的灰度变换函数<br><code>imadjust(f,[LOW_IN,HIGH_IN],[LOW_OUT,HIGH_OUT],grmma)</code></li></ul></li><li><p>直方图的处理和函数绘图</p><ul><li><p>生成图像的直方图</p><pre><code class="line-numbers language-matlab">  &gt;&gt; h = imhist(f)</code></pre></li><li><p>也可以用条形图来表示</p><pre><code class="line-numbers language-matlab">&gt;&gt; h = imhist(f,25);&gt;&gt; horz = linespace(0,255,25);&gt;&gt; bar(horz,h)&gt;&gt; axis(0 255 0 60000);&gt;&gt; set(gca, &#39;xtick&#39;, 0:50:255)&gt;&gt; set(gca, &#39;ytick&#39;, 0:20000:60000)</code></pre></li><li><p>杆状图<br><code>stem(horz, z , &#39;LineSpec&#39;, &#39;fill&#39;)</code></p></li><li><p>plot函数<br><code>plot(horz, z, &#39;LineSpec&#39;)</code></p></li><li><p>当处理函数句柄时<br><code>fplot(fhandle, limits, &#39;LineSpec&#39;)</code></p></li></ul></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

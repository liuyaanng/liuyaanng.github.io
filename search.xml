<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode_Day7</title>
      <link href="/2021/03/12/leetcode-day7/"/>
      <url>/2021/03/12/leetcode-day7/</url>
      
        <content type="html"><![CDATA[<h2 id="706-设计哈希映射"><a href="#706-设计哈希映射" class="headerlink" title="[706] 设计哈希映射"></a>[706] 设计哈希映射</h2><p><a href="https://leetcode-cn.com/problems/design-hashmap/description/">https://leetcode-cn.com/problems/design-hashmap/description/</a></p><ul><li>algorithms</li><li>Easy (58.60%)</li><li>Likes:    124</li><li>Dislikes: -</li><li>Total Accepted:    22.7K</li><li>Total Submissions: 38.6K</li><li>Testcase Example:  ‘[“MyHashMap”,”put”,”put”,”get”,”get”,”put”,”get”,”remove”,”get”]\n’ +<br>‘[[],[1,1],[2,2],[1],[3],[2,1],[2],[2],[2]]’</li></ul><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 <code>MyHashMap</code> 类：</p><ul>    <li><code>MyHashMap()</code> 用空映射初始化对象</li>    <li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>    <li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>    <li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li></ul><p> </p><p><strong>示例：</strong></p><pre><strong>输入</strong>：["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"][[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]<strong>输出</strong>：[null, null, null, 1, -1, null, 1, null, -1]<strong>解释</strong>：MyHashMap myHashMap = new MyHashMap();myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</pre><p> </p><p><strong>提示：</strong></p><ul>    <li><code>0 <= key, value <= 10<sup>6</sup></code></li>    <li>最多调用 <code>10<sup>4</sup></code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li></ul><p> </p><p><strong>进阶：</strong>你能否不使用内置的 HashMap 库解决此问题？</p><h3 id="方法1-暴力一维数组"><a href="#方法1-暴力一维数组" class="headerlink" title="方法1: 暴力一维数组"></a>方法1: 暴力一维数组</h3><p>适用于key范围较小的情况</p><pre><code class="line-numbers language-cpp">class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            const int N = 1000001;            data = vector&lt;int&gt;(N, -1); //直接初始化为-1    &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            data[key] = value;    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            return data[key];    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            data[key] = -1;    &#125;private:        vector&lt;int&gt; data;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319103752.png"></p><h3 id="方法2-二维数组-稀疏数组节省空间"><a href="#方法2-二维数组-稀疏数组节省空间" class="headerlink" title="方法2: 二维数组, 稀疏数组节省空间"></a>方法2: 二维数组, 稀疏数组节省空间</h3><p>通过设置两个hash值来避免冲突</p><pre><code class="line-numbers language-cpp">class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            data.resize(N);    &#125;        auto getHashValue1(int key)&#123;            return key % N;        &#125;        auto getHashValue2(int key)&#123;            return key / N;        &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            auto hashkey1 = getHashValue1(key);            auto hashkey2 = getHashValue2(key);            if(data[hashkey1].empty())&#123;                data[hashkey1].resize(N, -1);            &#125;            data[hashkey1][hashkey2] = value;    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            auto hashkey1 = getHashValue1(key);            auto hashkey2 = getHashValue2(key);            if(data[hashkey1].empty())&#123;                return -1;            &#125;            return data[hashkey1][hashkey2];    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            auto hashkey1 = getHashValue1(key);            auto hashkey2 = getHashValue2(key);            if(!data[hashkey1].empty())&#123;                data[hashkey1][hashkey2] = -1;            &#125;    &#125;private:        const int N = 1001;        vector&lt;vector&lt;int&gt;&gt; data;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319110154.png"></p><h3 id="方法3-链地址法1"><a href="#方法3-链地址法1" class="headerlink" title="方法3: 链地址法1"></a>方法3: 链地址法1</h3><p>这是一种处理冲突的方法, 具体原理如图:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/IMG_3726.JPG"></p><p>此方法不使用头节点(dummy head node), 减小空间开销, 但每次都需要判断是否为空节点</p><p>需注意当移除键值对时, 对于头节点与非头节点要分开讨论</p><pre><code class="line-numbers language-cpp">struct MyListNode&#123;    int key;     int val;    MyListNode* next;    MyListNode() : key(-1), val(-1), next(nullptr) &#123;&#125;    MyListNode(int _key, int _val) : key(_key), val(_val), next(nullptr) &#123;&#125;&#125;;class MyHashMap &#123;public:    /** Initialize your data structure here. */    MyHashMap() &#123;            data.resize(N);    &#125;        auto getHashValue(int key)&#123;            return key % N;        &#125;    /** value will always be non-negative. */    void put(int key, int value) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            if(head==nullptr)&#123;                head = new MyListNode(key, value);                return;            &#125;            auto p = head;            auto tail = p;            // add value which has been added            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    p-&gt;val = value;                    return;                &#125;                tail = p;                p = p-&gt;next;            &#125;            // add new value            tail-&gt;next = new MyListNode(key, value);    &#125;    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */    int get(int key) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            if(head==nullptr)&#123;                return -1;            &#125;            auto p = head;            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    return p-&gt;val;                &#125;                p = p-&gt;next;            &#125;            return -1;    &#125;    /** Removes the mapping of the specified value key if this map contains a mapping for the key */    void remove(int key) &#123;            auto hashkey = getHashValue(key);            auto&amp; head = data[hashkey];            if(head==nullptr)&#123;                return;            &#125;            auto p = head;            MyListNode* prev = nullptr;            while(p != nullptr)&#123;                if(p-&gt;key == key)&#123;                    // remove head                    if(prev == nullptr)&#123;                        auto dummy = head;                        head = head-&gt;next; // nullptr                        dummy-&gt;next = nullptr;                        delete dummy;                    &#125;                    else&#123;                        prev-&gt;next = p-&gt;next;                        p-&gt;next = nullptr;                        delete p;                    &#125;                    return;                &#125;                prev = p;                p = p-&gt;next;            &#125;    &#125;private:        const int N = 1001;        vector&lt;MyListNode*&gt; data;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210319120829.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day6</title>
      <link href="/2021/03/11/leetcode-day6/"/>
      <url>/2021/03/11/leetcode-day6/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>示例 1：</p><pre><code class="line-numbers language-cpp">输入：head = [1,3,2]输出：[2,3,1]</code></pre><p>限制：</p><p><code>0 &lt;= 链表长度 &lt;= 10000</code></p><h3 id="方法1-递归"><a href="#方法1-递归" class="headerlink" title="方法1: 递归"></a>方法1: 递归</h3><p>先进行递归至链表尾部, 在回溯的时候, 将值添加入数组, 即可实现逆序输出</p><ul><li>终止条件: 指针 <code>head == None</code> , 代表在链表尾部</li><li>递归进行: <code>head = head-&gt;next</code></li><li>回溯阶段: 将 <code>head-&gt;val</code> 添加至返回数组</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; reversePrint(ListNode* head) &#123;        reverse_array(head);        return res;    &#125;private:    vector&lt;int&gt; res;    void reverse_array(ListNode* head)&#123;        if(head == nullptr) return;               reverse_array(head-&gt;next);        res.push_back(head-&gt;val);        &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311120222.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(N)</code>,  遍历链表，递归N次。</li><li>空间复杂度:    <code>O(N)</code>, 递归需要 <code>O(N)</code> 的栈空间</li></ul><h3 id="方法2-辅助栈法"><a href="#方法2-辅助栈法" class="headerlink" title="方法2: 辅助栈法"></a>方法2: 辅助栈法</h3><p>链表只能从前向后, 而又需要倒序输出, 则可以使用栈来解决</p><ul><li>遍历链表, 将链表值添加入栈中</li><li>将栈顶元素添加至输出数组, 执行出栈操作</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; reversePrint(ListNode* head) &#123;        stack&lt;int&gt; st;        while(head != nullptr)&#123;            st.push(head-&gt;val);            head = head-&gt;next;        &#125;        vector&lt;int&gt; res;        while(!st.empty())&#123;            res.push_back(st.top());            st.pop();        &#125;        return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311162411.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(N)</code>, 入栈出栈时间总和为 <code>O(N)</code></li><li>空间复杂度:  <code>O(N)</code>, </li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day5</title>
      <link href="/2021/03/10/leetcode-day5/"/>
      <url>/2021/03/10/leetcode-day5/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/</a> </p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1：</p><pre><code class="line-numbers language-bash">输入：s = &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot;</code></pre><p>限制：</p><p><code>0 &lt;= s 的长度 &lt;= 10000</code></p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1:"></a>方法1:</h3><p>设置一个新的数组, 将结果存到新数组上.</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    string replaceSpace(string s) &#123;        string res;        for(auto &amp;e: s)&#123;            if(e == &#39; &#39;)&#123;                res += &quot;%20&quot;;            &#125;            else&#123;                res += e;            &#125;        &#125;        return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311114319.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code></li><li>空间复杂度: ‘O(n)’, 需要额外数组来存储</li></ul><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2:"></a>方法2:</h3><p>不创建新数组, 原地扩充</p><p>c++可以通过 <code>array.resize()</code> 来重置数组长度, 利用这一点, 则无需新建数组</p><ul><li>首先遍历原始数组, 统计空格数</li><li>重置数组长度,  新长度为原始长度 + 2 * 空格数</li><li>倒序遍历数组, 遇到空格替换, 否则不变, 直接移到相应位置</li></ul><pre><code class="line-numbers language-cpp">class Solution &#123;public:    string replaceSpace(string s) &#123;        int count = 0, len = s.size();        for(auto &amp;e: s)&#123;            if(e == &#39; &#39;)&#123;                count++;            &#125;        &#125;        s.resize(len + 2 * count);        for(int i = len - 1, j = s.size() - 1; i &lt; j; i--,j--)&#123;            if(s[i] == &#39; &#39;)&#123;                s[j-2] = &#39;%&#39;;                s[j-1] = &#39;2&#39;;                s[j] = &#39;0&#39;;                j -= 2;            &#125;            else&#123;                s[j] = s[i];            &#125;           &#125;          return s;       &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311120222.png"></p><p>复杂度分析: </p><ul><li>时间复杂度:  <code>O(n)</code>  两次遍历数组</li><li>空间复杂度:  <code>O(1)</code> 无额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day4</title>
      <link href="/2021/03/09/leetcode-day4/"/>
      <url>/2021/03/09/leetcode-day4/</url>
      
        <content type="html"><![CDATA[<p>[136] 只出现一次的数字</p><p><a href="https://leetcode-cn.com/problems/single-number/description/">https://leetcode-cn.com/problems/single-number/description/</a></p><ul><li>algorithms</li><li>Easy (70.80%)</li><li>Likes:    1743</li><li>Dislikes: -</li><li>Total Accepted:    348.9K</li><li>Total Submissions: 491.3K</li><li>Testcase Example:  ‘[2,2,1]’</li><li>Source Code:       136.single-number.cpp</li></ul><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><pre><strong>输入:</strong> [2,2,1]<strong>输出:</strong> 1</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入:</strong> [4,1,2,1,2]<strong>输出:</strong> 4</pre><p>方法一: 位运算</p><p>异或运算性质:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311101301.png"></p><p>故将数组内元素依次进行异或运算, 最终的结果即为出现一次的数.</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;            int res = 0;            for(auto e: nums)&#123;                res ^= e;            &#125;            return res;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210311101604.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(n)</code>, 与nums的大小有关, 相当于遍历一遍数组</li><li>空间复杂度: <code>O(1)</code>, 除输出数组外,无额外空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day3</title>
      <link href="/2021/03/08/leetcode-day3/"/>
      <url>/2021/03/08/leetcode-day3/</url>
      
        <content type="html"><![CDATA[<h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="[338] 比特位计数"></a>[338] 比特位计数</h2><p><a href="https://leetcode-cn.com/problems/counting-bits/description/">https://leetcode-cn.com/problems/counting-bits/description/</a></p><ul><li>algorithms</li><li>Medium (76.57%)</li><li>Likes:    664</li><li>Dislikes: -</li><li>Total Accepted:    115.6K</li><li>Total Submissions: 146.3K</li><li>Testcase Example:  ‘2’</li><li>Source Code:       338.counting-bits.cpp</li></ul><p>给定一个非负整数&nbsp;<strong>num</strong>。对于&nbsp;<strong>0 &le; i &le; num </strong>范围中的每个数字&nbsp;<strong>i&nbsp;</strong>，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><pre><strong>输入: </strong>2<strong>输出: </strong>[0,1,1]</pre><p><strong>示例&nbsp;2:</strong></p><pre><strong>输入: </strong>5<strong>输出: </strong><code>[0,1,1,2,1,2]</code></pre><p><strong>进阶:</strong></p><ul>    <li>给出时间复杂度为<strong>O(n*sizeof(integer))</strong>的解答非常容易。但你可以在线性时间<strong>O(n)</strong>内用一趟扫描做到吗？</li>    <li>要求算法的空间复杂度为<strong>O(n)</strong>。</li>    <li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的&nbsp;<strong>__builtin_popcount</strong>）来执行此操作。</li></ul><p>方法1: </p><p>从0到num直接计算1的个数, 计算方法用到了上面的 布赖恩·克尼根算法</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int count_ones(int x)&#123;        int count = 0;        while(x &gt; 0)&#123;            x &amp;= (x - 1);            count++;        &#125;        return count;    &#125;    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            for(int x=0; x &lt;= num; x++)&#123;                result[x] = count_ones(x);            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307234957.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(k*num)</code> , k 为int整型长度(32), </li><li>空间复杂度: <code>O(1)</code> , 除了返回的数组以外，空间复杂度为常数。</li></ul><p>方法2: 动态规划 最高有效位</p><p>对于整数x, 存在一个最大整数y, 且y是2的整数幂, 令 <code>z=y-x</code>, 用 <code>bits[x]</code> 来表示x的’一比特数’, 则 <code>bit[x] = bit[z] + 1 </code>, 这里加的 <code>1</code> 是最高位的1.</p><table><thead><tr><th>x</th><th>1</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>y</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>z=x-y</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p><strong>正整数 <code>y</code> 是 <code>2</code> 的整数次幂，当且仅当 <code>y&amp;(y-1)=0 </code></strong></p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            int highbit = 0;            for(int x=1; x &lt;= num; x++)&#123;                if((x &amp; (x - 1)) == 0)&#123;                    highbit = x;                &#125;                result[x] = result[x - highbit] + 1;            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210308113259.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(num)</code> , 只需要 <code>O(1)</code> 的时间计算</li><li>空间复杂度:  <code>O(1)</code>, 为常数</li></ul><p>方法3: 动态规划 最低有效位</p><p>将x右移一位可得到 $\dfrac{x}{2}$ 的值,</p><table><thead><tr><th>x</th><th>1</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>x/2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p> 反向考虑:</p><p>$$<br>bit[x] = bit[\dfrac{x}{2}] + bit[x]最低位<br>$$</p><p>据此, 合并奇偶情况:</p><p>$$<br>bit[x] = bit[\dfrac{x}{2}] + (x &amp; 1)<br>$$</p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            int highbit = 0;            for(int x=1; x &lt;= num; x++)&#123;                result[x] = result[x&gt;&gt;1] + (x &amp; 1);            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210308115024.png"></p><p>方法4: 动态规划 最低设置位</p><p>定义正整数 <code>x</code> 的「最低设置位」为 <code>x</code> 的二进制表示中的最低的 <code>1</code> 所在位。</p><table><thead><tr><th>1</th><th>0</th><th>1</th><th>0</th></tr></thead></table><p> 最低设置位是 <code>2</code></p><p> 令 <code>y=x&amp;(x-1)</code> , 则y是去除最低设置位后的数, 则 <code>bits[x]=bits[y]+1</code></p><table><thead><tr><th>x</th><th>1</th><th>0</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>x-1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>x&amp;(x-1)</td><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><pre><code class="line-numbers language-cpp">class Solution &#123;public:    vector&lt;int&gt; countBits(int num) &#123;            vector&lt;int&gt; result(num + 1);            int highbit = 0;            for(int x=1; x &lt;= num; x++)&#123;                result[x] = result[x&amp;(x-1)] +1;            &#125;            return result;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210308120402.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day2</title>
      <link href="/2021/03/07/leetcode-day2/"/>
      <url>/2021/03/07/leetcode-day2/</url>
      
        <content type="html"><![CDATA[<h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="[461] 汉明距离"></a>[461] 汉明距离</h2><p><a href="https://leetcode-cn.com/problems/hamming-distance/description/">https://leetcode-cn.com/problems/hamming-distance/description/</a></p><ul><li>algorithms</li><li>Easy (78.70%)</li><li>Likes:    379</li><li>Dislikes: -</li><li>Total Accepted:    97.6K</li><li>Total Submissions: 123.7K</li><li>Testcase Example:  ‘1\n4’</li><li>Source Code:       461.hamming-distance.cpp</li></ul><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p><p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p><p><strong>注意：</strong><br />0 &le; <code>x</code>, <code>y</code> &lt; 2<sup>31</sup>.</p><p><strong>示例:</strong></p><pre><strong>输入:</strong> x = 1, y = 4<strong>输出:</strong> 2<strong>解释:</strong>1   (0 0 0 1)4   (0 1 0 0)       &uarr;   &uarr;上面的箭头指出了对应二进制位不同的位置。</pre><p>方法1:</p><p>计算x与y的XOR值, 值与1进行 <code>&amp;</code> 操作, 结果为1则x与y在此位值不同, 汉明距离+1, 再进行移位操作, 逐位计算即可.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307215223.png"></p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int hammingDistance(int x, int y) &#123;            int z = x ^ y;            int distance = 0;            while(z)&#123;                distance += z &amp; 1;                z = z &gt;&gt; 1;            &#125;            return distance;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307230112.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: O(1), 整数长度固定, 最高32位 </li><li>空间复杂度: O(1), 恒定空间</li></ul><p>方法2: 布赖恩·克尼根算法</p><p>逐位移动，逐位比较边缘位置是否为 1。利用布莱恩·克尼根算法, 遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多. </p><p>当 <code>num &amp; (num - 1)</code> 运算时, 最右边等于1的一位会被抹除</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307225134.png"></p><pre><code class="line-numbers language-cpp">class Solution &#123;public:    int hammingDistance(int x, int y) &#123;            int z = x xor y;            int distance = 0;            while(z)&#123;                distance += 1;                z = z &amp; (z - 1);            &#125;            return distance;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210307230254.png"></p><p>复杂度分析: </p><ul><li>时间复杂度: <code>O(1)</code>, 实际进行了更少的迭代</li><li>空间复杂度:  <code>O(1)</code>, 恒定空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Day1</title>
      <link href="/2021/03/06/leetcode-day1/"/>
      <url>/2021/03/06/leetcode-day1/</url>
      
        <content type="html"><![CDATA[<p>[1] Two Sum  </p><p><a href="https://leetcode.com/problems/two-sum/description/">https://leetcode.com/problems/two-sum/description/</a></p><ul><li>algorithms</li><li>Easy (46.37%)</li><li>Likes:    19171</li><li>Dislikes: 682</li><li>Total Accepted:    3.8M</li><li>Total Submissions: 8.3M</li><li>Testcase Example:  ‘[2,7,11,15]\n9’</li></ul><p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p><p>&nbsp;</p><p><strong>Example 1:</strong></p><pre><strong>Input:</strong> nums = [2,7,11,15], target = 9<strong>Output:</strong> [0,1]<strong>Output:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].</pre><p><strong>Example 2:</strong></p><pre><strong>Input:</strong> nums = [3,2,4], target = 6<strong>Output:</strong> [1,2]</pre><p><strong>Example 3:</strong></p><pre><strong>Input:</strong> nums = [3,3], target = 6<strong>Output:</strong> [0,1]</pre><p>&nbsp;</p><p><strong>Constraints:</strong></p><ul>    <li><code>2 &lt;= nums.length &lt;= 10<sup>3</sup></code></li>    <li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>    <li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>    <li><strong>Only one valid answer exists.</strong></li></ul><p><strong>Approach 1:</strong> Brute Force</p><p>Loop through each element <code>x</code>  and find if there is another value that equals to <code>target - x</code> </p><pre><code class="line-numbers language-c++">class Solution &#123;public:        vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;            vector&lt;int&gt; answer;            int i, j;            for(i = 0; i&lt; nums.size() - 1; i++)&#123;                for(j = i + 1; j &lt; nums.size(); j++)&#123;                    int diff = target - nums[j];                    if(nums[i] == diff)&#123;                        answer.push_back(i);                        answer.push_back(j);                    &#125;                &#125;            &#125;            return answer;    &#125;&#125;;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210211230613.png"></p><p><strong>Complexity Analysis</strong> </p><ul><li>Time Complexity: $O(n^2)$</li><li>Space Complexity: $O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>COC</title>
      <link href="/2021/03/02/coc/"/>
      <url>/2021/03/02/coc/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>FZF</title>
      <link href="/2021/02/28/fzf/"/>
      <url>/2021/02/28/fzf/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/junegunn/fzf">fzf</a> 是一个非常强大的终端文件模糊查找神器,在mac下也有许多优秀的工具,比如mac自带的    <code>spotlight</code> , <a href="https://www.alfredapp.com/">Alfred</a> ,这些工具在桌面环境下非常好用,也十分漂亮,但我的工作一般都在终端下, fzf解决了我的问题. fzf有很多优点,可移植,速度超快,最重要的是,当fzf与 <strong>zsh, ranger, vim</strong> 碰撞在一起,极大的提高了我的工作效率.    </p><h2 id="FZF"><a href="#FZF" class="headerlink" title="FZF"></a>FZF</h2><ul><li>fzf的安装非常简单,在mac下,可以使用<code>Homebrew</code>来安装:</li></ul><pre><code class="line-numbers language-bash">brew install fzf</code></pre><p>现在就可以通过 <code>fzf</code> 命令来使用fzf了</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210301101707.png"></p><p>如果你刚安装完成,你的界面跟上图不一样,没有右侧的预览窗口,别着急,这些是可以在配置文件中修改的.</p><ul><li>如果要安装    <code> key bindings</code> 和 <code>fuzzy completion</code> :</li></ul><pre><code class="line-numbers language-bash">$(brew --prefix)/opt/fzf/install</code></pre><p>一路y,则会在你的根目录下生成 <code>.fzf.bash</code> 和 <code>.fzf.zsh</code> 文件,想要配置fzf,则只需修改相应的文件即可.</p><h2 id="FZF-ZSH-AMAZING"><a href="#FZF-ZSH-AMAZING" class="headerlink" title="FZF + ZSH = AMAZING"></a>FZF + ZSH = AMAZING</h2><p>fzf的配置文件写在 <code>.fzf.zsh</code> 中, 由于我的 <code>zsh</code> 配置文件在 <code>.config/zsh</code> 目录下, 所以我将fzf的配置文件也移到此处</p><pre><code class="line-numbers language-bash">mv ~/.fzf.zsh ~/.config/zsh/fzf.zsh</code></pre><p>下面开始配置 <code>fzf.zsh</code> 文件</p><ul><li>fzf的默认搜索工具: ag</li></ul><pre><code class="line-numbers language-bash">export FZF_DEFAULT_COMMAND=&#39;ag&#39;export FZF_DEFAULT_COMMAND=&#39;ag --hidden --ignore .git -g &quot;&quot;&#39;</code></pre><p>上面两条任选其一, 第二条表示搜索到的文件包含隐藏文件,忽略 <code>.git</code> 文件</p><ul><li>模糊查找补全</li></ul><p>fzf的默认键位为 <code>**</code> ,太麻烦了,换成 <code>\</code> 就舒服多了</p><pre><code class="line-numbers language-bash">export FZF_COMPLETION_TRIGGER=&#39;\&#39;</code></pre><ul><li>预览窗口的实现</li></ul><pre><code class="line-numbers language-bash">export FZF_DEFAULT_OPTS=&#39;--bind ctrl-k:down,ctrl-i:up --preview &quot;[[ $(file --mime &#123;&#125;) =~ binary ]] &amp;&amp; echo &#123;&#125; is a binary file || (ccat --color=always &#123;&#125; || highlight -O ansi -l &#123;&#125; || cat &#123;&#125;) 2&gt; /dev/null | head -500&quot;&#39;</code></pre><p>结合我的vim使用习惯,我将 <code>ctrl + i</code> 设置为向上, <code>ctrl + k</code> 设置为向下</p><p>当然,还有一些其他的配置,这些都可以在fzf的文档里找到.</p><h2 id="FZF-RANGER-EXCELLENT"><a href="#FZF-RANGER-EXCELLENT" class="headerlink" title="FZF + RANGER = EXCELLENT"></a>FZF + RANGER = EXCELLENT</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/ranger.gif"></p><p>fzf 和ranger 结合可直接在ranger下进行文件搜索,直接跳转到文件所在目录</p><ul><li>首先在ranger的配置文件中设置打开fzf搜索的快捷键( <code>ctrl+f</code> )</li></ul><pre><code class="line-numbers language-bash">vim ~/.config/ranger/rc.conf// add the following linemap &lt;C-f&gt; fzf_select</code></pre><ul><li>在 <code>commands.py</code> 中添加    <code>fzf_select</code> 函数</li></ul><pre><code class="line-numbers language-python">class fzf_select(Command):    &quot;&quot;&quot;    :fzf_select    Find a file using fzf.    With a prefix argument select only directories.    See: https://github.com/junegunn/fzf    &quot;&quot;&quot;    def execute(self):        import subprocess        import os.path        if self.quantifier:            # match only directories            command=&quot;find -L . \( -path &#39;*/\.*&#39; -o -fstype &#39;dev&#39; -o -fstype &#39;proc&#39; \) -prune \            -o -type d -print 2&gt; /dev/null | sed 1d | cut -b3- | fzf +m&quot;        else:            # match files and directories            command=&quot;find -L . \( -path &#39;*/\.*&#39; -o -fstype &#39;dev&#39; -o -fstype &#39;proc&#39; \) -prune \            -o -print 2&gt; /dev/null | sed 1d | cut -b3- | fzf +m&quot;        fzf = self.fm.execute_command(command, universal_newlines=True, stdout=subprocess.PIPE)        stdout, stderr = fzf.communicate()        if fzf.returncode == 0:            fzf_file = os.path.abspath(stdout.rstrip(&#39;\n&#39;))            if os.path.isdir(fzf_file):                self.fm.cd(fzf_file)            else:                self.fm.select_file(fzf_file)</code></pre><h2 id="FZF-VIM-UNBELIVABLE"><a href="#FZF-VIM-UNBELIVABLE" class="headerlink" title="FZF + VIM = UNBELIVABLE"></a>FZF + VIM = UNBELIVABLE</h2><p><a href="https://github.com/junegunn/fzf.vim">fzf.vim</a> 是fzf为vim玩家编写的插件</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210301113521.png"></p><p><code>fzf.vim</code> 的 <a href="https://godliuyang.wang/2021/02/20/neovim/#toc-heading-8">详细配置与快捷键设置</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LINUX</title>
      <link href="/2021/02/27/linux/"/>
      <url>/2021/02/27/linux/</url>
      
        <content type="html"><![CDATA[<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><ul><li>添加用户</li></ul><pre><code class="line-numbers language-bash">sudo adduser username</code></pre><ul><li>将用户添加到sudo组</li></ul><pre><code class="line-numbers language-bash">sudo usermod -aG sudo username</code></pre><ul><li>删除用户</li></ul><pre><code class="line-numbers language-bash">sudo deluser username</code></pre><ul><li>删除用户,并删除加目录</li></ul><pre><code class="line-numbers language-bash">sudo deluser --remove-home username</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2021/02/27/git/"/>
      <url>/2021/02/27/git/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Github-Cheat-Sheet"><a href="#1-Github-Cheat-Sheet" class="headerlink" title="1. Github Cheat Sheet"></a>1. Github Cheat Sheet</h1><h2 id="配置工具"><a href="#配置工具" class="headerlink" title="配置工具"></a>配置工具</h2><p>对所有本地仓库的用户信息进行配置</p><ul><li>对你的commit操作设置关联的用户名</li></ul><pre><code class="line-numbers language-bash">$ git config --global user.name &quot;[name]&quot;</code></pre><ul><li>对你的commit操作设置关联的邮箱地址</li></ul><pre><code class="line-numbers language-bash">$ git config --global user.email &quot;[email address]&quot;</code></pre><ul><li>启用有帮助的彩色命令行输出</li></ul><pre><code class="line-numbers language-bash">$ git config --global color.ui auto</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支是使用 Git 工作的一个重要部分。你做的任何提交都会发生在当前“checked out”到的分支上。使用<code>git status</code>查看那是哪个分支。</p><ul><li>创建一个新分支</li></ul><pre><code class="line-numbers language-bash">$ git branch [branch-name]</code></pre><ul><li>切换到指定分支并更新工作目录(working directory)</li></ul><pre><code class="line-numbers language-bash">$ git checkout [branch-name]</code></pre><ul><li>将指定分支的历史合并到当前分支。这通常在拉取请求(PR)中完成，但也是一个重要的 Git 操作。</li></ul><pre><code class="line-numbers language-bash">$ git merge [branch]</code></pre><ul><li>删除指定分支</li></ul><pre><code class="line-numbers language-bash">$ git branch -d [branch-name]</code></pre><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>当着手于一个新的仓库时，你只需创建一次。要么在本地创建，然后推送到 GitHub；要么通过 clone 一个现有仓库。</p><ul><li>初始化仓库</li></ul><pre><code class="line-numbers language-bash">$ git init</code></pre><ul><li>在使用过<code>git init</code> 命令后，使用以下命令将本地仓库与一个 GitHub 上的空仓库连接起来, 即将现在目录转化为一个git仓库</li></ul><pre><code class="line-numbers language-bash">$ git remote add origin [url]</code></pre><ul><li>Clone（下载）一个已存在于 GitHub 上的仓库，包括所有的文件、分支和提交(commits)</li></ul><pre><code class="line-numbers language-bash">$ git clone [url]</code></pre><h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><p>有时一些文件最好不要用 Git 跟踪。这通常在名为<code>.gitignore</code>的特殊文件中完成。你可以在<a href="https://github.com/github/gitignore">github.com/github/gitignore</a> 找到有用的<code>.gitignore</code>文件模板.</p><h2 id="同步更改"><a href="#同步更改" class="headerlink" title="同步更改"></a>同步更改</h2><p>将你本地仓库与 GitHub.com 上的远端仓库同步</p><ul><li>下载远端跟踪分支的所有历史</li></ul><pre><code class="line-numbers language-bash">$ git fetch</code></pre><ul><li>将远端跟踪分支合并到当前本地分支</li></ul><pre><code class="line-numbers language-bash">git merge</code></pre><ul><li>将所有本地分支提交上传到 GitHub</li></ul><pre><code class="line-numbers language-bash">$ git push</code></pre><ul><li>使用来自 GitHub 的对应远端分支的所有新提交更新你当前的本地工作分支。·<code>git pull</code> 是 <code>git fetch</code> 和    <code>git merge</code> 的结合</li></ul><pre><code class="line-numbers language-bash">$ git pull</code></pre><h2 id="进行更改"><a href="#进行更改" class="headerlink" title="进行更改"></a>进行更改</h2><p>浏览并检查项目文件的发展</p><ul><li>列出当前分支的版本历史</li></ul><pre><code class="line-numbers language-bash">$ git log</code></pre><ul><li>列出文件的版本历史，包括重命名</li></ul><pre><code class="line-numbers language-bash">$ git log --follow [file]</code></pre><ul><li>展示两个分支之间的内容差异</li></ul><pre><code class="line-numbers language-bash">$ git diff [first-branch]...[second-branch]</code></pre><ul><li>输出指定commit的元数据和内容变化</li></ul><pre><code class="line-numbers language-bash">$ git show [commit]</code></pre><ul><li>将文件进行快照处理用于版本控制</li></ul><pre><code class="line-numbers language-bash">$ git add [file]</code></pre><ul><li>将文件快照永久地记录在版本历史中</li></ul><pre><code class="line-numbers language-bash">$ git commit -m &quot;[descriptive message]&quot;</code></pre><h2 id="重做提交"><a href="#重做提交" class="headerlink" title="重做提交"></a>重做提交</h2><p>清除错误和构建用于替换的历史</p><ul><li>撤销所有 <code>[commit]</code>  <strong>后</strong>的提交,在本地保存更改</li></ul><pre><code class="line-numbers language-bash">$ git reset [commit]</code></pre><ul><li>放弃所有历史，改回指定提交。</li></ul><pre><code class="line-numbers language-bash">$ git reset --hard [commit]</code></pre><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><ul><li><strong>git</strong> : 一个开源的分布式版本控制系统</li><li><strong>GitHub</strong> : 一个托管和协作管理 Git 仓库的平台</li><li><strong>commit提交</strong> : 一个 Git 对象，是你整个仓库的快照的哈希值</li><li><strong>branch分支</strong> : 一个轻型可移动的 commit 指针</li><li><strong>clone</strong> : 一个仓库的本地版本，包含所有提交和分支</li><li><strong>remote远端</strong> : 一个 GitHub 上的公共仓库，所有小组成员通过它来交换修改</li><li><strong>fork</strong> : 一个属于另一用户的 GitHub 上的仓库的副本</li><li><strong>pull request 拉取请求</strong>: 一处用于比较和讨论分支上引入的差异，且具有评审、评论、集成测试等功能的地方</li><li><strong>HEAD</strong> : 代表你当前的工作目录。使用git checkout 可移动 HEAD 指针到不同的分支、标记(tags)或提交</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Neovim</title>
      <link href="/2021/02/20/neovim/"/>
      <url>/2021/02/20/neovim/</url>
      
        <content type="html"><![CDATA[<p>本文是为了方便记忆vim插件的一些快捷键。这是我的配置地址：<a href="https://github.com/liuyaanng/nvim">nvim</a>, 该配置在你装完neovim之后，打开neovim后会自动安装插件，你需要修改的地方是下图中python位置以及markdown预览插件中的默认浏览器。<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Neovim/1.jpg"> </p><p>我的vim插件大部分来自于一位大佬<a href="https://github.com/theniceboy">theniceboy</a>, 他在B站上出了很多包括vim, ranger, i3, dwm等等教程, 这是他的B站地址：<a href="https://space.bilibili.com/13081489?from=search&seid=4240676561582012103">theCW</a> </p><h2 id="1-Install-Neovim"><a href="#1-Install-Neovim" class="headerlink" title="1. Install Neovim"></a>1. Install Neovim</h2><p><a href="https://github.com/neovim/neovim/wiki/Installing-Neovim">Install Guide</a> </p><h2 id="2-有用的工具"><a href="#2-有用的工具" class="headerlink" title="2. 有用的工具"></a>2. 有用的工具</h2><ul><li>figlet</li></ul><pre><code class="line-numbers language-bash">brew install figlet</code></pre><h2 id="3-Vim基础快捷键"><a href="#3-Vim基础快捷键" class="headerlink" title="3. Vim基础快捷键"></a>3. Vim基础快捷键</h2><p>这里<code>&lt;LEADER&gt;</code>就是空格键</p><ul><li>基础快捷键</li></ul><pre><code class="line-numbers language-vim">- &#39;;&#39; :Save &amp; quit- &#39;Q&#39; quit- &#39;ctrl_q&#39; Exit Vim, unless there are some buffers which have been changed.- &#39;S&#39; save- &#39;&lt;LEADER&gt;rc&#39; open vimrcUndo -    `l` undo- &#39;Y&#39; Visual Mode : copy to system clipboard      Normal Mode : copy till the end of the line.- &#39;&gt;&#39; right indent- &#39;&lt;&#39; left indentSearch- &#39;&lt;LEADER&gt;&lt;CR&gt;&#39; highlight off- &#39;=&#39; next- &#39;-&#39; last- &#39;&lt;LEADER&gt;dw&#39; adjacent duplicate wordsSpace to Tab- &#39;&lt;LEADER&gt;tt&#39; turn space to tabFolding- &#39;&lt;LEADER&gt;o&#39; foldingLazyGit- &#39;\g&#39; :Git- &#39;ctrl_g&#39; open lazygitCursor Movement&quot;     ^&quot;     u&quot; &lt; n   i &gt;&quot;     e&quot;     v- &#39;u&#39; up- &#39;e&#39; down- &#39;n&#39; left- &#39;i&#39; right- &#39;N&#39; go to the start of the line- &#39;I&#39; go to the end of the line- &#39;\v&#39; choose current line- &#39;w&#39; go to the next word or sign- &#39;b&#39; go to the last word or sign- &#39;h&#39; go to the next end of word- &#39;ctrl_U&#39; move up the view port without moving the cursor- &#39;ctrl_E&#39; move down the view port without moving the cursor- &#39;ctrl_a&#39; Insert Mode: move to the end of current line           Command Mode: move to the start of command lineCommand Mode Cursor Movement - &#39;ctrl_a&#39; move to the start of command line- &#39;ctrl_e&#39; move to the end of command line- &#39;ctrl_p&#39; move up- &#39;ctrl_n&#39; move down - &#39;ctrl_b&#39; move left- &#39;ctrl_f&#39; move right- &#39;alt_b&#39; move to last word- &#39;alt_w&#39; move to next wordSplit the screen- &#39;su&#39; to up- &#39;se&#39; to down- &#39;sn&#39; to left- &#39;si&#39; to rightWindow management- &#39;&lt;LEADER&gt;w&#39; go to last window- &#39;&lt;LEADER&gt;u&#39; up- &#39;&lt;LEADER&gt;e&#39; down- &#39;&lt;LEADER&gt;n&#39; left- &#39;&lt;LEADER&gt;i&#39; right- &#39;sh&#39; place the two windows up and down- &#39;sv&#39; place the two windows left and right- &#39;&lt;LEADER&gt;q&#39; close the window below the current window- &#39;qf&#39; close current windowRotate screen- &#39;srh&#39; horizontal rotate- &#39;srv&#39; vertical rotateResize splits- &#39;&lt;up&gt;&#39; increase horizontal size- &#39;&lt;down&gt;&#39; decrease horizontal size- &#39;&lt;left&gt;&#39; decrease vertical size- &#39;&lt;right&gt;&#39; increase vertical sizeTab management- &#39;tu&#39; create a new tab- &#39;tn&#39; move to left tab- &#39;ti&#39; move to right tab- &#39;tmn&#39; move current tab to left- &#39;tmi&#39; move current tab to right- &#39;&lt;LEADER&gt;/&#39; open a terminal window- &#39;tx&#39; use &#39;figlet&#39; to generate words- &#39;\s&#39; find and replace</code></pre><h2 id="4-Vim-插件"><a href="#4-Vim-插件" class="headerlink" title="4. Vim 插件"></a>4. Vim 插件</h2><h3 id="Pretty-Dress"><a href="#Pretty-Dress" class="headerlink" title="Pretty Dress"></a>Pretty Dress</h3><ul><li><a href="https://github.com/bling/vim-bufferline">vim-bufferline</a> </li><li><a href="https://github.com/bpietravalle/vim-bolt">vim-bolt</a> </li><li><a href="https://github.com/ajmwagar/vim-deus">vim-deus</a> </li></ul><h3 id="Status-line"><a href="#Status-line" class="headerlink" title="Status line"></a>Status line</h3><ul><li><a href="https://github.com/theniceboy/eleline.vim">lelline</a> </li><li><a href="https://github.com/ojroques/vim-scrollstatus">vim-scrollstatus</a> </li></ul><h3 id="General-Highlight"><a href="#General-Highlight" class="headerlink" title="General Highlight"></a>General Highlight</h3><ul><li><a href="https://github.com/RRethy/vim-hexokinase">vim-hexokinase</a> </li><li><a href="https://github.com/RRethy/vim-illuminate">vim-illuminate</a> </li></ul><h3 id="File-navigation"><a href="#File-navigation" class="headerlink" title="File navigation"></a>File navigation</h3><ul><li><p><a href="https://github.com/Yggdroot/LeaderF">LeaderF</a> </p></li><li><p><a href="https://github.com/junegunn/fzf.vim">fzf.vim</a><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210301113521.png"></p><ul><li><p><a href="https://github.com/junegunn/fzf/blob/master/README-VIM.md">fzf.vim README</a> </p></li><li><p>安装</p><pre><code class="line-numbers language-vim">Plug &#39;junegunn/fzf.vim&#39;</code></pre><p>配置</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === FZF&quot; ===set rtp+=/usr/local/opt/fzf&quot; set rtp+=/home/linuxbrew/.linuxbrew/opt/fzf&quot; noremap &lt;silent&gt; &lt;C-p&gt; :Files&lt;CR&gt;noremap &lt;silent&gt; &lt;C-p&gt; :Leaderf file&lt;CR&gt;noremap &lt;silent&gt; &lt;C-f&gt; :Rg&lt;CR&gt;noremap &lt;silent&gt; &lt;C-h&gt; :History&lt;CR&gt;&quot;noremap &lt;C-t&gt; :BTags&lt;CR&gt;noremap &lt;silent&gt; &lt;C-l&gt; :Lines&lt;CR&gt;noremap &lt;silent&gt; &lt;C-w&gt; :Buffers&lt;CR&gt;noremap &lt;leader&gt;; :History:&lt;CR&gt;let g:fzf_preview_window = &#39;right:60%&#39;let g:fzf_commits_log_options = &#39;--graph --color=always --format=&quot;%C(auto)%h%d %s %C(black)%C(bold)%cr&quot;&#39;function! s:list_buffers()  redir =&gt; list  silent ls  redir END  return split(list, &quot;\n&quot;)endfunctionfunction! s:delete_buffers(lines)  execute &#39;bwipeout&#39; join(map(a:lines, &#123;_, line -&gt; split(line)[0]&#125;))endfunctioncommand! BD call fzf#run(fzf#wrap(&#123;  \ &#39;source&#39;: s:list_buffers(),  \ &#39;sink*&#39;: &#123; lines -&gt; s:delete_buffers(lines) &#125;,  \ &#39;options&#39;: &#39;--multi --reverse --bind ctrl-a:select-all+accept&#39;\ &#125;))noremap &lt;c-d&gt; :BD&lt;CR&gt;let g:fzf_layout = &#123; &#39;window&#39;: &#123; &#39;width&#39;: 0.9, &#39;height&#39;: 0.8 &#125; &#125;</code></pre><p>快捷键:    </p></li><li><p><code>ctrl_f</code> 查找文件</p></li><li><p><code>ctrl_p</code> 使用 <code>LeaderF</code> 查找当前目录下的文件</p></li><li><p><code>ctrl_l</code> 查找当前文件的行</p></li><li><p><code>ctrl_h</code> 打开文件浏览历史</p></li><li><p><code>ctrl_w</code> 打开buffer</p></li><li><p><code>ctrl_d</code> 选择关闭指定的buffer</p></li></ul></li><li><p><a href="https://github.com/kevinhwang91/rnvimr">rnvimr</a> 在vim下使用ranger</p><p>  配置 </p><pre><code class="line-numbers language-vim">&quot; ===&quot; === rnvimr&quot; ===let g:rnvimr_ex_enable = 1let g:rnvimr_pick_enable = 1let g:rnvimr_draw_border = 0&quot; Change the border&#39;s colorlet g:rnvimr_border_attr = &#123;&#39;fg&#39;: 14, &#39;bg&#39;: -1&#125;&quot; Add a shadow window, value is equal to 100 will disable shadowlet g:rnvimr_shadow_winblend = 70&quot; let g:rnvimr_bw_enable = 1highlight link RnvimrNormal CursorLinennoremap &lt;silent&gt; R :RnvimrToggle&lt;CR&gt;&lt;C-\&gt;&lt;C-n&gt;:RnvimrResize 0&lt;CR&gt;let g:rnvimr_action = &#123;                        \ &#39;&lt;C-t&gt;&#39;: &#39;NvimEdit tabedit&#39;,                        \ &#39;&lt;C-x&gt;&#39;: &#39;NvimEdit split&#39;,                        \ &#39;&lt;C-v&gt;&#39;: &#39;NvimEdit vsplit&#39;,                        \ &#39;gw&#39;: &#39;JumpNvimCwd&#39;,                        \ &#39;yw&#39;: &#39;EmitRangerCwd&#39;                        \ &#125;let g:rnvimr_layout = &#123; &#39;relative&#39;: &#39;editor&#39;,                        \ &#39;width&#39;: &amp;columns,                        \ &#39;height&#39;: &amp;lines,                        \ &#39;col&#39;: 0,                        \ &#39;row&#39;: 0,                        \ &#39;style&#39;: &#39;minimal&#39; &#125;let g:rnvimr_presets = [&#123;&#39;width&#39;: 0.8, &#39;height&#39;: 0.8&#125;]</code></pre><p>  快捷键</p><ul><li><code>R</code> 打开ranger</li></ul></li><li><p><a href="https://github.com/airblade/vim-rooter">vim-rooter</a> :自动将vim的工作目录到项目的根目录.</p><p>  <code>Rooter changes the working directory to the project root when you open a file or directory.</code></p><p>  对比:<br>  原文件目录:</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302121823.png"></p><p>  关闭rooter: 在vim里打开一个文件,此时vim的工作目录依旧是原文件所在目录</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302122402.png"></p><p>  启用rooter: 打开文件,vim的工作目录会切换到文件的根目录</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302122752.png"></p><p>  配置</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === vim-rooter&quot; ===let g:rooter_patterns = [&#39;__vim_project_root&#39;, &#39;.git/&#39;]let g:rooter_silent_chdir = 1</code></pre><p>  默认打开 <code>rooter</code></p></li><li><p><a href="https://github.com/pechorin/any-jump.vim">any-jump</a> </p><p>  用法: 在 <code>normal</code> 和 <code>visual</code> 模式下都可用. 只需要将光标放到想要查找的单词上,这个单词可以是 <code>变量</code>, <code>类</code>, <code>常量</code>, <code>名称</code>, <code>符号</code> ( <code>variable/class/constant/name/symbol</code> ) 然后按下 <code>&lt;LEADER&gt;j</code> 即可.</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302124051.png"></p><p>  配置</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === any-jump&quot; ===nnoremap &lt;LEADER&gt;j :AnyJump&lt;CR&gt;let g:any_jump_window_width_ratio  = 0.8let g:any_jump_window_height_ratio = 0.9</code></pre><p>  快捷键</p><ul><li><code>&lt;LEADER&gt;j</code> search </li></ul></li></ul><h3 id="Taglist"><a href="#Taglist" class="headerlink" title="Taglist"></a>Taglist</h3><ul><li><p><a href="https://github.com/liuchengxu/vista.vim">Vista.vim</a>  </p><p>  这是一款查看LSP符号,标签的插件,可配合多个vim插件使用</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302125525.png"></p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === Vista.vim&quot; ===noremap &lt;LEADER&gt;v :Vista coc&lt;CR&gt;noremap &lt;c-t&gt; :silent! Vista finder coc&lt;CR&gt;let g:vista_icon_indent = [&quot;╰─▸ &quot;, &quot;├─▸ &quot;]let g:vista_default_executive = &#39;ctags&#39;let g:vista_fzf_preview = [&#39;right:50%&#39;]let g:vista#renderer#enable_icon = 1let g:vista#renderer#icons = &#123;\   &quot;function&quot;: &quot;\uf794&quot;,\   &quot;variable&quot;: &quot;\uf71b&quot;,\  &#125;let g:scrollstatus_size = 15</code></pre><p>  快捷键:</p><ul><li><p><code>&lt;LEADER&gt;v</code> 打开vista面板</p></li><li><p><code>&lt;ctrl-t&gt;</code>  使用fzf查找名称</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302133944.png"></p></li></ul></li></ul><h3 id="Auto-Complete"><a href="#Auto-Complete" class="headerlink" title="Auto Complete"></a>Auto Complete</h3><ul><li><p><a href="https://github.com/neoclide/coc.nvim">coc</a> </p><p>  <a href="">详细配置教程</a> </p></li><li><p><a href="https://github.com/wellle/tmux-complete.vim">tmux-complete.vim</a> </p><p>  在临近的tmux窗格中启动单词的自动补全</p><h3 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a>Snippets</h3></li><li><p><a href="https://github.com/honza/vim-snippets">vim-snippets</a>     </p><p>  快速补全工具,非常强大</p></li></ul><h3 id="Ubdo-Tree"><a href="#Ubdo-Tree" class="headerlink" title="Ubdo Tree"></a>Ubdo Tree</h3><ul><li><p><a href="https://github.com/mbbill/undotree">undotree</a></p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302154803.png"></p><p>  配置: </p><pre><code class="line-numbers language-vim">&quot; ===&quot; === Undotree&quot; ===noremap L :UndotreeToggle&lt;CR&gt;let g:undotree_DiffAutoOpen = 1let g:undotree_SetFocusWhenToggle = 1let g:undotree_ShortIndicators = 1let g:undotree_WindowLayout = 2let g:undotree_DiffpanelHeight = 8let g:undotree_SplitWidth = 24function g:Undotree_CustomMap()    nmap &lt;buffer&gt; u &lt;plug&gt;UndotreeNextState    nmap &lt;buffer&gt; e &lt;plug&gt;UndotreePreviousState    nmap &lt;buffer&gt; U 5&lt;plug&gt;UndotreeNextState    nmap &lt;buffer&gt; E 5&lt;plug&gt;UndotreePreviousStateendfunc</code></pre><p>  快捷键:</p><ul><li><code>L</code>  打开undotree 面板</li></ul></li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li><p><a href="https://github.com/gisphm/vim-gitignore">vim-gitignore</a>:<br>  提供 <code>.gitignore</code> 文件高亮显示</p></li><li><p><a href="https://github.com/fszymanski/fzf-gitignore">fzf-gitignore</a>:  生成 <code>.gitignore</code> 文件</p><p>  配置:</p><pre><code class="line-numbers language-vim">noremap &lt;LEADER&gt;gi :FzfGitignore&lt;CR&gt;</code></pre><p>  快捷键:</p><ul><li><code>&lt;LEADER&gt;gi</code> 生成 <code>.gitignore</code> 文件</li></ul></li><li><p><a href="https://github.com/akiomik/git-gutter-vim">vim-gitgutter</a>:<br>  一个保存文件后能看到状态的插件</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302164010.png"></p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ==&quot; == GitGutter&quot; ==&quot; let g:gitgutter_signs = 0let g:gitgutter_sign_allow_clobber = 0let g:gitgutter_map_keys = 0let g:gitgutter_override_sign_column_highlight = 0let g:gitgutter_preview_win_floating = 1let g:gitgutter_sign_added = &#39;▎&#39;let g:gitgutter_sign_modified = &#39;░&#39;let g:gitgutter_sign_removed = &#39;▏&#39;let g:gitgutter_sign_removed_first_line = &#39;▔&#39;let g:gitgutter_sign_modified_removed = &#39;▒&#39;&quot; autocmd BufWritePost * GitGutternnoremap &lt;LEADER&gt;gf :GitGutterFold&lt;CR&gt;nnoremap H :GitGutterPreviewHunk&lt;CR&gt;nnoremap &lt;LEADER&gt;g- :GitGutterPrevHunk&lt;CR&gt;nnoremap &lt;LEADER&gt;g= :GitGutterNextHunk&lt;CR&gt;</code></pre><p>  快捷键:</p><ul><li><p><code>&lt;LEADER&gt;gf</code> 折叠</p></li><li><p><code>H</code> 预览当前文件块</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302164503.png"></p></li><li><p><code>&lt;LEADER&gt;g-</code> 上一块</p></li><li><p><code>&lt;LEADER&gt;g+</code> 下一块</p></li></ul></li><li><p><a href="https://github.com/cohama/agit.vim">agit</a>: 轻松查看git提交记录以及做出的更改</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210302164810.png"></p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === Agit&quot; ===nnoremap &lt;LEADER&gt;gl :Agit&lt;CR&gt;let g:agit_no_default_mappings = 1</code></pre><p>  快捷键:</p><ul><li><code>&lt;LEADER&gt;gl</code> 查看git提交记录</li></ul></li></ul><h3 id="Autoformat"><a href="#Autoformat" class="headerlink" title="Autoformat"></a>Autoformat</h3><ul><li><p><a href="https://github.com/Chiel92/vim-autoformat">vim-autoformat</a>: 一键格式化代码</p><p>  配置:</p><pre><code class="line-numbers language-vim">&quot; ===&quot; === AutoFormatr&quot; ===nnoremap \f :Autoformat&lt;CR&gt;let g:formatdef_custom_js = &#39;&quot;js-beautify -t&quot;&#39;let g:formatters_javascript = [&#39;custom_js&#39;]au BufWrite *.js :Autoformat</code></pre><p>  快捷键:</p><ul><li><code>\f</code> 一键格式化代码</li></ul></li></ul><h3 id="HTML-CSS-JS-TypeScript-JSON-etc"><a href="#HTML-CSS-JS-TypeScript-JSON-etc" class="headerlink" title="HTML CSS JS TypeScript JSON, etc"></a>HTML CSS JS TypeScript JSON, etc</h3><ul><li><p><a href="https://github.com/leshill/vim-json">vim-json</a>: 提供json数据的高亮显示</p></li><li><p><a href="https://github.com/neoclide/jsonc.vim">jsonc.vim</a> : 支持 <code>jsonc</code> 语法</p></li><li><p><a href="https://github.com/othree/html5.vim">html5.vim</a> : 提供H5高亮和补全</p></li><li><p><a href="https://github.com/alvan/vim-closetag">vim-closetag</a> : 快速书写 <code>html</code> 的标签</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-colsetag.gif"></p><p>  注意: 下面的标签不适用</p><pre><code class="line-numbers language-html">&lt;area&gt;, &lt;base&gt;, &lt;br&gt;, &lt;col&gt;, &lt;command&gt;, &lt;embed&gt;, &lt;hr&gt;, &lt;img&gt;,&lt;input&gt;, &lt;keygen&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;param&gt;, &lt;source&gt;, &lt;track&gt;, &lt;wbr&gt;,&lt;menuitem&gt;</code></pre><p>  快捷键: </p><ul><li><code>&gt;</code> </li><li><code>&gt;&gt;</code> </li></ul></li><li><p><a href="https://github.com/coolwanglu/vim.js">vim-js</a> : 支持JS语法</p></li><li><p><a href="https://github.com/HerringtonDarkholme/yats.vim">yats.vim</a> : 支持 <code>TypeScript</code> 语法</p></li><li><p><a href="https://github.com/posva/vim-vue">vim-vue</a> : 支持vue</p></li></ul><h3 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h3><ul><li><a href="https://github.com/fatih/vim-go">vim-go</a> 支持Go语言</li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><p><a href="https://github.com/Vimjas/vim-python-pep8-indent">vim-python-pep8-indent</a> : 调整vim的缩进以符合 <a href="https://www.python.org/dev/peps/pep-0008/">pep8</a> 规范</p></li><li><p><a href="https://github.com/tweekmonster/braceless.vim">braceless.vim</a> : 包含一些有用的快捷键, 在这里只配置函数主体高亮</p><p>  配置:</p><pre><code class="line-numbers language-vim">autocmd FileType python BracelessEnable +highlight-cc2</code></pre><p>  快捷键:</p><ul><li>Moving to recognized blocks is done with <code>[[</code> and <code>]]</code>. In Python, <code>[m</code> and <code>]m</code> moves to def and class blocks, while <code>[M</code> and <code>]M</code> moves to the end of those blocks.</li><li><code>zc</code> 折叠</li><li><code>zR</code> 取消折叠</li></ul></li></ul><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><ul><li><p><a href="https://github.com/iamcco/markdown-preview.nvim">markdown-preview</a> 这是一个实时预览markdown文件的插件, markdown 文件按<code>r</code>即可实时预览</p></li><li><p><a href="https://github.com/dhruvasagar/vim-table-mode">vim-table-mode</a> : md文件快速创建表格</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-table-mode.gif"><br>  配置:</p><pre><code class="line-numbers language-vim">&quot;let g:table_mode_disable_mappings = 1let g:table_mode_cell_text_object_i_map = &#39;k&lt;Bar&gt;&#39;</code></pre><p>  快捷键: </p><ul><li><code>&lt;LEADER&gt;tm</code>:  打开/关闭    <code>table-mode</code></li></ul></li><li><p><a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc</a> : 一键生成TOC</p></li><li><p><a href="https://github.com/dkarter/bullets.vim">bullets.vim</a> </p></li></ul><h3 id="Editor-Enhancement"><a href="#Editor-Enhancement" class="headerlink" title="Editor Enhancement"></a>Editor Enhancement</h3><ul><li><p><a href="https://github.com/jiangmiao/auto-pairs">auto-pairs</a> : 成对添加或删除括号, 引号</p></li><li><p><a href="https://github.com/mg979/vim-visual-multi">vim-visual-multi</a></p></li><li><p><a href="https://github.com/tomtom/tcomment_vim">tcomment_vim</a> :快速注释内容</p><p>  配置:</p><pre><code class="line-numbers language-vim">let g:tcomment_textobject_inlinecomment = &#39;&#39;nmap &lt;LEADER&gt;cn g&gt;cvmap &lt;LEADER&gt;cn g&gt;nmap &lt;LEADER&gt;cu g&lt;cvmap &lt;LEADER&gt;cu g&lt;</code></pre><p>  快捷键:</p><ul><li><code>&lt;leader&gt;cn</code> 注释</li><li><code>&lt;leader&gt;cu</code> 取消注释</li></ul></li><li><p><a href="https://github.com/LIUYAANNG/ANTOVIM">ANTOVIM</a> : 一键改变 <code>TRUE</code> 和 <code>FALSE</code></p><p>  快捷键:</p><ul><li><code>gs</code> 切换</li></ul></li><li><p><a href="https://github.com/tpope/vim-surround">vim-surround</a> </p><p>  快捷键:</p><ul><li><code>yskw&#39;</code> 在所选单词两边添加 <code>&#39;</code> : <code>word</code> to <code>&#39;word&#39;</code></li><li><code>cd&#39;&quot;</code> 将单词两边的 <code>&#39;&#39;</code> 变成    <code>&quot;&quot;</code> : <code>&#39;word&#39;</code> to <code>&quot;word&quot;</code></li></ul></li><li><p><a href="https://github.com/gcmt/wildfire.vim">wildfire.vim</a> : 选中特殊符号包裹的文字</p><p>  快捷键:</p><ul><li><p>在 <code>Visual Mode</code> 下, 使用 <code>k&#39;</code> 会选中被 <code>&#39;&#39;</code>包裹的文字, 同样的    <code>k), k&#125;, k]</code> 也适用</p><p>注意: 仓库wiki中快捷键是 <code>i&#39;</code>, 因为我做了按键映射, 将 <code>i</code> 映射到 <code>k</code> 上了</p></li></ul></li><li><p><a href="https://github.com/godlygeek/tabular">tabular</a> : 快速对齐文本</p><p>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-tabular.gif"></p><p>  快捷键:</p><ul><li><code>ga</code> + 对齐的参照物, 如: <code>:</code>, <code>=</code></li></ul></li><li><p><a href="https://github.com/tpope/vim-capslock">vim-capslock</a> : 大写锁定</p><p>  快捷键:</p><ul><li><code>Insert Mode</code> : <code>ctrl_C</code> </li><li><code>Normal Mode</code> : <code>gC</code></li></ul></li><li><p><a href="https://github.com/easymotion/vim-easymotion">vim-easymotion</a>  待完善</p></li><li><p><a href="https://github.com/svermeulen/vim-subversive">vim-subversive</a><br>  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/vim-subversive.gif"></p></li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> neovim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-CLI</title>
      <link href="/2021/02/10/leetcode-cli/"/>
      <url>/2021/02/10/leetcode-cli/</url>
      
        <content type="html"><![CDATA[<p>由于我有长期使vim的习惯, 在刷leetcode题时,在网页上写代码实在是有点难受, <a href="https://github.com/skygragon/leetcode-cli">LeetCode-cli</a> 完美解决了我的问题. </p><p>leetcode支持本地缓存题目,写代码,测试以及提交到<code>leetcode.com</code>.</p><p><img loading="lazy" src="https://github.com/skygragon/leetcode-cli/raw/master/docs/screenshots/intro.2018.01.13.gif" alt="LeetCode-cli">     </p><p>下面记录一下配置<code>leetcode-cli</code></p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><ul><li>下载稳定版本,并非开发版本. <a href="https://skygragon.github.io/leetcode-cli/install">Install guide</a> <pre><code class="line-numbers language-bash">npm install -g leetcode-cli</code></pre></li></ul><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>所有用法wiki介绍的很详细, 自己探索吧哈哈哈! </p><p>后续发现什么骚操作了再来这里分享</p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><p><strong>一:  连接不到<code>leetcode</code>和<code>leetcode.cn</code>服务器,都会报<code>invalid password</code>的<code>error</code></strong><br>解决方案如下:  参考<br><a href="https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/478#issuecomment-564757098">https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/478#issuecomment-564757098</a> </p><ol><li>确保已安装<code>Node.js 8+</code></li><li><pre><code class="line-numbers language-bash"># to remove the old versionnpm uninstall -g leetcode-cli# to install the up-to-date version(2.6.17+)npm install -g leetcode-tools/leetcode-cli</code></pre>使用<code>leetcode version</code>确保版本2.6.17+    </li><li>使用<code>cookie</code>登陆<br>这个版本中包含了很多种登陆方式    </li></ol><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210222559.png"><br>若使用账号密码无法登陆,可尝试使用<code>Cookie</code>登陆, 具体方式如下:<br>以<code>chrome</code>浏览器为例:    </p><ul><li><p>登陆<a href="">leetcode</a> , 打开 <strong><code>检查</code></strong><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210223002.png"></p></li><li><p>选择 <code>network</code> -&gt; <code>XHR</code> -&gt; <code>search</code> -&gt; <code>uid</code> -&gt; <code>all/</code><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210223441.png"></p></li><li><p>使用<code>leetcode user -c</code>, 输入<code>user</code>, 再将<code>cookie</code>粘贴就ok了<img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/img/20210210231428.png"></p></li></ul><p><strong>2. 使用<code>leetcode.cn</code>, 用<code>leetcode show</code>命令出现<code>http error</code></strong><br>解决办法: 参考<a href="https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/489">https://github.com/LeetCode-OpenSource/vscode-leetcode/issues/489</a> </p><ul><li>找到<code>leetcode.cn.js</code>文件, <strong>MacOS</strong> 一般在<code>/usr/local/lib/node_modules/vsc-leetcode-cli/lib/plugins/leetcode.cn.js</code></li><li>替换成以下代码:</li></ul><pre><code class="line-numbers language-js">&#39;use strict&#39;var request = require(&#39;request&#39;);var config = require(&#39;../config&#39;);var h = require(&#39;../helper&#39;);var log = require(&#39;../log&#39;);var Plugin = require(&#39;../plugin&#39;);var session = require(&#39;../session&#39;);//// [Usage]//// https://github.com/skygragon/leetcode-cli-plugins/blob/master/docs/leetcode.cn.md//var plugin = new Plugin(15, &#39;leetcode.cn&#39;, &#39;2018.11.25&#39;,    &#39;Plugin to talk with leetcode-cn APIs.&#39;);plugin.init = function() &#123;  config.app = &#39;leetcode.cn&#39;;  config.sys.urls.base            = &#39;https://leetcode-cn.com&#39;;  config.sys.urls.login           = &#39;https://leetcode-cn.com/accounts/login/&#39;;  config.sys.urls.problems        = &#39;https://leetcode-cn.com/api/problems/$category/&#39;;  config.sys.urls.problem         = &#39;https://leetcode-cn.com/problems/$slug/description/&#39;;  config.sys.urls.graphql         = &#39;https://leetcode-cn.com/graphql&#39;;  config.sys.urls.problem_detail  = &#39;https://leetcode-cn.com/graphql&#39;;  config.sys.urls.test            = &#39;https://leetcode-cn.com/problems/$slug/interpret_solution/&#39;;  config.sys.urls.session         = &#39;https://leetcode-cn.com/session/&#39;;  config.sys.urls.submit          = &#39;https://leetcode-cn.com/problems/$slug/submit/&#39;;  config.sys.urls.submissions     = &#39;https://leetcode-cn.com/api/submissions/$slug&#39;;  config.sys.urls.submission      = &#39;https://leetcode-cn.com/submissions/detail/$id/&#39;;  config.sys.urls.verify          = &#39;https://leetcode-cn.com/submissions/detail/$id/check/&#39;;  config.sys.urls.favorites       = &#39;https://leetcode-cn.com/list/api/questions&#39;;  config.sys.urls.favorite_delete = &#39;https://leetcode-cn.com/list/api/questions/$hash/$id&#39;;&#125;;// FIXME: refactor those// update options with user credentialsfunction signOpts(opts, user) &#123;  opts.headers.Cookie = &#39;LEETCODE_SESSION=&#39; + user.sessionId +                        &#39;;csrftoken=&#39; + user.sessionCSRF + &#39;;&#39;;  opts.headers[&#39;X-CSRFToken&#39;] = user.sessionCSRF;  opts.headers[&#39;X-Requested-With&#39;] = &#39;XMLHttpRequest&#39;;&#125;function makeOpts(url) &#123;  const opts = &#123;&#125;;  opts.url = url;  opts.headers = &#123;&#125;;  if (session.isLogin())    signOpts(opts, session.getUser());  return opts;&#125;function checkError(e, resp, expectedStatus) &#123;  if (!e &amp;&amp; resp &amp;&amp; resp.statusCode !== expectedStatus) &#123;    const code = resp.statusCode;    log.debug(&#39;http error: &#39; + code);    if (code === 403 || code === 401) &#123;      e = session.errors.EXPIRED;    &#125; else &#123;      e = &#123;msg: &#39;http error&#39;, statusCode: code&#125;;    &#125;  &#125;  return e;&#125;plugin.getProblems = function(cb) &#123;  plugin.next.getProblems(function(e, problems) &#123;    if (e) return cb(e);    plugin.getProblemsTitle(function(e, titles) &#123;      if (e) return cb(e);      problems.forEach(function(problem) &#123;        const title = titles[problem.id];        if (title)          problem.name = title;      &#125;);      return cb(null, problems);    &#125;);  &#125;);&#125;;plugin.getProblemsTitle = function(cb) &#123;  log.debug(&#39;running leetcode.cn.getProblemNames&#39;);  const opts = makeOpts(config.sys.urls.graphql);  opts.headers.Origin = config.sys.urls.base;  opts.headers.Referer = &#39;https://leetcode-cn.com/api/problems/algorithms/&#39;;  opts.json = true;  opts.body = &#123;    query: [      &#39;query getQuestionTranslation($lang: String) &#123;&#39;,      &#39;  translations: allAppliedQuestionTranslations(lang: $lang) &#123;&#39;,      &#39;    title&#39;,      &#39;    questionId&#39;,      &#39;  &#125;&#39;,      &#39;&#125;&#39;,      &#39;&#39;    ].join(&#39;\n&#39;),    variables:     &#123;&#125;,    operationName: &#39;getQuestionTranslation&#39;  &#125;;  const spin = h.spin(&#39;Downloading questions titles&#39;);  request.post(opts, function(e, resp, body) &#123;    spin.stop();    e = checkError(e, resp, 200);    if (e) return cb(e);    const titles = [];    body.data.translations.forEach(function(x) &#123;      titles[x.questionId] = x.title;    &#125;);    return cb(null, titles);  &#125;);&#125;;module.exports = plugin;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode_Daily_Questions</title>
      <link href="/2021/02/09/leetcode-daily-questions/"/>
      <url>/2021/02/09/leetcode-daily-questions/</url>
      
        <content type="html"><![CDATA[<p>待完善</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可爱的壁纸</title>
      <link href="/2020/09/24/ke-ai-de-bi-zhi/"/>
      <url>/2020/09/24/ke-ai-de-bi-zhi/</url>
      
        <content type="html"><![CDATA[<p>在寻找壁纸api的时候突然发现了一套灰常灰常可爱的壁纸，于是想把他们都放到我的壁纸界面上，无奈api一次请求的图片一样，所以就想着把这些图片搞下来，存到我的cdn加速中。</p><p>先来几张图：</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/1.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/13.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/29.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/65.jpg"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_source/mc/94.jpg"> </p><h3 id="1-得到图片"><a href="#1-得到图片" class="headerlink" title="1. 得到图片"></a>1. 得到图片</h3><p>懒癌晚期当然是不能一张一张的下载了，于是就有了下面</p><pre><code class="line-numbers language-python">import osimport timeimport randomimport requestsimport urllib.requestfrom urllib.request import Request, urlopen, urlretrieveurl = yourapiheaders = &#123;    &#39;User-Agent&#39;:    &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:23.0) Gecko/20100101 Firefox/23.0&#39;&#125;folder_path = &#39;/Users/kevin/Pictures/wallpapers/mc/&#39;folder = os.path.exists(folder_path)if not folder:    os.makedirs(folder_path)    print(&quot;创建文件夹%s成功&quot; % folder_path)file_names = os.listdir(folder_path)index = len(file_names)try:    while True:        flag = False        request = urllib.request.Request(url, headers=headers)        resp = urllib.request.urlopen(request)        real_url = resp.geturl()        response = requests.get(real_url)        # img_name = real_url.split(&#39;/&#39;)[4]        img_name = os.path.split(real_url)[1]        for file_name in file_names:            if file_name == img_name:                print(&#39;图片已存在&#39;)                flag = True                break        if flag:            time.sleep(random.randint(0, 3))            continue        path = folder_path + img_name        index += 1        urlretrieve(real_url, path)        print(&#39;已下载%d张图片,该图片的真实链接为%s&#39; % (index, real_url))        time.sleep(random.randint(0, 3))except:    print(&#39;出现异常&#39;)</code></pre><p>运行如下，没想到这么多张<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/1.jpg"> </p><h2 id="2-改名字"><a href="#2-改名字" class="headerlink" title="2. 改名字"></a>2. 改名字</h2><p>由于原图片的名字是一串神秘代码，这样看着太难受了，于是我决定给他们改名字，正好最近vim用的很顺手，接下来就是vim的骚操作了。</p><p>操作之前先讲讲vim为什么可以这么做: 可以在 Vim 内部调用外部程序(如shell命令)，还可以把缓冲区的内容作为标准输入传递给外部命令，或是把外部命令的标准输出导入到Vim缓冲区。</p><h3 id="1-在vim内部执行shell命令"><a href="#1-在vim内部执行shell命令" class="headerlink" title="1. 在vim内部执行shell命令"></a>1. 在vim内部执行shell命令</h3><p>在Vim的命令行模式中，在命令前加一个!前缀 (参见:h :! ) 就可以调用外部的shell程序。<br>例如：在vim中，想要查看当前目录的所有文件,在命令行模式下使用<code>:!ls</code></p><p>注：<code>:!ls</code> 和 <code>:ls</code> 是两个不同的Vim命令，前者是在Vim中调用shell命令 <code>ls</code>，用于列出目录下的所有文件，后者调用的是 Vim内置命令<code>ls</code>，用来显示当前缓冲区列表的内容.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/1.gif"> </p><h3 id="2-将Vim-缓冲区内容作为标准输入或标准输出"><a href="#2-将Vim-缓冲区内容作为标准输入或标准输出" class="headerlink" title="2. 将Vim 缓冲区内容作为标准输入或标准输出"></a>2. 将Vim 缓冲区内容作为标准输入或标准输出</h3><p>在使用<code>!&#123;cmd&#125;</code>时，vim会回显command的输出，可以用<code>:read !&#123;cmd&#125;</code>把command的输出重定向到当前vim的缓冲区中,或使用<code>:write !&#123;cmd&#125;</code>把当前vim缓冲区的内容作为command的标准输入.</p><p>例如：执行<code>:write !sh</code>则会在shell中逐行执行当前vim缓冲区的内容</p><h3 id="3-改名字"><a href="#3-改名字" class="headerlink" title="3. 改名字"></a>3. 改名字</h3><p>我想把名字改成（1.jpg，2.jpg）的形式，所以需要用到递增</p><ul><li>首先选中需要修改的部分，接下来执行两条指令:</li></ul><pre><code class="line-numbers language-vim">:&#39;&lt;,&gt;&#39;s/.*/mv &amp; aaa.jpg:&#39;&lt;,&gt;&#39;s/aaa/\=line(&quot;.&quot;)-line(&quot;&#39;&lt;&quot;)+1</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/2.gif"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@latest/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/3.gif"> </p><p>具体命令详解：</p><pre><code class="line-numbers language-vim">&#39;&lt;,&#39;&gt;        所选中的区域 (:help &#39;&lt;，:help &#39;&gt; )s            在选中的区域中进行替换 (:help :s ).*           匹配当前所有字符\=           指明后面是一个表达式 (:help :s\= )line(&quot;.&quot;)    当前光标所在行的行号 (:help line() )line(&quot;&#39;&lt;&quot;)   所选区域中第一行的行号 (:help line() ) </code></pre><p><code>&#39;&lt;</code>和<code>&#39;&gt;</code>是使用了”v”，”V”命令选中一个visual区域后，VIM设置的标记，分别用来标识visual区域的开始和结束。</p><ul><li>接着执行<code>:wirte !sh</code>即可</li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source/blog_images/%E5%8F%AF%E7%88%B1%E7%9A%84%E5%A3%81%E7%BA%B8/4.gif"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>魔改hexo博客</title>
      <link href="/2020/09/18/mo-gai-hexo-bo-ke/"/>
      <url>/2020/09/18/mo-gai-hexo-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="魔改hexo博客"><a href="#魔改hexo博客" class="headerlink" title="魔改hexo博客"></a>魔改hexo博客</h2><p>本次魔改主要包括以下几个方面</p><h2 id="1-添加一言插件"><a href="#1-添加一言插件" class="headerlink" title="1. 添加一言插件"></a>1. 添加一言插件</h2><h2 id="2-添加动态线条背景"><a href="#2-添加动态线条背景" class="headerlink" title="2. 添加动态线条背景"></a>2. 添加动态线条背景</h2><h2 id="3-添加Dplayer视频播放器"><a href="#3-添加Dplayer视频播放器" class="headerlink" title="3. 添加Dplayer视频播放器"></a>3. 添加Dplayer视频播放器</h2><h2 id="4-添加Aplayer播放器"><a href="#4-添加Aplayer播放器" class="headerlink" title="4. 添加Aplayer播放器"></a>4. 添加Aplayer播放器</h2><h2 id="5-添加看板娘（live2d-widget插件）"><a href="#5-添加看板娘（live2d-widget插件）" class="headerlink" title="5. 添加看板娘（live2d-widget插件）"></a>5. 添加看板娘（live2d-widget插件）</h2><h2 id="6-添加黑夜模式"><a href="#6-添加黑夜模式" class="headerlink" title="6. 添加黑夜模式"></a>6. 添加黑夜模式</h2><h2 id="7-添加文章更新日期"><a href="#7-添加文章更新日期" class="headerlink" title="7. 添加文章更新日期"></a>7. 添加文章更新日期</h2><h2 id="8-添加访客地图统计"><a href="#8-添加访客地图统计" class="headerlink" title="8. 添加访客地图统计"></a>8. 添加访客地图统计</h2><h2 id="9-添加valine评论邮件提醒"><a href="#9-添加valine评论邮件提醒" class="headerlink" title="9. 添加valine评论邮件提醒"></a>9. 添加valine评论邮件提醒</h2><h2 id="10-添加网站背景"><a href="#10-添加网站背景" class="headerlink" title="10. 添加网站背景"></a>10. 添加网站背景</h2><h2 id="11-添加腾讯兔小巢"><a href="#11-添加腾讯兔小巢" class="headerlink" title="11. 添加腾讯兔小巢"></a>11. 添加腾讯兔小巢</h2><h2 id="12-Mac样式的代码块的添加"><a href="#12-Mac样式的代码块的添加" class="headerlink" title="12. Mac样式的代码块的添加"></a>12. Mac样式的代码块的添加</h2><h3 id="12-1-代码高亮"><a href="#12-1-代码高亮" class="headerlink" title="12.1 代码高亮"></a>12.1 代码高亮</h3><h4 id="12-1-1-禁用highlight"><a href="#12-1-1-禁用highlight" class="headerlink" title="12.1.1 禁用highlight"></a>12.1.1 禁用highlight</h4><p>打开根目录下的<code>_config.yml</code>文件,修改配置</p><pre><code class="line-numbers language-yml">highlight:enable: falseline_number: falseauto_detect: falsetab_replace:</code></pre><h4 id="12-1-2-获取prism配置文件"><a href="#12-1-2-获取prism配置文件" class="headerlink" title="12.1.2 获取prism配置文件"></a>12.1.2 获取prism配置文件</h4><p>在<a href="https://prismjs.com/download.html">https://prismjs.com/download.html</a>选择喜欢的theme, 需要的language和plug(不推荐选太多,需要的选上即可), 将文件下载到本地后分别重命名为<code>prism.css</code>, <code>prism.js</code>, 将其放入到<code>/theme/matery/source/js/prism</code>目录下(prism文件夹自己创建) </p><h4 id="12-1-3-配置prism"><a href="#12-1-3-配置prism" class="headerlink" title="12.1.3 配置prism"></a>12.1.3 配置prism</h4><ul><li>在<code>themes/matery/layout/_partial/head.ejs</code> 添加以下代码:</li></ul><pre><code class="line-numbers language-ejs">&lt;link rel=&quot;stylesheet&quot; href=&quot;/js/prism/prism.css&quot;&gt;</code></pre><ul><li>在<code>themes/matery/layout/_partial/footer.ejs</code> 添加以下代码:</li></ul><pre><code class="line-numbers language-ejs">&lt;script src=&quot;/js/prism/prism.js&quot; async&gt;&lt;/script&gt;</code></pre><h4 id="12-1-4-添加配置"><a href="#12-1-4-添加配置" class="headerlink" title="12.1.4 添加配置"></a>12.1.4 添加配置</h4><p>在根目录的 <code>_config.yml</code> 文件中添加以下代码:</p><pre><code class="line-numbers language-yml">prism_plugin:    mode: &#39;preprocess&#39;    # realtime/preprocess    theme: &#39;tomorrow&#39;    line_number: false   # default false    custom_css:marked:    langPrefix: line-numbers language-</code></pre><p>此时测试效果如下图所示:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source/blog_images/%E9%AD%94%E6%94%B9hexo%E5%8D%9A%E5%AE%A2/1.png"> </p><h3 id="12-2-添加mac样式"><a href="#12-2-添加mac样式" class="headerlink" title="12.2 添加mac样式"></a>12.2 添加mac样式</h3><h4 id="12-2-1-创建codeblock的js文件"><a href="#12-2-1-创建codeblock的js文件" class="headerlink" title="12.2.1 创建codeblock的js文件"></a>12.2.1 创建codeblock的js文件</h4><p>在目录<code>theme/source/libs/codeBlock/</code>下创建<code>codeBlock.js</code>文件, 在里面添加如下代码:</p><pre><code class="line-numbers language-javascript">// 代码块$(function () &#123;    $(&#39;pre&#39;).wrap(&#39;&lt;div class=&quot;code-area&quot; style=&quot;position: relative&quot;&gt;&lt;/div&gt;&#39;);&#125;);</code></pre><h4 id="12-2-2-添加css样式"><a href="#12-2-2-添加css样式" class="headerlink" title="12.2.2 添加css样式"></a>12.2.2 添加css样式</h4><p>在<code>theme/source/css/matery.css</code>文件中添加:</p><pre><code class="line-numbers language-css">pre &#123;    padding: 2.5rem 1.5rem 1.5rem 1.5rem !important;    margin: 1rem 0 !important;    background: #272822;    overflow: auto;    border-radius: 0.35rem;    tab-size: 4;&#125;.code-area::after &#123;    content: &quot; &quot;;    position: absolute;    border-radius: 50%;    background: #ff5f56;    width: 12px;    height: 12px;    top: 0;    left: 12px;    margin-top: 12px;    -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;    box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;&#125;code &#123;    padding: 1px 5px;    top: 13px !important;    font-family: Inconsolata, Monaco, Consolas, &quot;Courier New&quot;, Courier, monospace;    font-size: 0.91rem;    color: #e96900;    background-color: #f8f8f8;    border-radius: 2px;&#125;pre code &#123;    padding: 0;    color: #e8eaf6;    background-color: #272822;&#125;pre[class*=&quot;language-&quot;] &#123;    padding: 1.2em;    margin: 0.5em 0;&#125;code[class*=&quot;language-&quot;],pre[class*=&quot;language-&quot;] &#123;    color: #e8eaf6;    white-space: pre-wrap !important;&#125;</code></pre><h4 id="12-2-3-调用js文件"><a href="#12-2-3-调用js文件" class="headerlink" title="12.2.3 调用js文件"></a>12.2.3 调用js文件</h4><p>在<code>theme/layout/_partial/post-detail.ejs</code>文件中添加</p><pre><code class="line-numbers language-ejs">&lt;!-- 代码块 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/libs/codeBlock/codeBlockFuction.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="12-3-测试"><a href="#12-3-测试" class="headerlink" title="12.3 测试"></a>12.3 测试</h3><p>执行<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>, 效果如下:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source/blog_images/%E9%AD%94%E6%94%B9hexo%E5%8D%9A%E5%AE%A2/2.png"> </p><h2 id="13-访问速度优化"><a href="#13-访问速度优化" class="headerlink" title="13. 访问速度优化"></a>13. 访问速度优化</h2><h3 id="13-1-静态资源优化"><a href="#13-1-静态资源优化" class="headerlink" title="13.1 静态资源优化"></a>13.1 静态资源优化</h3><h4 id="13-1-1-图片压缩"><a href="#13-1-1-图片压缩" class="headerlink" title="13.1.1 图片压缩"></a>13.1.1 图片压缩</h4><p><a href="https://developers.google.com/speed/webp?hl=zh-cn">WebP</a> 是Google开发的新图像格式,旨在以可接受的视觉质量为无损和有损压缩提供较小的文件大小。有损模式下比 JPEG 小 25% - 34%，无损模式下较 PNG 小 26%,很显然,在相同的用户体验下,使用WebP格式可以提高网站的访问速度.<br>如果你想详细了解这其中的技术细节，可以阅读 Google 开发者文章<a href="https://developers.google.com/speed/webp/docs/compression?hl=zh-cn">WebP压缩技术</a> </p><h5 id="13-1-1-1-优化目标"><a href="#13-1-1-1-优化目标" class="headerlink" title="13.1.1.1 优化目标"></a>13.1.1.1 优化目标</h5><p>使用WebP固然可以优化图像资源,提高访问速度,但截止到目前为止,即便浏览器对WebP的<a href="https://caniuse.com/#search=webp">支持情况</a> 已经接近80%, 却依然有些主流浏览器如 Safari、IE 仍不支持，所以不能直接转用 WebP.<br>由于目前精力有限,故先设定一个优化目标如下:    </p><ul><li>由于压缩图像这项工作重复且繁琐，图像优化应自动化完成,初次配置完成，日后使用无需任何操作便可全自动切换 WebP 图片格式.</li><li>对于不支持的浏览器，会自动回退到 JPEG/PNG 等传统格式</li><li>提前生成好两份文件而非请求时计算，节省算力且响应更迅速</li></ul><h5 id="13-1-1-2-目前已完成-网站首页轮播图"><a href="#13-1-1-2-目前已完成-网站首页轮播图" class="headerlink" title="13.1.1.2 目前已完成(网站首页轮播图)"></a>13.1.1.2 目前已完成(网站首页轮播图)</h5><p>这里使用一个开源工具: <a href="https://github.com/Jacksgong/webp-converter">Webp Converter and Analytics</a>, 具体使用方法在项目介绍页,这里不再赘述.<br>只是暂时使用这个工具,因为我的博客目前图片资源大的就是首页轮播图,这只是一个暂时的解决方案,因为需要手动(懒)…</p><h4 id="13-1-2-HTML压缩"><a href="#13-1-2-HTML压缩" class="headerlink" title="13.1.2 HTML压缩"></a>13.1.2 HTML压缩</h4><p>待定</p><h4 id="13-1-3-CSS压缩"><a href="#13-1-3-CSS压缩" class="headerlink" title="13.1.3 CSS压缩"></a>13.1.3 CSS压缩</h4><p>待定</p><h3 id="13-2-静态资源加载优化"><a href="#13-2-静态资源加载优化" class="headerlink" title="13.2 静态资源加载优化"></a>13.2 静态资源加载优化</h3><h4 id="13-2-1-使用CDN"><a href="#13-2-1-使用CDN" class="headerlink" title="13.2.1 使用CDN"></a>13.2.1 使用CDN</h4><p>参考<a href="https://godliuyang.wang/2020/09/15/cdn-for-blog/">CDN for Blog</a> </p><h2 id="14-添加推荐文章插件-hexo-recommended-posts"><a href="#14-添加推荐文章插件-hexo-recommended-posts" class="headerlink" title="14. 添加推荐文章插件(hexo-recommended-posts)"></a>14. 添加推荐文章插件(<a href="https://github.com/huiwang/hexo-recommended-posts">hexo-recommended-posts</a>)</h2><p>推荐文章的插件有很多, <a href="https://github.com/tea3/hexo-related-popular-posts">hexo-related-popular-posts</a> 是一个很棒的插件, 安装也很简单,不过我这里使用的是<code>hexo-recommended-posts</code></p><h3 id="14-1-安装"><a href="#14-1-安装" class="headerlink" title="14.1 安装"></a>14.1 安装</h3><pre><code class="line-numbers language-bash">npm install hexo-recommended-posts --save</code></pre><h3 id="14-2-下载推荐文章列表"><a href="#14-2-下载推荐文章列表" class="headerlink" title="14.2 下载推荐文章列表"></a>14.2 下载推荐文章列表</h3><pre><code class="line-numbers language-bash">hexo recommend</code></pre><h3 id="14-3-自定义配置"><a href="#14-3-自定义配置" class="headerlink" title="14.3 自定义配置"></a>14.3 自定义配置</h3><p>在博客根目录添加以下默认配置,根据个人情况修改</p><pre><code class="line-numbers language-yml">recommended_posts:  server: https://api.truelaurel.com #后端推荐服务器地址  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式  internalLinks: 3 #内部文章数量  externalLinks: 1 #外部文章数量  fixedNumber: false #控制是否返回固定数量的推荐文章, 如果默认推荐文章不够的话会填充当前文章的前后文章作为推荐文章.  autoDisplay: true #自动在文章底部显示推荐文章  excludePattern: [] #添加想要被过滤的链接的正则表达式, 如配置为 [&quot;example.com&quot;], 则所有包含 example.com 的链接都会从推荐文章中过滤掉.  titleHtml: &lt;h1&gt;推荐文章&lt;span style=&quot;font-size:0.45em; color:gray&quot;&gt;（由&lt;a href=&quot;https://github.com/huiwang/hexo-recommended-posts&quot;&gt;hexo文章推荐插件&lt;/a&gt;驱动）&lt;/span&gt;&lt;/h1&gt; #自定义标题</code></pre><h3 id="14-4-一点小改动"><a href="#14-4-一点小改动" class="headerlink" title="14.4 一点小改动"></a>14.4 一点小改动</h3><p>插件虽然有<code>autoDisplay</code>选项来控制是否在文章底部显示文章,但在配置文件中竟然没有一个选项来控制是否启用插件,这不能忍,于是我修改了一点插件的代码,实现了这个功能,具体实现如下:</p><ul><li><p>编辑<code>hexo-recommended-posts/lib/recommend.js</code>文件,第二行修改为</p><pre><code class="line-numbers language-javascript">var posts = filterPosts(recommended_posts, post, config.excludePattern, config.enable)</code></pre><p>第九行修改为</p><pre><code class="line-numbers language-javascript">function filterPosts(recommended_posts, post, excludePattern, enable) &#123;  if (recommended_posts === undefined || !enable ||      recommended_posts[post.permalink] === undefined) &#123;      return [];  &#125;</code></pre></li><li><p>在根目录config中添加<code>enable</code>选项,具体如下:</p><pre><code class="line-numbers language-yml">recommended_posts:  enable: trueserver: https://api.truelaurel.com #后端推荐服务器地址timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式internalLinks: 3 #内部文章数量externalLinks: 1 #外部文章数量fixedNumber: false #控制是否返回固定数量的推荐文章, 如果默认推荐文章不够的话会填充当前文章的前后文章作为推荐文章.autoDisplay: true #自动在文章底部显示推荐文章excludePattern: [] #添加想要被过滤的链接的正则表达式, 如配置为 [&quot;example.com&quot;], 则所有包含 example.com 的链接都会从推荐文章中过滤掉.titleHtml: &lt;h1&gt;推荐文章&lt;span style=&quot;font-size:0.45em; color:gray&quot;&gt;（由&lt;a href=&quot;https://github.com/huiwang/hexo-recommended-posts&quot;&gt;hexo文章推荐插件&lt;/a&gt;驱动）&lt;/span&gt;&lt;/h1&gt; #自定义标题</code></pre></li></ul><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><h3 id="2020-12-07"><a href="#2020-12-07" class="headerlink" title="2020.12.07"></a>2020.12.07</h3><ul><li>添加<code>hexo-recommended-posts</code>插件</li></ul><h3 id="2020-12-06"><a href="#2020-12-06" class="headerlink" title="2020.12.06"></a>2020.12.06</h3><ul><li>优化图片资源(首页轮播图)</li></ul><h3 id="2020-12-05"><a href="#2020-12-05" class="headerlink" title="2020.12.05"></a>2020.12.05</h3><ul><li>修复了一个 <code>ClustrMaps</code> 未统计访客的bug</li><li>默认不开启看板娘(太占用cpu内存,影响用户体验)</li></ul><h3 id="2020-11-22"><a href="#2020-11-22" class="headerlink" title="2020.11.22"></a>2020.11.22</h3><ul><li>使用<a href="https://github.com/fengkx/hexo-native-lazy-load">hexo-native-lazy-load</a> 代替<a href="https://github.com/Troy-Yang/hexo-lazyload-image">hexo-lazyload-image</a> </li></ul><h3 id="2020-11-16"><a href="#2020-11-16" class="headerlink" title="2020.11.16"></a>2020.11.16</h3><ul><li>添加网站背景图, 添加腾讯兔小巢</li><li>添加Mac样式的代码块</li></ul><h3 id="2020-11-15"><a href="#2020-11-15" class="headerlink" title="2020.11.15"></a>2020.11.15</h3><ul><li>删除冗余脚本, 模块化插件</li><li>使用<a href="https://deserts.io/valine-admin-document/">valine-admin</a>实现评论邮件提醒</li><li>修复黑夜模式bug, 现已完美运行</li></ul><h3 id="2020-11-14"><a href="#2020-11-14" class="headerlink" title="2020.11.14"></a>2020.11.14</h3><ul><li>加入文章更新日期</li><li>添加<a href="https://clustrmaps.com/">ClustrMaps</a>访客地图统计(从即日起)<ul><li>可通过config文件切换地图的样式</li><li>目前在pc端访问globe样式无法加载, 移动端则正常(bug)</li></ul></li></ul><h3 id="2020-09-25"><a href="#2020-09-25" class="headerlink" title="2020.09.25"></a>2020.09.25</h3><ul><li>加入黑夜模式</li><li>试运行黑夜模式</li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/15/cdn-for-blog/">CDN_for_blog</a></li><li><a href="https://godliuyang.wang/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/">Arch Linux + i3wm详细配置篇</a></li><li><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/">Manjaro i3wm 高效率环境配置篇(持续更新)</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN_for_blog</title>
      <link href="/2020/09/15/cdn-for-blog/"/>
      <url>/2020/09/15/cdn-for-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-CND"><a href="#Why-CND" class="headerlink" title="Why CND?"></a>Why CND?</h2><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><h2 id="USE-CDN"><a href="#USE-CDN" class="headerlink" title="USE CDN"></a>USE CDN</h2><ol><li>创建一个名为CDN的github仓库</li><li>把仓库clone到本地</li><li>将图片文件存储到仓库中并上传<br>注：jsDelivr不支持加载超过20M的资源</li><li>发布仓库</li></ol><ul><li>点击release发布仓库<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CDN_for_blog/release.jpg">  </li><li>注明版本号后发布<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CDN_for_blog/release_number.jpg"> </li></ul><ol start="5"><li>通过如下形式来使用</li></ol><pre><code>// load any GitHub release, commit, or branch// note: we recommend using npm for projects that support ithttps://cdn.jsdelivr.net/gh/user/repo@version/file</code></pre><p>例如：在我的github仓库中有这么一个文件</p><p><a href="https://github.com/liuyaanng/CDN/blob/1.02/blog_images/CDN_for_blog/release.jpg">https://github.com/liuyaanng/CDN/blob/1.02/blog_images/CDN_for_blog/release.jpg</a></p><p>使用jsdelivr加速访问就是：</p><p><a href="https://cdn.jsdelivr.net/gh/liuyaanng/CDN@1.02/blog_images/CDN_for_blog/release.jpg">https://cdn.jsdelivr.net/gh/liuyaanng/CDN@1.02/blog_images/CDN_for_blog/release.jpg</a> </p><p>其中<strong>1.02</strong>是我发布的版本号，当然也可以使用模糊版本号的方法进行访问，无论哪种形式，都可以明显的感觉到访问速度快了很多。</p><p>另外，在我使用的过程中，发现在第一次发布之后，以后在使用图片可将版本号换成<code>master</code>直接访问。</p><h2 id="Generate-Jsdelivr-Link"><a href="#Generate-Jsdelivr-Link" class="headerlink" title="Generate Jsdelivr Link"></a>Generate Jsdelivr Link</h2><h3 id="1-使用脚本生成-更优解见2"><a href="#1-使用脚本生成-更优解见2" class="headerlink" title="1. 使用脚本生成  **更优解见2 **"></a><del>1. 使用脚本生成</del>  **更优解见<a href="#toc-heading-5">2</a> **</h3><ul><li>我写博客的截图均是由<a href="https://zh.xnipapp.com/">Xnip</a> 生成，截图文件存储目录<code>Pictures/Xnip</code>,故我写了一个小脚本来实现</li></ul><pre><code class="line-numbers language-bash">#!/bin/bash# @author:liuyaanngrep_path=~/Github/Myrep/CDN/blog_photo_folder=blog_imagespath=~/Pictures/Xnipprefix=https://cdn.jsdelivr.net/gh/liuyaanng/CDN@files=$(ls $path)check_v=0check_f=0help_text=&quot;This is a script for move the picture files to github, and get the jsdelivr link quickly. This scripts run with 2 arguments.\n1. cdn_server.sh -v version -f folder. version is the release version,folder is the pictures&#39;s file folder. \nfor example: cdn_server.sh -v 1.0 -f cdn_for_blog, it will get\nhttps://cdn.jsdelivr.net/gh/liuyaanng/CDN@1.0/blog_images/cdn_for_blog/filename\nif you do not use version, please use:cdn_server.sh -v master -f foldername.2. cdn_server.sh -h    Show help content.&quot;while getopts :v:f:h optdo    case &quot;$opt&quot; in        v) version=$OPTARG             check_v=1;;        f) folder=$OPTARG             check_f=1;;        h) echo -e $help_text             exit 1;;        ?) echo &quot;sync error. Use &#39;cdn_server.sh -h&#39; for help.&quot;;;    esacdoneprint_link()&#123;if [ ! -n &quot;$files&quot; ]; then    echo &quot;There is no file in Xnip folder.&quot;else    for filename in $files    do        echo $prefix$version/$blog_photo_folder/$folder/$filename        mv $path/* $rep_path$blog_photo_folder/$folder        echo &quot;move file $filename success&quot;    done    cd $rep_path    git add .    git commit -m &quot;upload $folder&quot;    git pushfi&#125;if [ $check_v -eq $check_f ]; then    print_linkelse    echo &quot;need 2 args but given 1.&quot;fi</code></pre><p>该脚本有以下功能：</p><ol><li>将截图转到github仓库中并提交</li><li>自动生成jsdelivr链接</li></ol><p>如果你想使用的话只需修改上面的路径信息就行了。</p><p>脚本有两个参数，你可以用<code>cdn_server.sh -h</code> 来查看帮助信息。</p><ol><li><code>-a version</code>. <code>-a</code>参数后跟发布的版本号</li><li><code>-f folder</code>. <code>-f</code>参数后跟仓库中文件夹名</li></ol><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源. 若不想指定版本号（第一次发布之后可用），可以直接使用 <code>-a master</code>.</p><p>例如：</p><pre><code class="line-numbers language-bash">cdn_server.sh -a master -f CDN_for_blog</code></pre><h3 id='1'> 2. 使用PicGO工具实现一键上传并生成CDN链接</h3><p><a href="https://github.com/Molunerfinn/PicGo">PicGo</a><br>文档太详细,不想做过多介绍了</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2019/07/22/hexo-da-keng/">hexo大坑</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> jsdelivr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode EASY_9</title>
      <link href="/2020/08/17/leetcode-easy-9/"/>
      <url>/2020/08/17/leetcode-easy-9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</li></ul><p>示例：</p><pre><code>输入：121输出：True</code></pre><pre><code>输入：-121输出：False</code></pre><ul><li><p>思路1：将数字转化为字符串形式，分别进行头尾判断数字是否一致。<br>实现需要3步：</p><p>预判断：<br>首先判断当输入数字为负数或其个位数字是0（排除0）时一定输出False</p><pre><code class="line-numbers language-python">if (x &lt; 0 or (x % 10 == 0 and x!= 0)):    return False</code></pre><ul><li><p>将输入转化为字符串</p><pre><code class="line-numbers language-python3">x_str = str(x)</code></pre></li><li><p>分割字符串，不能用split方法。这里因为当输入为奇数时，数字中间的一位对结果无影响，故将这一位删掉。</p><pre><code class="line-numbers language-python3">x_list = []for x_s in x_str:  x_list.append(x_s)if num != num_i:  x_list.pop(num_i)</code></pre></li><li><p>判断是否为回文数。采用循环判断，从中间往两边依次判断，注意这里只要有一位不相同就会输出False</p></li></ul></li></ul><p>程序完整代码如下：</p><pre><code class="line-numbers language-python">if (x &lt; 0 or (x % 10 == 0 and x!= 0)):    return False    x_str = str(x)num = len(x_str) / 2 num_i = len(x_str) // 2x_list = []for x_s in x_str:    x_list.append(x_s)if num != num_i:    x_list.pop(num_i)i = 0result = Truewhile i &lt; num_i:    if x_list[num_i + i] == x_list[num_i - (i + 1)]:        result = True    else:        result = False        return result    i += 1return result</code></pre><p>在参考了LeetCode官网解法之后，发现了类似思路更简单的解法，代码如下：</p><pre><code class="line-numbers language-python">return (str(x) == str(x)[::-1])</code></pre><p>只需判断输入数字的一半即可判断结果，故可改进如下：</p><pre><code class="line-numbers language-python">x_str = str(x)x_len = len(x_str)x_h = x_len // 2return (x_str[:x_h] == x_str[-1:-x_h - 1:-1])</code></pre><p>以上方法均将输入转化为字符串之后再进行判断</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><p>你能不将整数转为字符串来解决这个问题吗？</p><ul><li>思路2: 将数字反转，然后将反转得到的数字与原始数字进行比较，两者相同则是回文数。但这时要考虑到溢出问题，反转得到的数字可能会大于整数的最大值。为了避免这个问题，考虑只反转输入数字的一半，若后一半反转后与前一半相同则是回文数。算法考虑如下：<ul><li>预判断如上</li><li>设置一个反转数，将输入数字除10求余，得到的数字是反转数的首位，依次循环，可得到一系列的反转数，x的值会越来越小，而反转数的值会越来越大。对于偶数来说，循环终止的条件很简单，就是当x等于反转数，对于奇数来说，循环终止的条件是x小于反转数，随后判断此时的x与反转数是否相同。注意：对于奇数来说，判断条件是x是否等于反转数除10取整的值，因为奇数多了一轮迭代。</li></ul></li></ul><p>完整代码如下：</p><pre><code class="line-numbers language-python">if (x &lt; 0 or (x % 10 == 0 and x != 0)):    return Falsex_reversed = 0while x_reversed &lt; x:    x_reversed = x_reversed * 10 + x % 10    x = x // 10return (x == x_reversed or x == x_reversed // 10)</code></pre><p>C代码如下：</p><pre><code class="line-numbers language-C">bool isPalindrome(int x)&#123;if (x&lt;0 || (x%10 == 0 &amp;&amp; x != 0))&#123;    return false;&#125;int x_reversed = 0;while (x_reversed &lt; x)&#123;    x_reversed = x_reversed * 10 + x % 10;     x = x / 10;&#125;return (x == x_reversed || x == x_reversed / 10);&#125;</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(log n) ，对于每次迭代，都将输入除以n，故时间复杂度为O(log n)</li><li>空间复杂度： O(1). 只需在常数空间存储若干变量。</li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/03/30/scikit-image-guide/">scikit-image guide</a></li><li><a href="https://godliuyang.wang/2020/01/29/sort/">SORT</a></li><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLSW</title>
      <link href="/2020/04/22/clsw/"/>
      <url>/2020/04/22/clsw/</url>
      
        <content type="html"><![CDATA[<p><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/#toc-heading-14">Install and Configure guide</a> </p><p><a href="https://github.com/liuyaanng/CLSW">My config</a> </p><h2 id="1-Vim-Neovim"><a href="#1-Vim-Neovim" class="headerlink" title="1. Vim(Neovim)"></a>1. Vim(Neovim)</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/vim_cheat_sheet.png" alt="vim cheat sheet"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/nvim.png" alt="Vim"></p><h2 id="2-Ranger"><a href="#2-Ranger" class="headerlink" title="2. Ranger"></a>2. Ranger</h2><ul><li><p>If you want a tool to preview images or other file type can preview as images (pdf, videos), i recommended ueberzug , but note, you should use ranger-git by <code>yaourt -S ranger-git</code></p></li><li><p>If you are a Mac user, iterm2 is enough to preview images.</p></li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/ranger.png" alt="Ranger"> </p><h2 id="3-Fish"><a href="#3-Fish" class="headerlink" title="3. Fish"></a>3. Fish</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/CLSW/Fish.png" alt="Fish"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GPU servers</title>
      <link href="/2020/04/21/gpu-servers/"/>
      <url>/2020/04/21/gpu-servers/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我的任务是在GPU服务器上使用深度强化学习训练Amazing Brick，Amazing Brick使用Python的<a href="https://arcade.academy/index.html">Arcade</a> 库来写的。    </p><p>我在考虑在GPU服务器上训练之前，没有注意到Arcade是使用<strong>OpenGL</strong> 和<strong>Pyglet</strong> 来进行渲染的</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/ArcadeVSPygame.png" alt="Arcade VS Pygame"></p><p>而服务器大多都以ssh登陆，而OpenGL就更不要说了，所以在我寻找服务器和准备环境的过程中就遇到了很多问题，这个在下面会说到。</p><h2 id="GPU-servers"><a href="#GPU-servers" class="headerlink" title="GPU servers"></a>GPU servers</h2><p>  <a href="https://www.zhihu.com/question/51707286">知乎:目前哪里可以租用到GPU服务器？</a> </p><hr><ul><li><a href="https://aistudio.baidu.com/aistudio/index">AI Studio</a></li></ul><p>非常良心，用算力可以获得算力，不怕你用，用得多送的多。<br>这里有一位同学写的攻略<a href="https://zhuanlan.zhihu.com/p/73361554?utm_source=wechat_session&utm_medium=social&utm_oi=28323023421440">薅薅国产免费GPU计算资源</a><br>登陆方式有 <strong>notebook</strong> ,可使用 <strong>Terminal</strong> ,但没有root权限，这就意味着有很多限制，最重要的是预装框架为 <strong>PaddlePaddle</strong> .  不能用 <code>TensorFlow</code>, 总不能为了嫖GPU服务器再去学一种框架吧，别担心, 这里有<a href="https://www.zhihu.com/question/336485090">百度paddlepaddle平台如何配置tensorflow-gpu</a>. 这个我没有尝试，有兴趣的可以尝试一下（有空了我会来填这个坑）</p><ul><li><a href="https://www.easyaiforum.cn/">易学智能</a> </li></ul><p>我现在使用的就是这个</p><p>感谢<a href="https://www.paratera.com/liveInterface.html">并行超算</a> 给我提供的50算力的试用，我就是靠着这50算力把环境给搭明白了哈哈哈。</p><ul><li>…</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="1-Ubuntu"><a href="#1-Ubuntu" class="headerlink" title="1. Ubuntu"></a>1. Ubuntu</h3><p>GPU 配置可根据自己的需要调整<br>我选择的是：</p><pre><code>OS: UbuntuGPU: RTX 2080TICPU: E5 4COREMEMARY: 15GENVIROMENT: Python 3.6 + TF 2.0</code></pre><p>这里的环境使开箱即用的，不需要激活</p><ol><li>基本包安装</li></ol><pre><code class="line-numbers language-bash">pip install arcade dataclasses scikit-image</code></pre><ol start="2"><li>测试arcade环境</li></ol><ul><li>Arcade 官方的一个小demo</li></ul><pre><code class="line-numbers language-python">&quot;&quot;&quot;Drawing an example happy faceIf Python and Arcade are installed, this example can be run from the command line with:python -m arcade.examples.happy_face&quot;&quot;&quot;import arcade# Set constants for the screen sizeSCREEN_WIDTH = 600SCREEN_HEIGHT = 600SCREEN_TITLE = &quot;Happy Face Example&quot;# Open the window. Set the window title and dimensionsarcade.open_window(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)# Set the background colorarcade.set_background_color(arcade.color.WHITE)# Clear screen and start render processarcade.start_render()# --- Drawing Commands Will Go Here ---# Draw the facex = 300y = 300radius = 200arcade.draw_circle_filled(x, y, radius, arcade.color.YELLOW)# Draw the right eyex = 370y = 350radius = 20arcade.draw_circle_filled(x, y, radius, arcade.color.BLACK)# Draw the left eyex = 230y = 350radius = 20arcade.draw_circle_filled(x, y, radius, arcade.color.BLACK)# Draw the smilex = 300y = 280width = 120height = 100start_angle = 190end_angle = 350arcade.draw_arc_outline(x, y, width, height, arcade.color.BLACK,                        start_angle, end_angle, 10)# Finish drawing and display the resultarcade.finish_render()# Keep the window open until the user hits the &#39;close&#39; buttonarcade.run()</code></pre><ul><li><p>-&gt;运行发现报错：<code>ImportError: Library “GLU” not found</code></p><p>解决办法：<a href="https://stackoverflow.com/questions/50446867/importerror-library-glu-not-found"><code>sudo apt-get install freeglut3-dev</code></a> </p></li><li><p>-&gt;再次运行报错：<code>pyglet.canvas.xlib.NoSuchDisplayException: Cannot connect to &quot;None&quot;</code></p><p>原因大概是arcade调用<code>pyglet</code>绘制窗口需要图形界面（就是弹出来的那个框框），而当你使用ssh连接server时是没有图形界面的。<br>因此我们需要一个虚拟的图形界面，而<a href="https://linux.die.net/man/1/xvfb"><code>xvfb-run</code></a>就是一个提供虚拟图形界面的工具。<br>这里有一篇文章是介绍如何使用<code>xvfb</code>来创建一个虚拟桌面来进行服务器端的图形测试的。</p><p><a href="http://elementalselenium.com/tips/38-headless">How To Run Your Tests Headlessly with Xvfb</a></p><p>安装<code>xvfb</code>之前要先更新一下 <code>sudo apt update</code>, 如果遇到密钥不可用可以<code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 密钥</code></p></li><li><p>-&gt;使用<code>xvfb-run -a python xxx.py</code> 来继续测试报错：<code>arcade.application.NoOpenGLException:  Unable to create an OpenGL 3.3+ context. Check to make sure your system supports OpenGL 3.3 or higher.</code>     </p><p>意思是OpenCV版本太低</p></li><li><p>接下来查看服务器端的OpenGL版本，使用<code>glxinfo | grep &quot;OpenGL&quot;</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/opencv_version.png" alt="opencv_version"> </p><p>还是没有图形界面的问题，继续使用<code>xvfb-run -a glxinfo | grep &quot;OpenGL&quot;</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/opencv_version2.png" alt="opencv_version"> </p><p>显示OpenGL的版本为3.1, 依旧无法满足arcade需要的OpenGL3+。</p></li><li><p>会不会是由于服务端原机器上的低版本OpenGL造成<code>xvfb</code>虚拟后的OpenCV版本较低？</p><p>我在本地的Ubuntu系统上分别运行<code>glxinfo | grep &quot;OpenGL&quot;</code>, 发现原机器版本为4.6，但<code>xvfb</code>虚拟后的版本为3.1，推测为<code>Xvfb</code>虚拟图形界面的原因。</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/GPU-servers/glxinfo.png"></p><p>此问题没有找到解决办法</p></li><li><p>⚠️ 如果你是一个<code>pygame</code>用户，或者你对OpenGL的版本要求不高（3.1），你完全可以使用<code>xvfb-run</code>来进行要求图形化的测试。经测试，pygame在GPU服务器上可以运行。</p></li></ul><p>既然Ubuntu无法完成我的工作，故我开始使用Windows</p><h3 id="2-Windows-10"><a href="#2-Windows-10" class="headerlink" title="2. Windows 10"></a>2. Windows 10</h3><p>系统配置</p><pre><code>OS: Windows 10GPU: RTX 2080TICPU: I5</code></pre><ul><li>进入系统要先激活环境,详细信息见<a href="https://www.easyaiforum.cn/helpDocument?manual_id=136">帮助文档</a> </li></ul><pre><code class="line-numbers language-bash">conda activate py36h</code></pre><ul><li><p>安装基本包和Ubuntu一样，测试的时候发现依旧存在<code>OpenGL</code>的问题,查看OpenGL版本为1.1</p><p>这里给几个查看OpenGL的工具：</p><ul><li>GPU_Caps_Viewer: 链接: <a href="https://pan.baidu.com/s/1_YisKqKJY_2Uml2MQXKnNQ">https://pan.baidu.com/s/1_YisKqKJY_2Uml2MQXKnNQ</a> 提取码: use7</li><li>GLViewer: 链接: <a href="https://pan.baidu.com/s/1G2GR5S9oSqatMmBqv5YLdA">https://pan.baidu.com/s/1G2GR5S9oSqatMmBqv5YLdA</a> 提取码: 27s2</li></ul></li><li><p>更新OpenGL</p><p>更新显卡驱动即可: <a href="https://www.nvidia.com/Download/index.aspx#">NVIDIA Driver Downloads</a> , 下载对应版本的驱动安装。</p><p>我在网上找到很多说用 驱动精灵， 鲁大师等软件更新驱动，我试了一下，完全不起作用。官网驱动亲测可行，就是有点耗时间。</p></li><li><p>更新完OpenGL之后代码就可以快乐地训练啦</p></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/05/09/use-tensorflow-in-ai-studio/">Use Tensorflow in AI Studio</a></li><li><a href="https://godliuyang.wang/2019/08/07/enjoy-pytorch/">Enjoy PyTorch</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-image guide</title>
      <link href="/2020/03/30/scikit-image-guide/"/>
      <url>/2020/03/30/scikit-image-guide/</url>
      
        <content type="html"><![CDATA[<h1 id="Python的数字图片处理包。比如-PIL-pillow-opencv-scikit-image"><a href="#Python的数字图片处理包。比如-PIL-pillow-opencv-scikit-image" class="headerlink" title="Python的数字图片处理包。比如 PIL, pillow, opencv, scikit-image"></a>Python的数字图片处理包。比如 PIL, pillow, opencv, scikit-image</h1><p>PIL和pillow只提供最基础的数字图像处理，功能有限；opencv实际上是一个c++库，只提供了python借口，更新速度非常慢。scikit-image是基于scipy的一款图像处理包，它将图片作为numpy数组进行处理，与matlab一样，所以我选择了是scikit-image进行图像处理</p><h2 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h2><pre><code class="line-numbers language-bash">conda install -c conda-forge scikit-image</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/08/17/leetcode-easy-9/">LeetCode EASY_9</a></li><li><a href="https://godliuyang.wang/2020/01/29/sort/">SORT</a></li><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About Proxy</title>
      <link href="/2020/02/04/about-proxy/"/>
      <url>/2020/02/04/about-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="About-Proxy"><a href="#About-Proxy" class="headerlink" title="About Proxy"></a>About Proxy</h1><p><del>Script: <a href="https://github.com/liuyaanng/SSR">SSR</a></del>  SSR seems very unstable, i use <strong>v2ray</strong> now.</p><p>Ping test: <a href="http://ping.chinaz.com/">ping</a> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/1.png" alt="Youtube speed"> </p><h2 id="V2Ray"><a href="#V2Ray" class="headerlink" title="V2Ray"></a>V2Ray</h2><p>Preconditions:</p><ul><li>a VPS: <a href="https://www.vultr.com/">vultr</a>( $5/m , i uesd now) , <a href="https://billing.virmach.com/cart.php">VIRMACH</a>( $1.25/m)</li><li>a Domain: (<a href="https://www.namesilo.com/">Namesilo</a>($0.99), <a href="https://www.freenom.com/">Freenom</a>(free) )</li><li>VPS OS version: Debian 9+ / Ubuntu 18.04+ / CentOS 7+</li></ul><h3 id="1-Resolve-the-domain-to-the-IP-of-your-VPS"><a href="#1-Resolve-the-domain-to-the-IP-of-your-VPS" class="headerlink" title="1. Resolve the domain to the IP of your VPS"></a>1. Resolve the domain to the IP of your VPS</h3><p><a href="https://www.cloudflare.com/">Cloudflare</a> </p><h4 id="1-Add-site"><a href="#1-Add-site" class="headerlink" title="1. Add site"></a>1. Add site</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/2.png"> </p><h4 id="2-Change-your-domain-NS"><a href="#2-Change-your-domain-NS" class="headerlink" title="2. Change your domain NS"></a>2. Change your domain NS</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/5.png"> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/3.png"> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/4.png"> </p><h4 id="3-Add-record"><a href="#3-Add-record" class="headerlink" title="3. Add record"></a>3. Add record</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/6.png"> </p><p><del>You can light the cloud icon to use a proxy which can hidden real ip. ~</del> it is possible to make v2ray doesn’t work.</p><p>NOTE: <strong>Do it after installed V2Ray if u need it</strong></p><h4 id="4-Ping"><a href="#4-Ping" class="headerlink" title="4. Ping"></a>4. Ping</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/7.png"> </p><p>it works.</p><h3 id="2-Set-BBR-lotserver"><a href="#2-Set-BBR-lotserver" class="headerlink" title="2. Set BBR lotserver"></a>2. Set BBR lotserver</h3><pre><code class="line-numbers language-bash">wget --no-check-certificate https://raw.githubusercontent.com/liuyaanng/SSR/master/tcp.sh &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/8.png"> </p><h3 id="3-Install-V2Ray"><a href="#3-Install-V2Ray" class="headerlink" title="3. Install V2Ray"></a>3. Install V2Ray</h3><p>There are two way to install V2Ray use different methods.</p><ul><li>Vmess+websocket+TLS+Nginx+Website</li></ul><pre><code class="line-numbers language-bash">bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install.sh) | tee v2ray_ins.log</code></pre><ul><li>Vmess + HTTP2 over TLS</li></ul><pre><code class="line-numbers language-bash">bash &lt;(curl -L -s https://raw.githubusercontent.com/wulabing/V2Ray_ws-tls_bash_onekey/master/install_h2.sh) | tee v2ray_ins_h2.log</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/About-Proxy/9.png"> </p><p>SELF TESTING</p><h3 id="4-Run-V2Ray"><a href="#4-Run-V2Ray" class="headerlink" title="4. Run V2Ray"></a>4. Run V2Ray</h3><ul><li>start v2ray: <code>systemctl start v2ray</code></li><li>stop v2ray: <code>systemctl stop v2ray</code></li><li>start nginx: <code>systemctl start nginx</code></li><li>stop nginx: <code>systemctl stop nginx</code></li></ul><h3 id="5-V2Ray-client"><a href="#5-V2Ray-client" class="headerlink" title="5. V2Ray client"></a>5. V2Ray client</h3><ul><li><p>Windows: </p><ul><li><a href="https://tlanyan.me/download.php?filename=/v2/windows/v2rayN-v3.5.zip">V2RayN</a> </li></ul></li><li><p>MacOS:</p><ul><li><a href="https://tlanyan.me/download.php?filename=/v2/macos/v2rayU-v1.5.1.dmg">V2RayU</a> </li><li><a href="https://github.com/yichengchen/clashX/releases/download/1.18.2/ClashX.dmg">ClashX</a> (what i use now)</li></ul></li><li><p>Linux:</p><ul><li><p><a href="https://www.jianshu.com/p/a5b6d9dc0441">link</a> </p></li><li><p><a href="https://snapcraft.io/install/v2ray-core/arch#install">Snap</a></p></li><li><p>Configuration V2Ray</p><p>config file is located in <code>/etc/v2ray/config.json</code></p><pre><code class="line-numbers language-bash">&#123;&quot;policy&quot;: null,&quot;log&quot;: &#123;&quot;access&quot;: &quot;&quot;,&quot;error&quot;: &quot;&quot;,&quot;loglevel&quot;: &quot;warning&quot;&#125;,&quot;inbounds&quot;: [&#123;  &quot;tag&quot;: &quot;proxy&quot;,  &quot;port&quot;: 1080,  &quot;listen&quot;: &quot;127.0.0.1&quot;,  &quot;protocol&quot;: &quot;socks&quot;,  &quot;sniffing&quot;: &#123;    &quot;enabled&quot;: true,    &quot;destOverride&quot;: [      &quot;http&quot;,      &quot;tls&quot;    ]  &#125;,  &quot;settings&quot;: &#123;    &quot;auth&quot;: &quot;noauth&quot;,    &quot;udp&quot;: true,    &quot;ip&quot;: null,    &quot;address&quot;: null,    &quot;clients&quot;: null  &#125;,  &quot;streamSettings&quot;: null&#125;],&quot;outbounds&quot;: [&#123;  &quot;tag&quot;: &quot;proxy&quot;,  &quot;protocol&quot;: &quot;vmess&quot;,  &quot;settings&quot;: &#123;    &quot;vnext&quot;: [      &#123;        &quot;address&quot;: &quot; &quot;, //your domain address        &quot;port&quot;:  ,   //port        &quot;users&quot;: [          &#123;            &quot;id&quot;: &quot; &quot;,   //id            &quot;alterId&quot;: 2,            &quot;email&quot;: &quot;t@t.tt&quot;,            &quot;security&quot;: &quot;auto&quot;          &#125;        ]      &#125;    ],    &quot;servers&quot;: null,    &quot;response&quot;: null  &#125;,    &quot;streamSettings&quot;: &#123;    &quot;network&quot;: &quot;ws&quot;,    &quot;security&quot;: &quot;tls&quot;,    &quot;tlsSettings&quot;: &#123;      &quot;allowInsecure&quot;: true,      &quot;serverName&quot;: &quot; &quot;    //domain address    &#125;,    &quot;tcpSettings&quot;: null,    &quot;kcpSettings&quot;: null,    &quot;wsSettings&quot;: &#123;      &quot;connectionReuse&quot;: true,      &quot;path&quot;: &quot;/e3137ae7/&quot;,   //path      &quot;headers&quot;: &#123;        &quot;Host&quot;: &quot; &quot;  //domain address      &#125;    &#125;,    &quot;httpSettings&quot;: null,    &quot;quicSettings&quot;: null  &#125;,  &quot;mux&quot;: &#123;    &quot;enabled&quot;: true,    &quot;concurrency&quot;: 8  &#125;&#125;,&#123;  &quot;tag&quot;: &quot;direct&quot;,  &quot;protocol&quot;: &quot;freedom&quot;,  &quot;settings&quot;: &#123;    &quot;vnext&quot;: null,    &quot;servers&quot;: null,    &quot;response&quot;: null  &#125;,  &quot;streamSettings&quot;: null,  &quot;mux&quot;: null&#125;,&#123;  &quot;tag&quot;: &quot;block&quot;,  &quot;protocol&quot;: &quot;blackhole&quot;,  &quot;settings&quot;: &#123;    &quot;vnext&quot;: null,    &quot;servers&quot;: null,    &quot;response&quot;: &#123;      &quot;type&quot;: &quot;http&quot;    &#125;  &#125;,  &quot;streamSettings&quot;: null,  &quot;mux&quot;: null&#125;],&quot;stats&quot;: null,&quot;api&quot;: null,&quot;dns&quot;: null,&quot;routing&quot;: &#123;&quot;domainStrategy&quot;: &quot;IPIfNonMatch&quot;,&quot;rules&quot;: [  &#123;    &quot;type&quot;: &quot;field&quot;,    &quot;port&quot;: null,    &quot;inboundTag&quot;: [      &quot;api&quot;    ],    &quot;outboundTag&quot;: &quot;api&quot;,    &quot;ip&quot;: null,    &quot;domain&quot;: null  &#125;]&#125;&#125;</code></pre></li></ul></li></ul><h2 id="Terminal-Proxy"><a href="#Terminal-Proxy" class="headerlink" title="Terminal Proxy"></a>Terminal Proxy</h2><h3 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h3><p>i can make some terminal commands run with proxy. But it seems can’t work on my computer. Sad. Anyway, i still share the way to install and configure.</p><ul><li>Installation</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S proxychains</code></pre><p>Or you can install it from source code. (make sure your <code>gcc</code> installed)</p><pre><code class="line-numbers language-bash">git clone https://github.com/rofl0r/proxychains-ngcd proxychains-ng./configuresudo make &amp;&amp; make installsudo make install-config(generate config file)</code></pre><ul><li>Configuration<br>config file is saved in <code>/etc/proxychains.conf</code></li></ul><p>Add <code>socks5  127.0.0.1 1080</code> to the end. note the space!</p><ul><li>Use</li></ul><p>Add <code>proxychains</code> before the terminal commands.</p><pre><code class="line-numbers language-bash">proxychains git clone https://github.com/rofl0r/proxychains-ng</code></pre><p>you can run <code>npm</code> , <code>docker</code> … But <code>ping</code> command is not suitable, because proxychains can only proxy <strong>TCP</strong>, and <code>ping</code> is use <strong>ICMP</strong>.</p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>You may need to configure a proxy server if you’re having trouble cloning or fetching from a remote repository or getting an error like unable to access <code>Couldn&#39;t resolve host</code>.</p><p>Consider something like:</p><pre><code class="line-numbers language-bash">git config --global http.proxy http://proxyUsername:proxyPassword@proxy.server.com:port</code></pre><p>i use <code>git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;</code> to set my git cause i use socks5.</p><p>i also use <code> git config --local http.proxy &#39;socks5://127.0.0.1:1080&#39;</code> to set my local config that can only work in ‘git clone’ repositories.</p><p>Check global proxy:</p><pre><code class="line-numbers language-bash">git config --global http.proxy</code></pre><p>Check local proxy:</p><pre><code class="line-numbers language-bash">git config --local http.proxy</code></pre><p>Cancel proxy:</p><pre><code class="line-numbers language-bash">git config --global --unset http.proxy</code></pre><pre><code class="line-numbers language-bash">git config --local --unset http.proxy</code></pre><h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>Create <code>.wgetrc</code> file in home directory.</p><pre><code class="line-numbers language-bash">use_proxy=yeshttp_proxy=127.0.0.1:1080https_proxy=127.0.0.1:1080</code></pre><p>it can only use http proxy.</p>]]></content>
      
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Horner&#39;s Method</title>
      <link href="/2020/02/02/horner-s-method/"/>
      <url>/2020/02/02/horner-s-method/</url>
      
        <content type="html"><![CDATA[<h3 id="Function-vs-Polynomial"><a href="#Function-vs-Polynomial" class="headerlink" title="Function vs Polynomial"></a>Function vs Polynomial</h3><ul><li>f(x) means a function, any function<ul><li>$$ f(x) = \sin (e^x) + \ln ( \frac{1}{x^2+1} ) $$</li><li>$$ f(x) = \alpha x^3 - \arctan(x) $$</li></ul></li><li>p(x) means a polynomial function<ul><li>$$ p(x) = dx^3 + cx^2 + bx + a $$</li><li>$$ p(x) = a + bx + cx^2 + dx^3 $$</li></ul></li><li>evaluating p(x) can be slow<ul><li>$$ p(x) = a + bx + cx^2 + dx^3 $$</li><li>$$ p(x) = a + b \times x + c \times x \times x + d \times x \times x \times x $$</li></ul></li></ul><p>It include <strong>4 additions</strong> and <strong>6 multiplications</strong></p><h3 id="Horner’s-Method"><a href="#Horner’s-Method" class="headerlink" title="Horner’s Method"></a>Horner’s Method</h3><ul><li>Rewrite p(x)<ul><li>$$ p(x) = a + bx + cx^2 + dx^3 $$</li><li>$$ p(x) = a + bx + x(cx + dx^2) $$</li><li>$$ p(x) = a + x(b + x(cx + dx)) $$</li><li>$$ p(x) = a + x \times (b + x \times (c + d \times x)) $$</li></ul></li></ul><p>It include <strong>3 additions</strong> and <strong>3 multiplications</strong></p><ul><li>In terms of $a_n$<ul><li>$$ p(x) = a_0 + a_1x + a_2x^2 + a_3x^3 + \cdots + a_nx^n $$</li><li>$$ p(x) = a_0x^0 + a_1x + a_2x^2 + a_3x^3 + \cdots + a_nx^n  = \sum_{i=0}^{n} a_i x^i $$</li><li>$$ p(x) = a_0 +x(a_1 + x(a_2 + \cdots + x(a_{n-1} + xa_n    ) \cdots )) $$</li><li>$$p(x) = p_0(x) where p_i(x) = \begin{cases} a_i + x \times p_{i+1}(x), if i &lt; n \ a_n, if i = n \end{cases}$$</li></ul></li></ul><h4 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h4><p>Give the value of coefficient $a_0$, $a_1$, $\cdots$, $a_n$ and $x$.</p><pre><code class="line-numbers language-python">y = 0for i = n downto 0  y = a_i + xy</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SORT</title>
      <link href="/2020/01/29/sort/"/>
      <url>/2020/01/29/sort/</url>
      
        <content type="html"><![CDATA[<h2 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h2><h3 id="1-BUBBLE-SORT"><a href="#1-BUBBLE-SORT" class="headerlink" title="1. BUBBLE SORT"></a>1. BUBBLE SORT</h3><pre><code class="line-numbers language-python">BUBBLE-SORT(A)//A:sort arrayfor i = 1 to A.length - 1  for j = A.length to i + 1    if A[j] &lt; A[j-1]      swap(A[j], A[j-1]</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/BUBBLE_SORT.gif" alt="BUBBLE_SORT"> </p><p>$$ \Theta (n^2) $$</p><h3 id="2-INSERTION-SORT"><a href="#2-INSERTION-SORT" class="headerlink" title="2. INSERTION SORT"></a>2. INSERTION SORT</h3><pre><code class="line-numbers language-python">INSERTION-SORT(A)//A:sort arrayfor j = 2 to A.length  key = A[j]  //Insert A[j] into the sorted sequence A[1..j-1]  i = j - 1  while i &gt; 0 and A[i] &gt; key    A[i+1] = A[i]    i = i - 1  A[i+1] = key</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/INSERTION_SORT.gif" alt="INSERTION_SORT"> </p><p>$$ \Theta (n^2) $$</p><h3 id="3-SELECT-SORT"><a href="#3-SELECT-SORT" class="headerlink" title="3. SELECT SORT"></a>3. SELECT SORT</h3><pre><code class="line-numbers language-python">SELECT-SORT(A)//A:sort arrayfor i = 1 to range(i,A.length)  min = A[i]  for j = 1 to A.length    if min &gt; A[j]      min = A[j]      min_index = j  swap(A[i],A[min_index])</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/SELECT_SORT.gif" alt="SELECT_SORT"> </p><p>$$ \Theta (n^2) $$</p><h3 id="4-MERGE-SORT"><a href="#4-MERGE-SORT" class="headerlink" title="4. MERGE SORT"></a>4. MERGE SORT</h3><pre><code class="line-numbers language-python">MERGE-SORT(A, p, r)//A:sort array//p:begin index//r:end indexif p &lt; r  q = [(p + r) / 2]  MERGE-SORT(A, p, q)  MERGE-SORT(A, q+1, r)  MERGE(A, p, q, r)MERGE(A, p, q, r)//A:sort array//p:begin index//q:mid index//r:end indexn1 = q - p + 1n2 = r - qLet L[1..n1 + 1] and R[1..n2 + 1] be new arraysfor i = 1 to n1  L[i] = A[p + i - 1]for j = 1 to n2  R[j] = A[q + j]L[n1 + 1] = infinityR[n2 + 1] = infinityi = 1j = 1for k = p to r  if L[i] &lt;= R[j]    A[k] = L[i]    i = i + 1  else    A[k] = R[j]    j = j + 1</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/SORT/MERGE_SORT.gif" alt="MERGE_SORT"> </p><p>$$ \Theta (n) $$</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/08/17/leetcode-easy-9/">LeetCode EASY_9</a></li><li><a href="https://godliuyang.wang/2020/03/30/scikit-image-guide/">scikit-image guide</a></li><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux + i3wm详细配置篇</title>
      <link href="/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/"/>
      <url>/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Arch-linux-i3"><a href="#Arch-linux-i3" class="headerlink" title="Arch linux + i3"></a>Arch linux + i3</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/img.jpg" alt="arch+i3"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/main.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/albert.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/music.png"> </p><h2 id="Installation-guide"><a href="#Installation-guide" class="headerlink" title="Installation guide"></a>Installation guide</h2><h3 id="1-Boot-the-live-environment"><a href="#1-Boot-the-live-environment" class="headerlink" title="1. Boot the live environment"></a>1. Boot the live environment</h3><p>The live environment can be booted from a USB flash device, an optical disc or a network with PXE. </p><h3 id="2-Connect-the-Internet"><a href="#2-Connect-the-Internet" class="headerlink" title="2. Connect the Internet"></a>2. Connect the Internet</h3><pre><code class="line-numbers language-bash">wifi-menu</code></pre><p>Use <code>ping www.archlinux.org</code> to verify the connection.</p><h3 id="3-Update-the-system-clock"><a href="#3-Update-the-system-clock" class="headerlink" title="3. Update the system clock"></a>3. Update the system clock</h3><p>Use <code>tiledatectl</code> to ensure the system colck is accurate</p><pre><code class="line-numbers language-bash">timedatectl set-ntp true</code></pre><p>To check the service status, use <code>timedatectl status</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/1.png" alt="timedate"> </p><h3 id="4-Partition-the-disks"><a href="#4-Partition-the-disks" class="headerlink" title="4. Partition the disks"></a>4. Partition the disks</h3><p>When recognized by the live system, disks are assigned to a block device such as <code>/dev/sda</code> or <code>/dev/nvme0n1</code> . To identify these devices, use <code>lsblk</code> or <code>fdisk</code> .</p><pre><code class="line-numbers language-bash">fdisk -l</code></pre><p>Use <a href="https://wiki.archlinux.org/index.php/Fdisk">fdisk</a> or <a href="https://wiki.archlinux.org/index.php/Parted">parted</a> to modify partition tables. </p><p>for example: </p><pre><code class="line-numbers language-bash"># parted /dev/sda(parted) mklabelNew disk label type? gpt(parted) exit</code></pre><p>Use <code>cfdisk</code> to create partition.    </p><p>It should include <strong>EFI</strong> , <strong>/</strong> (root), <strong>/home</strong> , <strong>/swap</strong> .</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/2.png" alt="Disks"> </p><h3 id="5-Format-the-partitions"><a href="#5-Format-the-partitions" class="headerlink" title="5. Format the partitions"></a>5. Format the partitions</h3><p>Note the correct partitions</p><ul><li>EFI partition</li></ul><pre><code class="line-numbers language-bash">mkfs.vfat /dev/sda2</code></pre><ul><li>root and home partition</li></ul><pre><code class="line-numbers language-bash">mkfs.ext4 /dev/sda3mkfs.ext4 /dev/sda4</code></pre><ul><li>swap partition</li></ul><pre><code class="line-numbers language-bash">mkswap -f /dev/sda5swapon /dev/swap</code></pre><h3 id="6-Mount-the-file-systems"><a href="#6-Mount-the-file-systems" class="headerlink" title="6. Mount the file systems"></a>6. Mount the file systems</h3><p>Pay attention to the <strong>order</strong> of mounting partitions!</p><ul><li>mount the file system on the root partition to <code>/mnt</code></li></ul><pre><code class="line-numbers language-bash">mount /dev/sda3 /mnt</code></pre><ul><li>create <strong>home</strong> folder in <code>/mnt</code> folder and mount the file system on the home partition to <code>/mnt/home</code></li></ul><pre><code class="line-numbers language-bash">mkdir /mnt/homemount /dev/sda4 /mnt/home</code></pre><ul><li>create <strong>/mnt/boot/EFI</strong> folder and mount the file system on the EFI partition to <code>/mnt/boot/EFI</code></li></ul><pre><code class="line-numbers language-bash">mkdir /mnt/bootmkdir /mnt/boot/EFImount /dev/sda2 /mnt/boot/EFI</code></pre><h3 id="7-Select-the-mirrors"><a href="#7-Select-the-mirrors" class="headerlink" title="7. Select the mirrors"></a>7. Select the mirrors</h3><pre><code class="line-numbers language-bash">vim /etc/pacman.d/mirrorlist</code></pre><p>Paste the China mirrors in the beginning</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/3.png" alt="mirrorlist"> </p><h3 id="8-Install-essential-packages"><a href="#8-Install-essential-packages" class="headerlink" title="8. Install essential packages"></a>8. Install essential packages</h3><pre><code class="line-numbers language-bash">pacstrap /mnt base linux linux-firmware</code></pre><h3 id="9-Generate-an-fstab-file"><a href="#9-Generate-an-fstab-file" class="headerlink" title="9. Generate an fstab file"></a>9. Generate an <strong>fstab</strong> file</h3><pre><code class="line-numbers language-bash">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code></pre><p>Check the resulting <code>/mnt/etc/fstab</code> file, and edit it in case of errors.</p><pre><code class="line-numbers language-bash">cat /mnt/etc/fstab</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/4.png" alt="fstab"> </p><h3 id="10-Change-root-into-the-new-system"><a href="#10-Change-root-into-the-new-system" class="headerlink" title="10. Change root into the new system"></a>10. Change root into the new system</h3><pre><code class="line-numbers language-bash">arch-chroot /mnt</code></pre><h3 id="11-Time-zone"><a href="#11-Time-zone" class="headerlink" title="11. Time zone"></a>11. Time zone</h3><pre><code class="line-numbers language-bash">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc.localtimehwclock --systohc</code></pre><h3 id="12-Localozation-Language"><a href="#12-Localozation-Language" class="headerlink" title="12. Localozation(Language)"></a>12. Localozation(Language)</h3><ul><li>Uncomment <code>en_US.UTF-8 UTF-8</code> and others needed locals in <code>/etc/locale.gen</code> , and generate them with:</li></ul><pre><code class="line-numbers language-bash">locale-gen</code></pre><ul><li>Create the <code>locale.conf</code> file, and set <code>LANG</code> variable accordingly:</li></ul><pre><code class="line-numbers language-bash">vim /etc/locale.confLANG=en_US.UTF-8</code></pre><h3 id="13-Initramfs"><a href="#13-Initramfs" class="headerlink" title="13. Initramfs"></a>13. Initramfs</h3><pre><code class="line-numbers language-bash">mkinitcpio -P</code></pre><h3 id="14-Root-password"><a href="#14-Root-password" class="headerlink" title="14. Root password"></a>14. Root password</h3><pre><code class="line-numbers language-bash">passwd root</code></pre><h3 id="15-Network-configuration"><a href="#15-Network-configuration" class="headerlink" title="15. Network configuration"></a>15. <a href="https://wiki.archlinux.org/index.php/Network_configuration">Network configuration</a></h3><ul><li>Create the <strong>hostname</strong> file</li></ul><pre><code class="line-numbers language-bash">vim /etc/hostname</code></pre><p>Enter your hostname in this file.</p><ul><li>Add matching entries to <strong>hosts</strong></li></ul><pre><code class="line-numbers language-bash">vim /etc/hosts</code></pre><pre><code>127.0.0.1    localhost::1          localhost127.0.0.1    yourhostname.localdomain    yourhostname</code></pre><ul><li>Install some software to ensure you can connect the Internet after reboot system.</li></ul><pre><code class="line-numbers language-bash">pacman -S iw wpa_supplicant dialog networkmanager</code></pre><p><a href="#nm">Detailed configuration</a> </p><h3 id="16-Microcode"><a href="#16-Microcode" class="headerlink" title="16. Microcode"></a>16. <a href="https://wiki.archlinux.org/index.php/Microcode">Microcode</a></h3><p>My computer is <code>Intel</code> processors.</p><pre><code class="line-numbers language-bash">pacman -S intel-ucode</code></pre><h3 id="17-Boot-loader"><a href="#17-Boot-loader" class="headerlink" title="17. Boot loader"></a>17. <a href="https://wiki.archlinux.org/index.php/Arch_boot_process#Boot_loader">Boot loader</a></h3><p><a href="https://wiki.archlinux.org/index.php/GRUB"><strong>GRUB</strong></a> </p><pre><code class="line-numbers language-bash">pacman -S grub efibootmgrgrub-install --target=x86_64-efi --efi-directory=/boot/EFI -bootloader-id=Archlinuxgrub-mkconfig -o /boot/grub/grub.cfg</code></pre><p>If you can see some <code>img</code> file generated, it means the grub boot loader file are successful creatted.</p><h3 id="18-Reboot"><a href="#18-Reboot" class="headerlink" title="18. Reboot"></a>18. Reboot</h3><pre><code class="line-numbers language-bash">exitumount -R /mntreboot</code></pre><p>Use <code>uname -a</code> to view the Version of Arch linux.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/5.png" alt="Arch_linux Version"> </p><h2 id="My-config-recommendations"><a href="#My-config-recommendations" class="headerlink" title="My config recommendations"></a>My config recommendations</h2><h3 id="1-Add-users"><a href="#1-Add-users" class="headerlink" title="1. Add users"></a>1. Add users</h3><pre><code class="line-numbers language-bash">useradd -s -G wheel -s /bin/bash username</code></pre><p>To allow user to gain full root privileges when he precdeds a command with <code>sudo</code> , add the following line to <code>/etc/sudoers</code> .</p><pre><code class="line-numbers language-bash">USER_NAME ALL=(ALL) ALL</code></pre><p><code>su username</code> to switch users.</p><h3 id="2-NetworkManager"><a href="#2-NetworkManager" class="headerlink" title="2. NetworkManager "></a>2. <a id = "nm"><a href="https://wiki.archlinux.org/index.php/NetworkManager">NetworkManager</a> </a></h3><p>NetworkManager(package <code>networkmanager</code> ) contains a daemon, a command line interface( <code>nmcli</code> ) and a curses-based interface( <code>nmtui</code> ). After installation, you should <strong>enable the daemon</strong>.</p><pre><code class="line-numbers language-bash">systemctl enable NetworkManager.servicesystemctl start NetworkManager.service</code></pre><p>Use <code>ip link</code> to view the network interface.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/6.png" alt="Network interface"> </p><p><strong>Usage</strong></p><ul><li>List nearby wifi networks</li></ul><pre><code class="line-numbers language-bash">nmcli device wifi list</code></pre><ul><li>Connect to a wifi network</li></ul><pre><code class="line-numbers language-bash">nmcli device wifi connect SSID password password</code></pre><ul><li>Disconnect an interface</li></ul><pre><code class="line-numbers language-bash">nmcli device disconnect ifname eth0</code></pre><ul><li>See a list of network devices and wheir state</li></ul><pre><code class="line-numbers language-bash">nmcli device</code></pre><ul><li>Turn off wifi</li></ul><pre><code class="line-numbers language-bash">nmcli radio wifi off</code></pre><p><code>nm-applet</code> for a system tray applet</p><pre><code class="line-numbers language-bash">sudo pacman -S network-manager-applet</code></pre><ul><li>Add <code>exec --no-startup-id nm-applet</code> to <code>~/.config/i3/config</code> fot autostart <code>nm-applet</code> .</li></ul><h3 id="3-Xorg-display-server"><a href="#3-Xorg-display-server" class="headerlink" title="3. Xorg display server"></a>3. <a href="https://wiki.archlinux.org/index.php/Xorg">Xorg</a> display server</h3><ul><li>Installation</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S xorg xorg-server xorg-apps</code></pre><ul><li><p>Driver installation</p><ol><li>First, identify your card:</li></ol><pre><code class="line-numbers language-bash">lspci | grep -e VGA -e 3D</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/7.png" alt="card"> </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/8.png"> </p><ol start="2"><li>Install an appropriate deiver</li></ol><pre><code class="line-numbers language-bash">pacman -Ss xf86-video</code></pre><p><strong>Note</strong> : For NVIDIA Optimus enabled laptop which uses an integrated video card combined with a dedicated GPU, You  <strong>can not</strong> just install <code>xf86-video-intel</code> &amp; <code>nvidia</code> , it will get a blcak screen. See <a href="https://wiki.archlinux.org/index.php/NVIDIA_Optimus">NVIDIA Optimus</a> to get more informations. </p><p>I just install <code>xf86-video-vesa</code> . </p><pre><code class="line-numbers language-bash">pacman -S xf86-video-vesa</code></pre><p><a href="https://wiki.archlinux.org/index.php/Xorg#Driver_installation">Xorg: Driver_installtion</a> </p></li><li><p>Use <a href="https://wiki.archlinux.org/index.php/Xinit">xinit</a> to start Xorg display server.</p></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S xorg-xinit</code></pre><ul><li>Create <code>.xinitrc</code> file(in common users)</li></ul><pre><code class="line-numbers language-bash">sudo cp /etc/X11/xinit/xinitrc ~/.xinitrc</code></pre><ul><li>Tap-to-click</li></ul><pre><code class="line-numbers language-bash">sudo vim /etc/X11/xorg.conf.d/30-touchpad.conf</code></pre><p>Add the following lines to it.</p><pre><code>Section &quot;InputClass&quot;  Identifier &quot;touchpad&quot;  Driver &quot;libinput&quot;  MatchIsTouchpad &quot;on&quot;  Option &quot;Tapping&quot; &quot;on&quot;EndSection</code></pre><ul><li>Install Windows Manager (i3)</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S i3</code></pre><p>It include <code>i3-gaps</code> , <code>i3wm</code> , <code>i3blocks</code> , <code>i3lock</code> , <code>i3status</code></p><ul><li>Use i3</li></ul><p>Add <code>exec i3</code> to the end of <code>~.xinitrc</code> .</p><ul><li>Start Xorg server.</li></ul><pre><code class="line-numbers language-bash">startx</code></pre><ul><li>Autostart X at login</li></ul><p>I’m a <a href="https://fishshell.com/">fish</a> user, so i just need add the following to the bottom of my <code>~/.config/fish/config.fish</code> .</p><pre><code class="line-numbers language-bash"># Start X at loginif status is-login    if test -z &quot;$DISPLAY&quot; -a $XDG_VTNR = 1        exec startx -- -keeptty    endend</code></pre><p>Other shell user (like <strong>bash</strong> , <strong>zsh</strong> ), Please visit <a href="https://wiki.archlinux.org/index.php/Xinit#Autostart_X_at_login">here</a> </p><h3 id="4-i3wm"><a href="#4-i3wm" class="headerlink" title="4. i3wm"></a>4. i3wm</h3><p><a href="https://i3wm.org/">i3wm</a>  ,   <a href="https://wiki.archlinux.org/index.php/I3">i3-ArchWiki</a> </p><p><a href="https://github.com/liuyaanng/Arch_linux#i3-and-i3status">My i3 config</a> </p><h3 id="5-Some-useful-software"><a href="#5-Some-useful-software" class="headerlink" title="5. Some useful software"></a>5. Some useful software</h3><ul><li>yaourt</li></ul><p>Add the source to <code>/etc/pacman.conf</code></p><pre><code>[archlinuxcn]#The Chinese Arch Linux communities packages.SigLevel = Optional TrustAllServer = http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch#Server   = http://repo.archlinuxcn.org/$arch#Server   = http://repo.archlinux.fr/$arch</code></pre><p>Synchronized communities</p><pre><code class="line-numbers language-bash">sudo pacman -Syu</code></pre><p>Insatll yaourt </p><pre><code class="line-numbers language-bash">sudo pacman -S yaourt</code></pre><ul><li><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/#toc-heading-13">Software i often use</a></li></ul><h3 id="6-Fonts"><a href="#6-Fonts" class="headerlink" title="6. Fonts"></a>6. Fonts</h3><p><a href="https://wiki.archlinux.org/index.php/Fonts">Fonts-ArchWiki</a> , <a href="https://github.com/ryanoasis/nerd-fonts">Nerd-fonts</a> , <a href="https://unicode-table.com/en/">Unicode-table</a>  </p><table><thead><tr><th align="center">adobe-source-code-pro</th><th align="center">adobe-source-han-serif-cn-fonts</th><th align="center">adobe-source-han-serif-tw-fonts</th></tr></thead><tbody><tr><td align="center">ttf-symbola</td><td align="center">nerd-fonts-complete</td><td align="center">nerd-fonts-dejavu-complete</td></tr><tr><td align="center">font-awesome</td><td align="center">noto-fonts-emoji</td><td align="center"></td></tr></tbody></table><p><code>fc-list</code> to show the fonts you have installed.</p><h3 id="7-Volume"><a href="#7-Volume" class="headerlink" title="7. Volume"></a>7. Volume</h3><ul><li><p>ALSA is a set of built-in GNU/Linux modules. Therefore, manual insatllation is not necessary.</p></li><li><p>Install <strong>pulseaudio</strong></p></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S pulseaudio</code></pre><ul><li>Install <strong>alsa-utils</strong></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S alsa-utils</code></pre><p>Use <code>alsamixer</code> to manage the system volume</p><ul><li>VoulmeIcon</li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/9.png" alt="VolumeIcon"> </p><p>If you want a System volume tray, you can try <strong>volumeicon</strong></p><ol><li><p>Install volumeicon</p><pre><code class="line-numbers language-bash">sudo pacman -S volumeicon</code></pre></li><li><p>Add <code>volumeicon</code> file in <code>~/.config/volumeicon</code>  , and add the following lines to it.</p><pre><code class="line-numbers language-bash">[Alsa]card=default[Notification]show_notification=truenotification_type=1[StatusIcon]stepsize=5onclick=xterm -e &#39;alsamixer&#39;theme=White Gnomeuse_panel_specific_icons=truelmb_slider=truemmb_mute=trueuse_horizontal_slider=falseshow_sound_level=trueuse_transparent_bac&lt;++&gt;kground=true[Hotkeys]up_enabled=truedown_enabled=truemute_enabled=trueup=XF86AudioRaiseVolumedown=XF86AudioLowerVolumemute=XF86AudioMute</code></pre></li><li><p>Create <code>pulseaudio-ctl.desktop</code> in <code>~/.config/autostart</code> , and add the following lines to it.</p><pre><code class="line-numbers language-bash">[Desktop Entry]Encoding=UTF-8Type=ApplicationName=pulseaudio-ctlcomment=Set Volume to 70%Exec=pulseaudio-ctl-normalStartupNotify=trueTerminal=falseHidden=false</code></pre></li><li><p>Add <code>exec --no-startup-id volumeicon</code> to <code>~/.config/i3/config</code> .</p></li><li><p>I wrote two scripts to control the volume of the system with <code>alsamixer</code> and <code>dunst</code> , put them to <code>/usr/bin/</code> .</p><p><a href="https://github.com/liuyaanng/Arch_linux/blob/master/volume_up.sh">volume_up</a><br><a href="https://github.com/liuyaanng/Arch_linux/blob/master/volume_down.sh">volume_down</a> </p></li></ol><h3 id="8-Screen-brightness"><a href="#8-Screen-brightness" class="headerlink" title="8. Screen brightness"></a>8. Screen brightness</h3><p>A good advice for backlight management is <code>xorg-xbacklight</code> , but it seems not work on my computer. </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/12.png" alt="xbacklight -error"> </p><p>If you have the same problem, you can try the solution of Wiki, but it still can’t work on my computer. Sad! So i try another way to control the screen brightness.<br>The backlight can be controlled by the file <code>/sys/class/backlight/intel_backlight/brightness</code> ‘s value. So i wrote a script to control it. I named it <code>intel_brightness_control.sh</code></p><pre><code class="line-numbers language-bash">#!/bin/bashset -efile=&quot;/sys/class/backlight/intel_backlight/brightness&quot;current=$(cat &quot;$file&quot;)new=&quot;$current&quot;if [ &quot;$1&quot; = &quot;-inc&quot; ]then  new=$(( current + $2 ))  status=&quot;Up&quot;fiif [ &quot;$1&quot; = &quot;-dec&quot; ]then  if [ current &lt; 100 ]  then    new=&quot;50&quot;  else    new=$(( current - $2 ))  fi  status=&quot;Down&quot;fiecho &quot;$new&quot; | tee &quot;$file&quot;brightness=`light -G`notify-send &quot;Brightness $status($brightness%)&quot;</code></pre><p>Remember put it in your <code>/usr/bin/</code>.</p><p>Then do <code>sudo chmod 777 /sys/class/backlight/intel_backlight/brightness</code> . The last thing is adding the following lines to <code>.config/i3/config</code> .</p><pre><code class="line-numbers language-bash"># Screen brightness controlsbindsym XF86MonBrightnessUp exec &quot;intel_brightness_control.sh -inc 100&quot;bindsym XF86MonBrightnessDown exec &quot;intel_brightness_control.sh -dec 100&quot;</code></pre><h3 id="9-Bluetooth"><a href="#9-Bluetooth" class="headerlink" title="9. Bluetooth"></a>9. Bluetooth</h3><ul><li>Install <strong>bluez</strong> , <strong>bluez-utils</strong></li></ul><pre><code class="line-numbers language-bash">sudo pacman -S bluez bluez-utils</code></pre><ul><li>The generic Bluetooth driver is the <code>btusb</code> Kernel module. Use <code>lsmod</code> to check whether that module is loaded. </li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/11.png" alt="btusb module"><br>  If it’s not, do <code>modprobe btusb</code> to load the moudle.</p><ul><li>Start / Enable</li></ul><pre><code class="line-numbers language-bash">systemctl enable bluetooth.servicesystemctl start bluetooth.service</code></pre><ul><li>Auto power-on after boot</li></ul><p>Add the line <code>AutoEnable=true</code> in <code>/etc/bluetooth/main.conf</code> at the bottom in the <code>[Policy]</code> section.</p><ul><li>Discoverable on startup</li></ul><pre><code class="line-numbers language-bash">/etc/bluetooth/main.conf[General]DiscoverableTimeout = 0Discoverable=true</code></pre><ul><li>Install <strong>pulseaudio-bluetooth</strong> to use audio equipment like bluetooth headphones or speakers.</li></ul><p><a href="https://wiki.archlinux.org/index.php/Bluetooth_headset">Bluetooth headset</a> </p><pre><code class="line-numbers language-bash">sudo pacman -S pulseaudio-bluetooth</code></pre><ul><li>Install <a href="https://github.com/blueman-project/blueman">blueman</a> </li></ul><pre><code class="line-numbers language-bash">sudo pacman -S blueman</code></pre><ol><li><code>blueman-applet</code> to use.</li><li>add <code>exec --no-startup-id blueman-applet</code> to <code>~/.config/i3/config</code> to auto start <code>blueman-applet</code> .</li></ol><h3 id="10-Notify-Dunst"><a href="#10-Notify-Dunst" class="headerlink" title="10. Notify(Dunst)"></a>10. Notify(Dunst)</h3><pre><code class="line-numbers language-bash">sudo pacman -S libnotify dunst</code></pre><p>Create <code>org.freedesktop.Notifications.service</code> in <code>/usr/share/dbus-1/services/</code> folder. Add the following lines.</p><pre><code>[D-BUS Service]Name.org.freedesktop.NotificationsExec=/usr/local/bin/dunst</code></pre><p>An example configuration file is included at <code>/usr/local/share/dunst/dunstrc</code> . Copy this file to <code>~/.config/dunst/dunstrc</code> and edit it accordingly.</p><p><a href="https://github.com/liuyaanng/Arch_linux/tree/master/dunst">My Dunstrc</a> </p><p>Use <code>notify-send &quot;Hello, world!&quot; </code> to test.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Arch-Linux/10.png" alt="Dunst"> </p><h3 id="11-Shutdown-Reboot-LockScreen"><a href="#11-Shutdown-Reboot-LockScreen" class="headerlink" title="11. Shutdown Reboot LockScreen"></a>11. Shutdown Reboot LockScreen</h3><ul><li>Create a script named <code>i3exit</code> . Make sure you have <code>polkit</code> installed. </li></ul><pre><code class="line-numbers language-bash">#!/bin/shlock() &#123;    i3lock&#125;case &quot;$1&quot; in    lock)        blurlock        ;;    logout)        i3-msg exit        ;;    suspend)        blurlock &amp;&amp; systemctl suspend        ;;    hibernate)        blurlock &amp;&amp; systemctl hibernate        ;;    reboot)        systemctl reboot        ;;    shutdown)        systemctl poweroff        ;;    *)        echo &quot;Usage: $0 &#123;lock|logout|suspend|hibernate|reboot|shutdown&#125;&quot;        exit 2esacexit 0</code></pre><p>Do <code>chmod +x</code> and put it in <code>$PATH</code> ( <code>/usr/bin/</code> ) .</p><ul><li>Add the following lines to <code>.config/i3/config</code></li></ul><pre><code class="line-numbers language-bash">set $mode_system System (l) lock, (e) logout, (s) suspend, (h) hibernate, (r) reboot, (Shift+s) shutdownmode &quot;$mode_system&quot; &#123;    bindsym l exec --no-startup-id i3exit lock, mode &quot;default&quot;    bindsym e exec --no-startup-id i3exit logout, mode &quot;default&quot;    bindsym s exec --no-startup-id i3exit suspend, mode &quot;default&quot;    bindsym h exec --no-startup-id i3exit hibernate, mode &quot;default&quot;    bindsym r exec --no-startup-id i3exit reboot, mode &quot;default&quot;    bindsym Shift+s exec --no-startup-id i3exit shutdown, mode &quot;default&quot;      # back to normal: Enter or Escape    bindsym Return mode &quot;default&quot;    bindsym Escape mode &quot;default&quot;&#125;bindsym $mod+Pause mode &quot;$mode_system&quot;</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/">Manjaro i3wm 高效率环境配置篇(持续更新)</a></li></ul></div>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> i3wm </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bilibili-Evolved</title>
      <link href="/2019/09/21/bilibili-evolved/"/>
      <url>/2019/09/21/bilibili-evolved/</url>
      
        <content type="html"><![CDATA[<h2 id="Bilibili-Evolved"><a href="#Bilibili-Evolved" class="headerlink" title="Bilibili-Evolved"></a>Bilibili-Evolved</h2><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/2.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/3.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/4.png"></p><h3 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h3><ul><li><p>You should install <a href="https://www.tampermonkey.net/">Tampermonkey</a> first.</p></li><li><p><a href="https://greasyfork.org/en/scripts/373563-bilibili-evolved">Bilibili-Evolved</a></p></li></ul><p>Please access <a href="https://github.com/the1812/Bilibili-Evolved">GitHub</a> to view how to use it.</p><h3 id="2-Download-videos"><a href="#2-Download-videos" class="headerlink" title="2. Download videos"></a>2. Download videos</h3><h4 id="2-1-Download-single-video"><a href="#2-1-Download-single-video" class="headerlink" title="2.1 Download single video."></a>2.1 Download single video.</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/5.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/6.png"></p><h4 id="2-2-Batch-export-with-aria2"><a href="#2-2-Batch-export-with-aria2" class="headerlink" title="2.2 Batch export(with aria2)."></a>2.2 Batch export(with aria2).</h4><ul><li>Install aria2.</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S aria2</code></pre><ul><li>export aria2(a txt file)</li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Bilibili-Evolved/7.png"></p><ul><li>Download videos in current directory.</li></ul><pre><code class="line-numbers language-bash">aria2c -i Download.txt</code></pre><h3 id="3-Convert-video-files"><a href="#3-Convert-video-files" class="headerlink" title="3. Convert video files."></a>3. Convert video files.</h3><p>The default video files format is <code>flv</code>.<br>I recommend using <a href="http://ffmpeg.org/">ffmpeg</a> to convert video files format on Linux.</p><pre><code class="line-numbers language-bash">ffmpeg -i input.flv output.mp4</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bilibili.com </tag>
            
            <tag> Script </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git &amp; Github</title>
      <link href="/2019/09/18/git-github/"/>
      <url>/2019/09/18/git-github/</url>
      
        <content type="html"><![CDATA[<h3 id="1-When-i-download-files-from-GitHub-Failed-to-connect-to-127-0-0-1-port-1080-Connection-refused"><a href="#1-When-i-download-files-from-GitHub-Failed-to-connect-to-127-0-0-1-port-1080-Connection-refused" class="headerlink" title="1. When i download files from GitHub, Failed to connect to 127.0.0.1 port 1080: Connection refused"></a>1. When i download files from GitHub, <code>Failed to connect to 127.0.0.1 port 1080: Connection refused</code></h3><ol><li>Find wheather you are using proxy server or not.</li></ol><pre><code class="line-numbers language-bash">git config --global http.proxy</code></pre><ol start="2"><li>Cancel the proxy server.</li></ol><pre><code class="line-numbers language-bash">git config --global --unset http.proxy</code></pre><h3 id="2-Clone-with-SSH-Github-guide"><a href="#2-Clone-with-SSH-Github-guide" class="headerlink" title="2. Clone with SSH (Github guide)"></a>2. Clone with SSH (<a href="https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh">Github guide</a>)</h3><ul><li>Install Openssh</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S openssh</code></pre><ul><li>Generating a new SSH key</li></ul><pre><code class="line-numbers language-bash">ssh-keygen</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/1.png"> </p><pre><code class="line-numbers language-bash">tree .ssh</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/2.png"> </p><ul><li>Copy the SSH key to your clipboard</li></ul><pre><code class="line-numbers language-bash">cat .ssh/id_rsa.pub</code></pre><ul><li>In the upper-right corner of any page, click your profile photo, then click <strong>Settings</strong></li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/3.png"></p><ul><li><p>In the user settings sidebar, click <strong>SSH and GPG keys</strong></p></li><li><p>Click <strong>New SSH key</strong> or <strong>Add SSH key</strong>.</p></li><li><p>In the “Title” field, add a descriptive label for the new key. For example, if you’re using arch linux, you might call this key “Arch linux”</p></li><li><p>Paste your key into the “Key” field.</p></li></ul><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Git-Github/4.png"> </p><ul><li>If prompted, confirm your GitHub password.</li></ul><h3 id="3-Mandatory-update-of-local-repository"><a href="#3-Mandatory-update-of-local-repository" class="headerlink" title="3.Mandatory update of local repository"></a>3.Mandatory update of local repository</h3><pre><code class="line-numbers language-bash">git fetch --all &amp;&amp;  git reset --hard origin/master &amp;&amp; git pull</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda</title>
      <link href="/2019/09/18/anaconda/"/>
      <url>/2019/09/18/anaconda/</url>
      
        <content type="html"><![CDATA[<h2 id="Install-Guide"><a href="#Install-Guide" class="headerlink" title="Install Guide"></a>Install Guide</h2><p>You probably need proxy: <a href="https://godliuyang.wang/2020/02/04/about-proxy/">About Proxy</a> </p><h3 id="1-Download-Anaconda"><a href="#1-Download-Anaconda" class="headerlink" title="1. Download Anaconda"></a>1. Download <code>Anaconda</code></h3><p>Click here to download <a href="https://www.anaconda.com/distribution/">Anaconda</a></p><h3 id="2-Install-Anaconda"><a href="#2-Install-Anaconda" class="headerlink" title="2. Install Anaconda"></a>2. Install <code>Anaconda</code></h3><pre><code class="line-numbers language-bash">bash ~/Downloads/Anaconda3-2019.07-Linux-x86_64.sh</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/3.png"></p><p>Press ENTER</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/4.png"></p><p>input yes </p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/5.png"></p><p>Press ENTER<br>A few minutes later…….</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/6.png"></p><p>input yes</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/7.png"></p><p>successful installation.</p><p>You can use <code>conda -V</code> to check the version of anaconda.</p><h3 id="3-Bash-user"><a href="#3-Bash-user" class="headerlink" title="3. Bash user"></a>3. Bash user</h3><pre><code class="line-numbers language-bash">vim ~/.bashrc</code></pre><p>add the following line to your ~/.bashrc.</p><pre><code class="line-numbers language-bash">export PATH=&quot;/home/xupp/anaconda3/bin:$PATH&quot;</code></pre><p>Reboot your terminal.</p><h3 id="4-Fish-user"><a href="#4-Fish-user" class="headerlink" title="4. Fish user"></a>4. Fish user</h3><p>If your shell is <strong>fish</strong>, you probably need to configure your environment variable.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/8.png"></p><p>I use <code>set</code> command to do this.</p><pre><code class="line-numbers language-bash">set -xg</code></pre><p>Prints all global, exported variables.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/1.png"></p><p>I find the user name of anaconda path in PATH is wrong.<br>I don’t know why it is, but i know i should correct it.</p><pre><code class="line-numbers language-bash">set PATH[1] /home/kevin/anaconda3/bin</code></pre><p>it works.</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/9.png"></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/10.png"></p><h2 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h2><h3 id="1-Create-Python-environment"><a href="#1-Create-Python-environment" class="headerlink" title="1. Create Python environment"></a>1. Create Python environment</h3><pre><code class="line-numbers language-bash">conda create --name python37 python=3.7</code></pre><h3 id="2-Check-Python-Environment-you-have-created"><a href="#2-Check-Python-Environment-you-have-created" class="headerlink" title="2. Check Python Environment you have created."></a>2. Check Python Environment you have created.</h3><pre><code class="line-numbers language-bash">conda info --envs</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Anaconda/11.png"> </p><p>Where * indicates the current Python environment</p><h3 id="3-Modify-Python-environment"><a href="#3-Modify-Python-environment" class="headerlink" title="3. Modify Python environment"></a>3. Modify Python environment</h3><pre><code class="line-numbers language-bash">source activate python37</code></pre><p>and modify default Python environment</p><pre><code class="line-numbers language-bash">source deactivate</code></pre><h3 id="4-Delate-Python-environment"><a href="#4-Delate-Python-environment" class="headerlink" title="4. Delate Python environment"></a>4. Delate Python environment</h3><pre><code class="line-numbers language-bash">conda remove --name python37 --all</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/03/17/pandas-ji-chu/">Pandas 基础</a></li><li><a href="https://godliuyang.wang/2020/03/14/numpy-ji-chu/">Numpy 基础</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Anaconda3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro i3wm 高效率环境配置篇(持续更新)</title>
      <link href="/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/"/>
      <url>/2019/08/24/manjaro-i3wm-huan-jing-pei-zhi-pian/</url>
      
        <content type="html"><![CDATA[<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/4.png"><br>Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版<br>使用它是因为 AUR软件仓库有着世界上最齐全的Linux软件，万物皆可 pacman ,arch的wiki绝对是我见过的最详细的linux发行版的”说明书”, 在这里基本能解决我所有的问题, 另，作为基于Arch的发行版，每日一 <code>sudo pacman -Syu</code>简直不要太爽啊！<br>有时间一定要尝试一下 原生Arch(有生之年系列，趁还折腾的动)</p><h2 id="1-系统安装"><a href="#1-系统安装" class="headerlink" title="1. 系统安装"></a>1. 系统安装</h2><h3 id="1-1-ISO文件下载"><a href="#1-1-ISO文件下载" class="headerlink" title="1.1 ISO文件下载"></a>1.1 ISO文件下载</h3><p><a href="https://www.manjaro.org/">Manjaro官网</a></p><p>Manjaro i3属于社区版本<br><a href="https://osdn.net/projects/manjaro-community/storage/i3/18.0.4/manjaro-i3-18.0.4-stable-x86_64.iso/">Download manjaro-i3-18.0.4-stable-x86_64.iso</a></p><h3 id="1-2-U盘启动盘制作"><a href="#1-2-U盘启动盘制作" class="headerlink" title="1.2 U盘启动盘制作"></a>1.2 U盘启动盘制作</h3><p>首先准备一个容量大于4G的U盘，在制作启动盘之前请先把里面的资料转存到别处，因为此项操作会格式化U盘且不可恢复。<br>刻录工具有很多，</p><ul><li><a href="http://cn.ezbsystems.com/dl2.php?file=uiso9_cn.exe">UltralISO</a></li><li><a href="http://cdimage.deepin.com/applications/deepin-boot-maker/windows/deepin-boot-maker.exe">深度启动盘制作工具</a> 深度科技，很简洁的一个工具</li><li><a href="https://github.com/pbatard/rufus/releases/download/v3.6/rufus-3.6.exe">Rufus</a></li></ul><p>按照软件的操作步骤制作启动盘<br>注：若遇到启动盘系统安装的过程中遇到启动盘不可用则使用 <strong>Rufus</strong> 使用DD镜像模式制作<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/1.png"></p><h3 id="1-3-系统安装"><a href="#1-3-系统安装" class="headerlink" title="1.3 系统安装"></a>1.3 系统安装</h3><p>安装过程很简单，参考下面这篇博客<br><a href="https://www.jianshu.com/p/e555a079f78a">Manjaro Linux i3 安装笔记</a></p><p>安装时语言选择  <strong>简体中文</strong>即可</p><h2 id="2-中文环境配置"><a href="#2-中文环境配置" class="headerlink" title="2. 中文环境配置"></a>2. 中文环境配置</h2><h3 id="2-1-更换Linux国内源"><a href="#2-1-更换Linux国内源" class="headerlink" title="2.1 更换Linux国内源"></a>2.1 更换Linux国内源</h3><p>Manjaro 默认的更新源在国外，没翻墙的宝宝无法更新，这里先换一下更新源</p><h4 id="2-1-1-更新镜像排名"><a href="#2-1-1-更新镜像排名" class="headerlink" title="2.1.1 更新镜像排名"></a>2.1.1 更新镜像排名</h4><pre><code class="line-numbers language-bash">sudo pacman-mirrors -i -c China -m rank //更新镜像排名</code></pre><p>之后自己选择几个镜像，推荐ustc和tuna的镜像源</p><pre><code class="line-numbers language-bash">sudo vim /etc/pacman.d/mirrorlist //查看选择的源sudo pacman -Syy  //更新数据源</code></pre><h4 id="2-1-2-设置Archlinuxcn源"><a href="#2-1-2-设置Archlinuxcn源" class="headerlink" title="2.1.2 设置Archlinuxcn源"></a>2.1.2 设置Archlinuxcn源</h4><pre><code class="line-numbers language-bash">sudo vim /etc/pacman.conf</code></pre><p>在文件末尾添加如下:</p><pre><code class="line-numbers language-bash">[archlinuxcn]SigLevel = Optional TrustedOnly#中科大源Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch#清华源Server = http://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch[antergos]SigLevel = TrustAllServer = https://mirrors.ustc.edu.cn/antergos/$repo/$archServer = http://mirrors.tuna.tsinghua.edu.cn/antergos/$repo/$arch[arch4edu]SigLevel = TrustAllServer = http://mirrors.tuna.tsinghua.edu.cn/arch4edu/$arch</code></pre><h4 id="2-1-3-导入GPG-key"><a href="#2-1-3-导入GPG-key" class="headerlink" title="2.1.3 导入GPG key"></a>2.1.3 导入GPG key</h4><pre><code class="line-numbers language-bash">sudo pacman -Syy //更新数据源sudo pacman -S archlinuxcn-keyring //安装导入GPG keysudo pacman -S antergos-keyrin</code></pre><h4 id="2-1-4-更新系统"><a href="#2-1-4-更新系统" class="headerlink" title="2.1.4 更新系统"></a>2.1.4 更新系统</h4><pre><code class="line-numbers language-bash">sudo pacman -Syu</code></pre><h3 id="2-2-解决桌面中文显示方块问题"><a href="#2-2-解决桌面中文显示方块问题" class="headerlink" title="2.2 解决桌面中文显示方块问题"></a>2.2 解决桌面中文显示方块问题</h3><p>若遇到桌面时间中文部分显示为 <strong>方块</strong>     </p><pre><code class="line-numbers language-bash">sudo vim /usr/share/conky/conky_maia</code></pre><p>将 <strong>conky.text</strong> 的前四行字体改为 <strong>anti</strong> 即可</p><h3 id="2-3-中文输入法"><a href="#2-3-中文输入法" class="headerlink" title="2.3 中文输入法"></a>2.3 中文输入法</h3><p>先安装fcitx</p><pre><code class="line-numbers language-bash">sudo pacman -S fcitx fcitx-im fcitx-configtool</code></pre><p>安装完fcitx之后，创建.xprofile文件</p><pre><code class="line-numbers language-bash">vim ~/.xprofile</code></pre><p>在里面添加如下内容:</p><pre><code class="line-numbers language-bash">#fcitxexport GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=&quot;@im=fcitx&quot;</code></pre><p>之后安装中文输入法，搜狗拼音貌似对arch的支持不太好，所以我们选择谷歌拼音</p><pre><code class="line-numbers language-bash">sudo pacman -S fcitx-googlepinyin</code></pre><p>之后在终端运行 <code>$ fcitx</code> 在图形化界面的配置文件中配置输入法即可，配置快捷键<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/2.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/3.png"></p><p>若中文输入法开机无法自启动，则执行如下操作</p><pre><code class="line-numbers language-bash">vim ~/.i3/config</code></pre><p>添加如下内容:</p><p><code>exec_always fcitx</code></p><h2 id="3-高效率软件以及配置"><a href="#3-高效率软件以及配置" class="headerlink" title="3. 高效率软件以及配置"></a>3. 高效率软件以及配置</h2><h3 id="3-1-软件"><a href="#3-1-软件" class="headerlink" title="3.1 软件"></a>3.1 软件</h3><h4 id="3-1-1-Alacritty"><a href="#3-1-1-Alacritty" class="headerlink" title="3.1.1 Alacritty"></a>3.1.1 Alacritty</h4><p>Alacritty 是一个免费的开源，快速，跨平台的终端仿真器，它使用GPU进行渲染，我使用tree命令跑了一下，确实速度快。kitty也是一款优秀的终端，不过它的配置稍麻烦，感兴趣的可以自行Google.</p><pre><code class="line-numbers language-bash">sudo pacman -S alacritty</code></pre><h4 id="3-1-2-fish-amp-oh-my-fish-omf"><a href="#3-1-2-fish-amp-oh-my-fish-omf" class="headerlink" title="3.1.2 fish &amp; oh-my-fish(omf)"></a>3.1.2 fish &amp; oh-my-fish(omf)</h4><ul><li>fish是一个智能且用户友好的命令行shell，适用于macOS，Linux和其他家族。fish包含语法突出显示，自动提示类型和精美的选项卡完成等功能，无需配置。<br>Terminal下默认的SHELL是bash, 但bash作为你经常使用的工具来说一点都不便捷,相信有很多人都用过另一款shell,它的名字是<strong>zsh</strong>，以及<strong>oh-my-zsh</strong>，我也用了一段时间的zsh，在用的过程中我发现它有时候运行贼慢，忍不了，而且配置虽说有oh-my-zsh管理，但终归不是傻瓜式工具，直到有一天我发现了 <strong>fish</strong>,官网号称是一个专为90后设计的shell。<br>安装很简单:</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S fish</code></pre><p>终端输入<code>fish</code>即可进入</p><ul><li>查看已经安装的shell</li></ul><pre><code class="line-numbers language-bash">cat /etc/shells</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/12.png"></p><ul><li>修改默认shell</li></ul><p>看一下上一步输出的<code>fish</code>的位置，然后执行</p><pre><code class="line-numbers language-bash">chsh -s usr/bin/fish</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/13.png"><br>之后重启终端,shell就默认为fish了<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/14.png"></p><p>配置文件的位置是<code>/home/kevin/.config/fish/functions/fish_prompt.fish</code>，可以在这里设置替换命令，提高效率，举个例子:<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/18.png"></p><ul><li>oh-my-fish是一个 Fishshell 框架，允许你安装扩展或更改你的 shell 外观的软件包。它简单易用，快速可扩展。使用 omf，你可以根据你的想法，很容易地安装主题，丰富你的外观和安装插件来调整你的 Fish shell。    </li><li>安装omf<br>在fish shell里执行</li></ul><pre><code class="line-numbers language-bash">curl -L https://get.oh-my.fish | fish</code></pre><ul><li>列出所有的安装包</li></ul><pre><code class="line-numbers language-bash">omf list</code></pre><p>这条命令会列出一安装的主题和插件</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/15.png"></p><ul><li>列出已安装主题</li></ul><pre><code class="line-numbers language-bash">omf theme</code></pre><ul><li>安装一个新主题<br>我现在用的主题叫 ays<pre><code class="line-numbers language-bash">omf install ays</code></pre></li><li>改变主题</li></ul><pre><code class="line-numbers language-bash">omf theme ays</code></pre><ul><li>卸载oh-my-fish</li></ul><pre><code class="line-numbers language-bash">omf destroy</code></pre><ul><li><p>Fish 运行Bash commands<br>例如 在fish 不能运行 time 命令，以下是解决办法    </p><ul><li><p>在 <code>fish/functions/</code> 目录下创建 <code>time.fish</code> 文件，在里面输入    </p><pre><code>function time --description &quot;alias time bash -c time&quot; bash -c &quot;time $argv&quot;;end</code></pre></li></ul></li></ul><p>其他具体功能见<a href="https://github.com/oh-my-fish/oh-my-fish">oh-my-fish</a></p><h4 id="3-1-3-Chromium"><a href="#3-1-3-Chromium" class="headerlink" title="3.1.3 Chromium"></a>3.1.3 Chromium</h4><p>安装方式:</p><pre><code class="line-numbers language-bash">sudo pacman -S chromium</code></pre><h4 id="3-1-4-nitrogen"><a href="#3-1-4-nitrogen" class="headerlink" title="3.1.4 nitrogen"></a>3.1.4 nitrogen</h4><p>一款可视化换壁纸的软件,当然<strong>feh</strong>也是一款优秀的壁纸切换软件，教程很多，这里不再说了</p><pre><code class="line-numbers language-bash">sudo pacman -S nitrogen</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/5.png"></p><h4 id="3-1-5-neofetch"><a href="#3-1-5-neofetch" class="headerlink" title="3.1.5 neofetch"></a>3.1.5 neofetch</h4><p>neofetch是一个个性化显示Linux系统信息的工具</p><pre><code class="line-numbers language-bash">sudo pacman -S neofetch</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/19.png"></p><h4 id="3-1-6-vim"><a href="#3-1-6-vim" class="headerlink" title="3.1.6 vim"></a>3.1.6 vim</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/6.png"></p><p>文本/代码编辑中最最最为优秀经典的上古神器,之后我会写一个调教Vim的教程</p><pre><code class="line-numbers language-bash">sudo pacman -S vim </code></pre><h4 id="3-1-7-albert"><a href="#3-1-7-albert" class="headerlink" title="3.1.7 albert"></a>3.1.7 albert</h4><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/7.png"><br>一款软件/文件/搜索 启动器</p><pre><code class="line-numbers language-bash">sudo pacman -S albert</code></pre><p>第一次运行会提示你设置一下</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/8.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/9.png"></p><h4 id="3-1-8-iease-music"><a href="#3-1-8-iease-music" class="headerlink" title="3.1.8 iease-music"></a>3.1.8 iease-music</h4><p>网易云音乐最漂亮的第三方客户端！</p><pre><code class="line-numbers language-bash">sudo pacman -S iease-music</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/10.png"></p><h4 id="3-1-9-deepin-screenshot"><a href="#3-1-9-deepin-screenshot" class="headerlink" title="3.1.9 deepin-screenshot"></a>3.1.9 deepin-screenshot</h4><p>深度截图</p><pre><code class="line-numbers language-bash">sudo pacman -S deepin-screenshot</code></pre><h4 id="3-1-10-shadowsocks-qt5"><a href="#3-1-10-shadowsocks-qt5" class="headerlink" title="3.1.10 shadowsocks-qt5"></a>3.1.10 shadowsocks-qt5</h4><pre><code class="line-numbers language-bash">sudo pacman -S shadowsocks-qt5</code></pre><h4 id="3-1-11-thefuck"><a href="#3-1-11-thefuck" class="headerlink" title="3.1.11 thefuck"></a>3.1.11 thefuck</h4><p>自从用了”Thefuck”,妈妈再也不用担心我敲错命令了。<br>有了它，万物皆可fffffffffuck!</p><pre><code class="line-numbers language-bash">sudo pacman -S thefuck</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/11.png"></p><h4 id="3-1-12-compton"><a href="#3-1-12-compton" class="headerlink" title="3.1.12 compton"></a>3.1.12 compton</h4><p>设置窗口半透明+毛玻璃效果</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/16.png"></p><p>Manjaro i3 自带的有compton，不过这个只能做到半透明而没有毛玻璃效果，我使用的是<a href="https://github.com/tryone144/compton">Compton</a>,下面详细介绍一下安装过程</p><ol><li>卸载原有的compton</li></ol><pre><code class="line-numbers language-bash">sudo pacman -R compton</code></pre><p>若遇到依赖问题无法卸载，则</p><pre><code class="line-numbers language-bash">sudo pacman -Rc compton</code></pre><ol start="2"><li>clone仓库</li></ol><pre><code class="line-numbers language-bash">git clone git@github.com:liuyaanng/compton.git</code></pre><ol start="3"><li>安装</li></ol><p>具体内容参考<a href="https://github.com/liuyaanng/compton/blob/dual_kawase/README.md">README</a><br>安装前要确保下列依赖已经安装。<br>其实大部分都已经安装,只有个别没有，若下面安装不成功，则按提示把依赖装上即可，有问题也可以在issues上查看</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/17.png"></p><pre><code class="line-numbers language-bash">cd compton# Make the main programmake# Make the man pagemake docs# Installmake install</code></pre><ol start="4"><li>配置</li></ol><p>配置信息在<a href="">.config</a></p><h4 id="3-1-13-deepin-file-manager"><a href="#3-1-13-deepin-file-manager" class="headerlink" title="3.1.13 deepin-file-manager"></a>3.1.13 deepin-file-manager</h4><p>默认的 <code>pcmanfm</code> 竟然没有搜索功能，这不能忍啊<br>我使用 <code>deepin-file-manager</code> 来代替默认的 <code>pcmanfm</code></p><pre><code class="line-numbers language-bash">sudo pacman -S deepin-file-manager</code></pre><p>在配置文件里</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/blog_source@master/blog_images/Manjaro-i3wm-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E7%AF%87/20.png"></p><h3 id="3-2-i3的配置"><a href="#3-2-i3的配置" class="headerlink" title="3.2 i3的配置"></a>3.2 i3的配置</h3><p>i3的配置文件在 <code>~/.i3/config</code></p><p>里面的配置信息介绍的很详细,需要更详细的信息你可以阅读官方<a href="https://i3wm.org/docs/userguide.html">userguide</a></p><p> 首先在<code>Autoapplications</code>处添加自启动的应用</p><pre><code class="line-numbers language-bash">exec_always fcitxexec_always albert</code></pre><ul><li>把系统默认terminal换成<code>alacritty</code><br>在 <code>start a terminal</code>处将原来的代码注释掉，加上以下语句</li></ul><pre><code class="line-numbers language-bash">bindsym $mod+Return exec alacritty</code></pre><ul><li>设置软件启动快捷键</li></ul><p>在配置文件中添加</p><pre><code class="line-numbers language-bash">set $mod Mod4set $mod1 Mod1</code></pre><p>mod在这里设置的是键盘的<code>Super</code>键<br>mod1在这里设置的是<code>Alt</code>键</p><pre><code class="line-numbers language-bash">bindsym $mod+c exec chromiumbindsym $mod+p exec nitrogenbindsym $mod1+m exec iease-musicbindsym $mod1+Shift+a exec deepin-screenshot</code></pre><ul><li>窗口之间的间距通过i3-gaps来设置，若没有安装，则</li></ul><pre><code class="line-numbers language-bash">sudo pacman -S i3-gaps</code></pre><p>在配置文件中加入</p><pre><code class="line-numbers language-bash">gaps inner 16gaps outer 0</code></pre><p>可以根据自己喜好调整数值</p><ul><li>xbacklight config</li></ul><p>install <code>xorg-xbacklight</code> first</p><pre><code class="line-numbers language-bash">sudo pacman -S xorg-xbacklight </code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h4 id="彻底解决蜂鸣问题"><a href="#彻底解决蜂鸣问题" class="headerlink" title="彻底解决蜂鸣问题"></a>彻底解决蜂鸣问题</h4><p>由于蜂鸣是由主板发出来的声音，故不能通过调节音量来消除此声音，要从源头上解决</p><ul><li>关闭终端下Tab键的蜂鸣提示</li></ul><pre><code class="line-numbers language-bash">sudo vim /etc/inputrc</code></pre><p>将 <code>set bell-style none</code> 前的注释去掉</p><ul><li>关闭vim中错误提示蜂鸣声</li></ul><pre><code class="line-numbers language-bash">vim .vim/vimrc</code></pre><p>在里面加入  <code>set vb t_vb= </code></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2019/12/06/arch-linux-i3wm-xiang-xi-pei-zhi/">Arch Linux + i3wm详细配置篇</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Manjaro </tag>
            
            <tag> linux </tag>
            
            <tag> i3wm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Face Recognition</title>
      <link href="/2019/08/10/face-recognition-with-opencv/"/>
      <url>/2019/08/10/face-recognition-with-opencv/</url>
      
        <content type="html"><![CDATA[<h1 id="Face-Recognition-with-OpenCV"><a href="#Face-Recognition-with-OpenCV" class="headerlink" title="Face Recognition with OpenCV"></a>Face Recognition with OpenCV</h1><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>My Particular Environment:<br>Ubuntu16.04 + OpenCV3.3.0 + OpenCV_contrib3.3.0</p><h2 id="1-Image-Acquisition-and-Face-Database-Creation"><a href="#1-Image-Acquisition-and-Face-Database-Creation" class="headerlink" title="1. Image Acquisition and Face Database Creation"></a>1. Image Acquisition and Face Database Creation</h2><h3 id="1-1-Image-Acquisition"><a href="#1-1-Image-Acquisition" class="headerlink" title="1.1 Image Acquisition"></a>1.1 Image Acquisition</h3><h4 id="1-1-1-Steps-and-methods"><a href="#1-1-1-Steps-and-methods" class="headerlink" title="1.1.1 Steps and methods"></a>1.1.1 Steps and methods</h4><ol><li>Open the camera and capture images;</li><li>Loading the face classifier;</li><li>Start face detection, frame the face part and display;</li><li>Under the condition that the face is detected, take a picture with one button;</li><li>For the face part, resize and write the image file in the specified directory;</li></ol><h4 id="1-1-2-Code"><a href="#1-1-2-Code" class="headerlink" title="1.1.2 Code"></a>1.1.2 Code</h4><pre><code class="line-numbers language-cpp">#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;#include &lt;stdio.h&gt;#include &lt;opencv2/face.hpp&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt; using namespace cv;using namespace std;using namespace cv::face;#define CV_COLOR_GREEN cv::Scalar(0, 255, 0)int resize_save(Mat&amp; faceIn, char* path, int  faceseq);//Input: current image, the path of file, the name or faceseq of images.//Output: None//Function: resize the current image to (92, 112), which is same to the train data.int get_face(char* path);//Input: the path of file.//Output: None//Function: Use face_cascade to detect if there are faces in the window, and save the faces through function reszie_save.int resize_save(Mat&amp; faceIn, char* path, int  faceseq)&#123;  string strname;  Mat faceOut;  bool ret;  if(faceIn.empty())&#123;    printf(&quot;FaceIn is empty.\n&quot;);    return -1;  &#125;  if(faceIn.cols &gt; 100)&#123;    resize(faceIn, faceOut, Size(92, 112));    //Resize and Keep a match with the train database.    strname = format(&quot;%s/%d.jpg&quot;, path, faceseq); //mkdir    ret = imwrite(strname, faceOut); //save image. Note the file suffix.    if(ret == false)&#123;      printf(&quot;Image write failed!\n&quot;);      printf(&quot;Please check filename[%s] is legal!\n&quot;, strname.c_str());      return -1;    &#125;    imshow(strname, faceOut);  &#125;  waitKey(20);  return 0;&#125;int get_face(char* path)&#123;  CascadeClassifier face_cascade;  VideoCapture camera;  int ret;  Mat frame;  //camera frame  vector&lt;Rect&gt; objects; //The faces coordinates.  Mat img_gary; //Gradation pictures.  Mat faceImg;  int faceNum = 1; //  char key;  camera.open(0);  if(!camera.isOpened())&#123;    cout &lt;&lt; &quot;Open camera failed.&quot; &lt;&lt; endl;    return -1;  &#125;  cout &lt;&lt; &quot;Open camera succeed. &quot; &lt;&lt; endl;  //Load the face cascadeclassifier.  ret = face_cascade.load(&quot;haarcascade_frontalface_alt2.xml&quot;);  if(!ret)&#123;    cout &lt;&lt; &quot;Load xml failed.&quot; &lt;&lt; endl;    return -1;  &#125;  cout &lt;&lt; &quot;Load xml succeed.&quot; &lt;&lt; endl;  while(1)&#123;    camera &gt;&gt; frame;    if(frame.empty())&#123;      continue;    &#125;    cvtColor(frame, img_gary, COLOR_BGR2GRAY); //Transform frame as the gradation picture, note imshow is still the original frame.    equalizeHist(img_gary, img_gary); //Histogram equalization, which is helpful to improve the quality of pictures.    //Face detection    face_cascade.detectMultiScale(img_gary, objects, 1.1,3 , 0, Size(50,50));    for(size_t i = 0; i &lt; objects.size(); i++)&#123;      rectangle(frame, objects[i], CV_COLOR_GREEN);    &#125;    imshow(&quot;Camera&quot;, frame);    key = waitKey(1);    switch (key)&#123;      case &#39;p&#39;: //tap &#39;P&#39; to save.        if(objects.size() == 1)&#123;          faceImg = frame(objects[0]);          ret = resize_save(faceImg, path, faceNum);          if(ret == 0)&#123;            cout &lt;&lt; &quot;resize_save succeed.\n&quot; &lt;&lt; endl;            faceNum++;          &#125;        &#125;        break;      case 27:   //switch to ESC        cout &lt;&lt; &quot;Esc ...&quot; &lt;&lt; endl;        return 0;      default:        break;    &#125;  &#125;&#125;int main(int argc, char* argv[])&#123;  if(argc != 2)      &#123;        printf(&quot;usage: %s &lt;path&gt;\n&quot;, argv[0]);        return -1;      &#125;  get_face(argv[1]);  return 0;&#125;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/4.jpg"><br>Note:    </p><ol><li>After the compilation is successful, the execution executable file must provide parameters, which are the directories for storing the face image, and it must be an existing directory.(E.g: ./program_name Img/s41)    </li><li>Press the “P” button to take a photo and save the face. Press the “Esc” button to exit.</li></ol><h3 id="1-2-Face-Database-Creation"><a href="#1-2-Face-Database-Creation" class="headerlink" title="1.2 Face Database Creation"></a>1.2 Face Database Creation</h3><p>The official document provides a download of the face database, and i use the <a href="http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html">AT&amp;T Facedatabase</a> to create my face database. I have updated this zip file to my github, you can download it from <a href="att_faces.zip">here</a> faster.<br>AT&amp;T Face Database is also known as the OCR face database, 40 people, 10 photos per person. The photos are token at different times, different lighting, different expressions(closed eyes, laughing or not laughing), different face details(with or without glasses). All images were captured on a dark , even background with a vertical face o the front(some with a slight rotation).<br>You can download the compressed package from the website, and first extract the att_faces folder. There are 40 folders under the folder, which named from “s1” to “s40”. Each folder has the same person’s photos with different expressions, and there are 10 face photos.<br>The format of these images is “.pgm”<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/2.png"></p><p>Note:<br>If you want to add your own photos to the face database through the program, the number of added pictures must be no less than 2.</p><h2 id="2-Face-Recognition-Model-training"><a href="#2-Face-Recognition-Model-training" class="headerlink" title="2. Face Recognition Model training"></a>2. Face Recognition Model training</h2><h3 id="2-1-Create-a-label-file-CSV"><a href="#2-1-Create-a-label-file-CSV" class="headerlink" title="2.1 Create a label file CSV"></a>2.1 Create a label file CSV</h3><p>With the face database data, we need to read it in the program, here we need to use csv file to read the image data in the face database.<br>The format of a csv file: image path name + label, such as /Img/s1/image.jpg;1<br>Assume the face image path is: /Img/s1/01..jpg<br>And we give this face image a label “1”, this label represents the person’s name. One person’s face image label must be the same.<br>You can create a csv file manually and then enter the data one by one. But if you use python, you don’t have to do this tedious and boring work.<br>The following is a piece of code which can write data in the CSV file automatically.</p><pre><code class="line-numbers language-python">#!/usr/bin/env pythonimport sysimport os.path# This is a tiny script to help you creating a CSV file from a face# database with a similar hierarchie:##  #  #  |-- s1#  |   |-- 1.pgm#  |   |-- ...#  |   |-- 10.pgm#  |-- s2#  |   |-- 1.pgm#  |   |-- ...#  |   |-- 10.pgm#  ...#  |-- s40#  |   |-- 1.pgm#  |   |-- ...#  |   |-- 10.pgm#if __name__ == &quot;__main__&quot;:    if len(sys.argv) != 2:        print &quot;usage: create_csv &lt;base_path&gt;&quot;        sys.exit(1)    BASE_PATH=sys.argv[1]            SEPARATOR=&quot;;&quot;    # This is output csv file.    fh = open(&quot;../at.csv&quot;,&#39;w&#39;)    for dirname, dirnames, filenames in os.walk(BASE_PATH):        for subdirname in dirnames:            subject_path = os.path.join(dirname, subdirname)            for filename in os.listdir(subject_path):                abs_path = &quot;%s/%s&quot; % (subject_path, filename)                print(&quot;%s%s%s&quot; % (abs_path, SEPARATOR, subdirname[1:]))                fh.write(abs_path)                fh.write(SEPARATOR)                fh.write(subdirname[1:])                fh.write(&quot;\n&quot;)    fh.close()</code></pre><p>You should set the image path parameter (absolute path) when running.(E.g: <strong>python filename.py /home/kevin/OpenCV/face_rec/Img</strong> ) and you can get a CSV file like this:<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/5.png"><br>This CSV file is created.</p><h3 id="2-2-Model-training"><a href="#2-2-Model-training" class="headerlink" title="2.2 Model training"></a>2.2 Model training</h3><p>This is the official example of OpenCV: <a href="https://docs.opencv.org/3.2.0/da/d60/tutorial_face_main.html">Click here</a><br>They offer three models: Eigenfaces, Fisherfaces and Local Binary Patterns Histograms(LBPH)    </p><p>Then I will train my own face database based on these models on the first step.</p><pre><code class="line-numbers language-cpp">static Mat norm_0_255(InputArray _src)&#123;  Mat src = _src.getMat();  Mat dst; //Create and return a normalized image matrix:  switch(src.channels()) &#123;    case 1:        cv::normalize(_src, dst, 0, 255, NORM_MINMAX, CV_8UC1);        break;    case 3:        cv::normalize(_src, dst, 0, 255, NORM_MINMAX, CV_8UC3);        break;    default:        src.copyTo(dst);        break;  &#125;  return dst;&#125;//load CSV filestatic void read_csv(const string&amp; filename, vector&lt;Mat&gt;&amp; images, vector&lt;int&gt;&amp; labels, char separator = &#39;;&#39;)&#123;  std::ifstream file(filename.c_str(), ifstream::in);    if (!file) &#123;        string error_message = &quot;No valid input file was given, please check the given filename.&quot;;        CV_Error(Error::StsBadArg, error_message);    &#125;    string line, path, classlabel;    while (getline(file, line)) &#123;        stringstream liness(line);        getline(liness, path, separator);        getline(liness, classlabel);        if(!path.empty() &amp;&amp; !classlabel.empty()) &#123;            images.push_back(imread(path, 0));            labels.push_back(atoi(classlabel.c_str()));        &#125;    &#125;&#125;void train_model(const string&amp; fn_csv)&#123;  // 2 containers to store image data and corresponding labels    vector&lt;Mat&gt; images;    vector&lt;int&gt; labels;    // load data    try    &#123;        read_csv(fn_csv, images, labels);    &#125;    catch (cv::Exception&amp; e)    &#123;        cerr &lt;&lt; &quot;Error opening file \&quot;&quot; &lt;&lt; fn_csv &lt;&lt; &quot;\&quot;. Reason: &quot; &lt;&lt; e.msg &lt;&lt; endl;        exit(1);    &#125;    if (images.size() &lt;= 1) &#123;        string error_message = &quot;This demo needs at least 2 images to work. Please add more images to your data set!&quot;;        CV_Error(CV_StsError, error_message);    &#125;    Mat testSample = images[images.size() - 1];    int testLabel = labels[labels.size() - 1];    images.pop_back();    labels.pop_back();    // The following lines create a feature face model for face recognition.     // Train it with images and tags read from a CSV file.     // Here is a complete PCA transform     //If you only want to keep 10 principal components, use the following code     // cv::EigenFaceRecognizer::create(10);     // cv::FisherFaceRecognizer::create(10);     //     // If you also want to initialize with a confidence threshold, use the following statement:     // cv::EigenFaceRecognizer::create(10, 123.0);     //     // If you use all features and use a threshold, use the following statement:     // cv::EigenFaceRecognizer::create(0, 123.0);     // cv::FisherFaceRecognizer::create(0, 123.0);    Ptr&lt;BasicFaceRecognizer&gt; model0 = EigenFaceRecognizer::create();    model0-&gt;train(images, labels);    model0-&gt;write(&quot;MyFacePCAModel.xml&quot;);    Ptr&lt;BasicFaceRecognizer&gt; model1 = FisherFaceRecognizer::create();    model1-&gt;train(images, labels);    model1-&gt;write(&quot;MyFaceFisherModel.xml&quot;);     Ptr&lt;LBPHFaceRecognizer&gt; model2 = LBPHFaceRecognizer::create();    model2-&gt;train(images, labels);    model2-&gt;write(&quot;MyFaceLBPHModel.xml&quot;);    // The test image is predicted below, predictedLabel is the predicted label result    int predictedLabel0 = model0-&gt;predict(testSample);    int predictedLabel1 = model1-&gt;predict(testSample);    int predictedLabel2 = model2-&gt;predict(testSample);    // There is also a way to get the result and get the threshold:    //      int predictedLabel = -1;    //      double confidence = 0.0;    //      model-&gt;predict(testSample, predictedLabel, confidence);    string result_message0 = format(&quot;Predicted class = %d / Actual class = %d.&quot;, predictedLabel0, testLabel);    string result_message1 = format(&quot;Predicted class = %d / Actual class = %d.&quot;, predictedLabel1, testLabel);    string result_message2 = format(&quot;Predicted class = %d / Actual class = %d.&quot;, predictedLabel2, testLabel);    cout &lt;&lt; result_message0 &lt;&lt; endl;    cout &lt;&lt; result_message1 &lt;&lt; endl;    cout &lt;&lt; result_message2 &lt;&lt; endl;    waitKey(0);&#125;int main(int argc, char* argv[])&#123;  if(argc != 2)      &#123;        printf(&quot;usage: %s &lt;csv_file&gt;\n&quot;, argv[0]);        return -1;      &#125;  string fn_csv = string(argv[1]);  train_model(fn_csv);  return 0;&#125;</code></pre><p>At this point, we have completed the training of the face model. And we get three files:     </p><p><code>MyFaceFisherModel.xml、MyFaceLBPHModel.xml、MyFacePCAModel.xml</code></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/6.png"><br>Note:    </p><ol><li><p>Changes to the API of the OpenCV3.3 Face Recognition Module</p><p>a. Facerec.hpp before opencv3.3</p><pre><code class="line-numbers language-cpp">#ifndef __OPENCV_FACEREC_HPP__#define __OPENCV_FACEREC_HPP__#include &quot;opencv2/face.hpp&quot;#include &quot;opencv2/core.hpp&quot;namespace cv &#123; namespace face &#123;// base for two classesclass CV_EXPORTS_W BasicFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setNumComponents */    CV_WRAP virtual int getNumComponents() const = 0;    // ----------- ...... -----------    CV_WRAP virtual cv::Mat getEigenValues() const = 0;    CV_WRAP virtual cv::Mat getEigenVectors() const = 0;    CV_WRAP virtual cv::Mat getMean() const = 0;&#125;;CV_EXPORTS_W Ptr&lt;BasicFaceRecognizer&gt; createEigenFaceRecognizer(int num_components = 0, double threshold = DBL_MAX);CV_EXPORTS_W Ptr&lt;BasicFaceRecognizer&gt; createFisherFaceRecognizer(int num_components = 0, double threshold = DBL_MAX);class CV_EXPORTS_W LBPHFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setGridX */    CV_WRAP virtual int getGridX() const = 0;    /** @copybrief getGridX @see getGridX */    CV_WRAP virtual void setGridX(int val) = 0;    // ----------- ...... -----------    CV_WRAP virtual cv::Mat getLabels() const = 0;&#125;;CV_EXPORTS_W Ptr&lt;LBPHFaceRecognizer&gt; createLBPHFaceRecognizer(int radius=1, int neighbors=8, int grid_x=8, int grid_y=8, double threshold = DBL_MAX);&#125;&#125; //namespace cv::face#endif //__OPENCV_FACEREC_HPP__</code></pre><ul><li><p>Comment section of the ninth line: <code>// base for two classes</code>,  This shows that BasicFaceRecognizer is the base class of two classes: EigenFaceRecognizer and FisherFaceRecognizer. With LBPHFaceRecognizer is irrelevant. Even the new API is still the case.</p></li><li><p>Method of creating three face recognizers.</p><pre><code class="line-numbers language-cpp">Ptr&lt;BasicFaceRecognizer&gt; model =  createEigenFaceRecognizer();Ptr&lt;BasicFaceRecognizer&gt; model =  createFisherFaceRecognizer();Ptr&lt;LBPHFaceRecognizer&gt; model  =  createLBPHFaceRecognizer();</code></pre></li></ul><p>b. Facerec.hpp after opencv3.3</p></li></ol><pre><code class="line-numbers language-cpp">#ifndef __OPENCV_FACEREC_HPP__#define __OPENCV_FACEREC_HPP__#include &quot;opencv2/face.hpp&quot;#include &quot;opencv2/core.hpp&quot;namespace cv &#123; namespace face &#123;// base for two classesclass CV_EXPORTS_W BasicFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setNumComponents */    CV_WRAP int getNumComponents() const;    // ----------- ...... -----------    CV_WRAP cv::Mat getEigenValues() const;    CV_WRAP cv::Mat getEigenVectors() const;    CV_WRAP cv::Mat getMean() const;    virtual void read(const FileNode&amp; fn);    virtual void write(FileStorage&amp; fs) const;    virtual bool empty() const;    using FaceRecognizer::read;    using FaceRecognizer::write;protected:    int _num_components;    double _threshold;    std::vector&lt;Mat&gt; _projections;    Mat _labels;    Mat _eigenvectors;    Mat _eigenvalues;    Mat _mean;&#125;;class CV_EXPORTS_W EigenFaceRecognizer : public BasicFaceRecognizer&#123;public:    CV_WRAP static Ptr&lt;EigenFaceRecognizer&gt; create(int num_components = 0, double threshold = DBL_MAX);&#125;;class CV_EXPORTS_W FisherFaceRecognizer : public BasicFaceRecognizer&#123;public:    CV_WRAP static Ptr&lt;FisherFaceRecognizer&gt; create(int num_components = 0, double threshold = DBL_MAX);&#125;;class CV_EXPORTS_W LBPHFaceRecognizer : public FaceRecognizer&#123;public:    /** @see setGridX */    CV_WRAP virtual int getGridX() const = 0;    // ----------- ...... -----------    CV_WRAP virtual cv::Mat getLabels() const = 0;    CV_WRAP static Ptr&lt;LBPHFaceRecognizer&gt; create(int radius=1, int neighbors=8, int grid_x=8, int grid_y=8, double threshold = DBL_MAX);&#125;;&#125;&#125; //namespace cv::face#endif //__OPENCV_FACEREC_HPP__</code></pre><ul><li>Both EigenFaceRecognizer and FisherFaceRecognizer are inherited from BasicFaceRecognizer. However, the LBFPHaceRecognizer, like the BasicFaceRecognizer, inherits from FaceRecognizer.    </li><li>Method of creating three face recognizer</li></ul><pre><code class="line-numbers language-cpp">Ptr&lt;EigenFaceRecognizer&gt; model  = EigenFaceRecognizer::create();Ptr&lt;FisherFaceRecognizer&gt; model = FisherFaceRecognizer::create();Ptr&lt;LBPHFaceRecognizer&gt; model   = LBPHFaceRecognizer::create();</code></pre><h2 id="3-Identify-faces-in-the-video-stream-camera"><a href="#3-Identify-faces-in-the-video-stream-camera" class="headerlink" title="3. Identify faces in the video stream (camera)"></a>3. Identify faces in the video stream (camera)</h2><h3 id="3-1-Ready-to-work"><a href="#3-1-Ready-to-work" class="headerlink" title="3.1 Ready to work."></a>3.1 Ready to work.</h3><h4 id="3-1-1-Copy-the-training-file-obtained-in-the-second-step-to-the-current-folder"><a href="#3-1-1-Copy-the-training-file-obtained-in-the-second-step-to-the-current-folder" class="headerlink" title="3.1.1 Copy the training file obtained in the second step to the current folder."></a>3.1.1 Copy the training file obtained in the second step to the current folder.</h4><h4 id="3-1-2-The-process-or-method-of-Face-Recognition"><a href="#3-1-2-The-process-or-method-of-Face-Recognition" class="headerlink" title="3.1.2 The process or method of Face Recognition"></a>3.1.2 The process or method of Face Recognition</h4><p>This step has a similar part to the creation of a face recognition database.</p><ul><li>Open the camera</li><li>Loading face detector, face model</li><li>Scale the image (for efficiency)</li><li>Face recognition (compare to face model)</li><li>Label faces with rectangular wireframes and add text labels</li></ul><h4 id="3-2-Code"><a href="#3-2-Code" class="headerlink" title="3.2 Code"></a>3.2 Code</h4><pre><code class="line-numbers language-cpp">#include &lt;opencv2/opencv.hpp&gt;  #include &quot;opencv2/core.hpp&quot;#include &quot;opencv2/face.hpp&quot;#include &quot;opencv2/highgui.hpp&quot;#include &quot;opencv2/imgproc.hpp&quot;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace cv;using namespace cv::face;using namespace std;#define ROW_MIN        45int exitFlag = 0;int Recognition_And_Draw();int Recognition_And_Draw()&#123;  int ret = 0; //  double scale = 4; //Zoom factor  double fx = 1 / scale;  Mat frame;  //Video frame  VideoCapture cap(0);    //Open the camera  if(!cap.isOpened())&#123;    cout &lt;&lt; &quot;Open camera failed.\n&quot; &lt;&lt; endl;    return -1;  &#125;  //Load cascade classifier  CascadeClassifier cascade;  ret = cascade.load(&quot;haarcascade_frontalface_alt2.xml&quot;);  if(!ret)&#123;    printf(&quot;Load xml failed[ret = %d]. \n&quot;, ret);    return -1;  &#125;  cout &lt;&lt; &quot;Load xml succeed.&quot; &lt;&lt; endl;  // Loading trained face models  Ptr&lt;BasicFaceRecognizer&gt; modelPCA = EigenFaceRecognizer::create();    modelPCA-&gt;read(&quot;MyFacePCAModel.xml&quot;);    Ptr&lt;BasicFaceRecognizer&gt; modelFisher = FisherFaceRecognizer::create();  modelFisher-&gt;read(&quot;MyFaceFisherModel.xml&quot;);    Ptr&lt;LBPHFaceRecognizer&gt; modelLBPH = LBPHFaceRecognizer::create();    modelLBPH-&gt;read(&quot;MyFaceLBPHModel.xml&quot;);    while(!exitFlag)&#123;    cap &gt;&gt; frame;    if(frame.empty())      continue;    Mat facesImg;  //    vector&lt;Rect&gt; faces;  //Create a vector container for storing faces    Mat gary_img; //grayscale image    Mat scl_gary_img; //Scaled grayscale image    cvtColor(frame, gary_img, COLOR_BGR2GRAY); //Convert the original image to a grayscale image    resize(gary_img, scl_gary_img, Size(), fx, fx, INTER_LINEAR); //resize img    equalizeHist( scl_gary_img, scl_gary_img );  //face detection    cascade.detectMultiScale(scl_gary_img, faces, 1.1, 2, 0|CASCADE_SCALE_IMAGE,Size(30, 30));    printf(&quot;Face.size = %ld\n&quot;, faces.size());  //facesImg = scl_gary_img(faces[0]);    Mat face_resize;  //To prevent the picture is too small (that is, people too far away from the camera)    int predictPCA = 0;      int predictFisher = 0;      int predictLBPH = 0;    for(size_t i = 0; i &lt; faces.size(); i++)&#123;      Rect rectFace = faces[i];      facesImg = scl_gary_img(faces[i]);      if(facesImg.rows &gt;= ROW_MIN)&#123;        resize(facesImg, face_resize, Size(92, 112));      &#125;      else&#123;        printf(&quot;faceImg.rows[%d] &lt; %d \n&quot;, facesImg.rows, ROW_MIN);        continue;      &#125;      if(!face_resize.empty())&#123;        predictPCA = modelPCA-&gt;predict(face_resize);          predictFisher = modelFisher-&gt;predict(face_resize);          predictLBPH = modelLBPH-&gt;predict(face_resize);       &#125;      cout &lt;&lt; &quot;predictPCA   : &quot; &lt;&lt; predictPCA    &lt;&lt; endl;      cout &lt;&lt; &quot;predictFisher: &quot; &lt;&lt; predictFisher &lt;&lt; endl;      cout &lt;&lt; &quot;predictLBPH  : &quot; &lt;&lt; predictLBPH   &lt;&lt; endl;      rectangle(frame, Point(rectFace.x, rectFace.y) * scale, Point(rectFace.x + rectFace.width, rectFace.y + rectFace.height) * scale, Scalar(0, 255, 0), 2, 8);      if (predictPCA == 41)&#123;        putText(frame, &quot;Liuyang&quot;, Point(faces[i].x, faces[i].y) * scale, FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 0, 255), 2);      &#125;      else&#123;        putText(frame, &quot;X&quot;, Point(faces[i].x, faces[i].y) * scale, FONT_HERSHEY_SIMPLEX, 1.5, Scalar(0, 0, 255), 2);      &#125;  // if(faces.size() &lt;= 0)&#123;  //  cout &lt;&lt; &quot;There are no faces in the camera.\n&quot; &lt;&lt; endl; // &#125;    &#125;    imshow(&quot;frame&quot;, frame);      if (waitKey(1) == 27)&#123;                exitFlag = 1;                cout &lt;&lt; &quot;Esc...&quot; &lt;&lt; endl;                break;      &#125;  &#125;&#125;int main()&#123;  Recognition_And_Draw();  return 0;&#125;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Recognition-with-OpenCV/7.jpg"></p><p>Note:    </p><ol><li>This program supports multiple face recognition at the same time</li><li>Face recognition accuracy is not high, and it is susceptible to environmental factors such as light.</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/08/17/leetcode-easy-9/">LeetCode EASY_9</a></li><li><a href="https://godliuyang.wang/2020/03/30/scikit-image-guide/">scikit-image guide</a></li><li><a href="https://godliuyang.wang/2020/01/29/sort/">SORT</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
          <category> Face Recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
            <tag> python </tag>
            
            <tag> Face Recongnition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Enjoy PyTorch</title>
      <link href="/2019/08/07/enjoy-pytorch/"/>
      <url>/2019/08/07/enjoy-pytorch/</url>
      
        <content type="html"><![CDATA[<h1 id="Installing-PyTorch-with-Anaconda-and-Conda"><a href="#Installing-PyTorch-with-Anaconda-and-Conda" class="headerlink" title="Installing PyTorch with Anaconda and Conda"></a>Installing PyTorch with Anaconda and Conda</h1><p>My Particular Environment:</p><ul><li>OS: Ubuntu 16.04</li><li>Package Manager: conda</li><li>Python: 3.6</li><li>CUDA: None</li></ul><p>Getting started with PyTorch is very easy. The recommended best option is to use the Anaconda Pythob package manager.</p><ol><li><a href="https://www.anaconda.com/distribution/">Download and install Anaconda</a>(Go with the latest Python version)<br>You can download the <code>.sh</code> package from the Anaconda website, but it’s very slowly for me. So i find another choice.<br>You can find it in <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Tsinghua university open source mirror station</a>, which i download is <code>Anaconda3-5.2.0-Linux-x86_64.sh</code>. Or if you already get the “wget”, you can run this command in the terminal.<pre><code class="line-numbers language-bash">wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.2.0-Linux-x86_64.sh</code></pre>Use <code>conda -V</code> to check the Version of Anaconda after open a new terminal.<br>If it isn’t work, try,<pre><code class="line-numbers language-bash">echo &#39;export PATH=&quot;~/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; ~/.bashrcsource ./bashrc</code></pre></li><li>Go to the Getting Started section on the <a href="https://pytorch.org/">Pytorch website</a>.</li><li>Specify the appropriate configuration options for your particular environment.<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Enjoy-PyTorch-Task1/1.png"></li><li>Run the presented command in the terminal to install Pytorch.<pre><code class="line-numbers language-bash">conda install pytorch-cpu torchvision-cpu -c pytorch</code></pre></li></ol><pre><code class="line-numbers language-python">import torchimport torch.nn as nnimport torchvisionimport torch.utils.data as Data# Hyper ParametersEPOCH = 1  BATCH_SIZE = 50LR = 0.001  DOWNLOAD_MNIST = True  # Mnisttrain_data = torchvision.datasets.MNIST(    root=&#39;./mnist/&#39;,      train=True,  # this is training data    transform=torchvision.transforms.ToTensor(),  # exchange PIL.Image or numpy.ndarray to torch.FloatTensor (C x H x W)    download=DOWNLOAD_MNIST,  )test_data = torchvision.datasets.MNIST(    root=&#39;./mnist/&#39;,    train=False)# BATCH_SIZEtrain_loader = Data.DataLoader(    dataset=train_data,    batch_size=BATCH_SIZE,    shuffle=True  )# test_datatest_x = torch.unsqueeze(test_data.test_data, dim=1).type(torch.FloatTensor)test_y = test_data.test_labels# cnnclass CNN(nn.Module):    def __init__(self):        super(CNN, self).__init__()        self.layer1 = nn.Sequential(            # (1, 28, 28)            nn.Conv2d(                in_channels=1,                out_channels=16,                kernel_size=5,                  stride=1,                  padding=2,                groups=1            ),            # (16, 28, 38)            nn.ReLU(),            nn.MaxPool2d(kernel_size=2)            # (16, 14, 14)        )        self.layer2 = nn.Sequential(            nn.Conv2d(                in_channels=16,                out_channels=32,                kernel_size=5,                stride=1,                padding=2            ),            nn.ReLU(),            nn.MaxPool2d(kernel_size=2)        )        self.layer3 = nn.Linear(32 * 7 * 7, 10)    def forward(self, x):        # print(x.shape)        x = self.layer1(x)        # print(x.shape)        x = self.layer2(x)        # print(x.shape)        x = x.view(x.size(0), -1)        # print(x.shape)        x = self.layer3(x)        # print(x.shape)        return xcnn = CNN()optimizer = torch.optim.Adam(cnn.parameters(), lr=LR)loss_function = nn.CrossEntropyLoss()for epoch in range(EPOCH):    for step, (b_x, b_y) in enumerate(train_loader):        output = cnn(b_x)        loss = loss_function(output, b_y)        optimizer.zero_grad()        loss.backward()        optimizer.step()print(&#39;finished training&#39;)test_out = cnn(test_x)predict_y = torch.argmax(test_out, 1).data.numpy()print(&#39;Accuracy in Test : %.4f%%&#39; % (sum(predict_y == test_y.data.numpy()) * 100/ len(predict_y)))</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/04/21/gpu-servers/">GPU servers</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> PyTorch Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA算法实现</title>
      <link href="/2019/08/07/pca-suan-fa-shi-xian/"/>
      <url>/2019/08/07/pca-suan-fa-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="PCA算法实例及C-实现"><a href="#PCA算法实例及C-实现" class="headerlink" title="PCA算法实例及C++实现"></a>PCA算法实例及C++实现</h1><h2 id="PCA算法"><a href="#PCA算法" class="headerlink" title="PCA算法"></a>PCA算法</h2><p>总结一下PCA的算法步骤：</p><p>设有m条n维数据。</p><ol><li>将原始数据按列组成n行m列矩阵X</li><li>将X的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</li><li>求出协方差矩阵 $C=\frac{1}{m}XX^\mathsf{T}$</li><li>求出协方差矩阵的特征值及对应的特征向量</li><li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P</li><li>$Y = PX$即为降维到k维后的数据</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以<br>$$ \begin{pmatrix}<br>  -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>  -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \<br>\end{pmatrix} $$<br>为例，我们用PCA方法将这组二维数据其降到一维。</p><p>因为这个矩阵的每行已经是零均值，这里我们直接求协方差矩阵：<br>$$ C=\frac{1}{5}\begin{pmatrix}<br>  -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>  -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \<br>\end{pmatrix}\begin{pmatrix}<br>  -1 &amp; -2 \\<br>  -1 &amp; 0  \\<br>  0  &amp; 0  \\<br>  2  &amp; 1  \\<br>  0  &amp; 1 \<br>\end{pmatrix}=\begin{pmatrix}<br>  \frac{6}{5} &amp; \frac{4}{5} \\<br>  \frac{4}{5} &amp; \frac{6}{5} \<br>\end{pmatrix}$$<br>然后求其特征值和特征向量，具体求解方法不再详述，可以参考相关资料。求解后特征值为：<br>$$\lambda_1=2,\lambda_2=2/5$$<br>其对应的特征向量分别是：<br>$$c_1\begin{pmatrix}<br>  1 \\<br>  1<br>\end{pmatrix},c_2\begin{pmatrix}<br>  -1 \\<br>  1<br>\end{pmatrix}$$<br>其中对应的特征向量分别是一个通解， $c_1$和 $c_2$ 可取任意实数。那么标准化后的特征向量为：<br>$$\begin{pmatrix}<br>  1/\sqrt{2} \\<br>  1/\sqrt{2}<br>\end{pmatrix},\begin{pmatrix}<br>  -1/\sqrt{2} \\<br>  1/\sqrt{2}<br>\end{pmatrix}$$<br>因此我们的矩阵P是：<br>$$P=\begin{pmatrix}<br>  1/\sqrt{2}  &amp; 1/\sqrt{2}  \\<br>  -1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}$$<br>最后我们用P的第一行乘以数据矩阵，就得到了降维后的表示：<br>$$Y=\begin{pmatrix}<br>  1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}\begin{pmatrix}<br>  -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>  -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\end{pmatrix}=\begin{pmatrix}<br>  -3/\sqrt{2} &amp; -1/\sqrt{2} &amp; 0 &amp; 3/\sqrt{2} &amp; -1/\sqrt{2}<br>\end{pmatrix}$$<br>可以验证协方差矩阵C的对角化：<br>$$PCP^\mathsf{T}=\begin{pmatrix}<br>  1/\sqrt{2}  &amp; 1/\sqrt{2}  \\<br>  -1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}\begin{pmatrix}<br>  6/5 &amp; 4/5 \\<br>  4/5 &amp; 6/5<br>\end{pmatrix}\begin{pmatrix}<br>  1/\sqrt{2} &amp; -1/\sqrt{2}  \\<br>  1/\sqrt{2} &amp; 1/\sqrt{2}<br>\end{pmatrix}=\begin{pmatrix}<br>  2 &amp; 0  \\<br>  0 &amp; 2/5<br>\end{pmatrix}$$<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/02.png"></p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><p>因为要对一组图片信息进行训练，所以我写了一部分通过摄像头截取图片帧的代码，<code>get_img()</code>函数。这里提取了5个特征脸和一个均值脸</p><pre><code class="line-numbers language-cpp">#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#define img_num 300 //训练图片的张数using namespace cv;using namespace std;//通过摄像头保存要训练的图片//打开摄像头int get_img()&#123;  VideoCapture cap(0);  if(!cap.isOpened())  &#123;    return -1;  &#125;  Mat frame;  bool stop = false;  int i = 1;  while(!stop)&#123;    cap &gt;&gt; frame;    printf(&quot;%d\n&quot;, i);    if (frame.empty())      stop = true;    //string filename = format(&quot;%d.jpg&quot;, i);    char filename[20];    sprintf(filename, &quot;Img/%d.jpg&quot;, i);    imwrite(filename, frame);    i++;    imshow(&quot;frame&quot;, frame);    waitKey(30);    if(i &gt; img_num)      break;  &#125;return -1;&#125;//把图像归一化为0-255Mat norm_0_255(const Mat&amp; src)&#123;  Mat dst;  switch(src.channels())&#123;    case 1:        cv::normalize(src, dst, 0, 255, NORM_MINMAX, CV_8UC1);        break;    case 3:        cv::normalize(src, dst, 0, 255, NORM_MINMAX, CV_8UC3);        break;    default:        src.copyTo(dst);        break;  &#125;  return dst;&#125;//将给定的图像转化为行矩阵Mat asRowMatrix(const vector&lt;Mat&gt;&amp; src, int rtype, double alpha = 1, double beta = 0)&#123;  // 样本数量  size_t n = src.size();  //没有样本，返回空矩阵  if (n == 0)    return Mat();  //样本的维数  size_t d = src[0].total();  Mat data(n, d, rtype);  //拷贝数据  for (int i = 0; i &lt; n; i++)&#123;    if(src[i].empty())&#123;      string error_message = format(&quot;Image number %d was empty, please check your input data.&quot;, i);      CV_Error(CV_StsBadArg, error_message);    &#125;    //确保数据能被reshape    if(src[i].total() != d)&#123;      string error_message = format(&quot;Wrong number of elements in matrix #%d! Expected %d was %d.&quot;, i, d, src[i].total());      CV_Error(CV_StsBadArg, error_message);    &#125;    Mat xi = data.row(i);    //转化为1行，n列的格式    if(src[i].isContinuous())&#123;      src[i].reshape(1, 1).convertTo(xi, rtype, alpha, beta);    &#125;    else &#123;      src[i].clone().reshape(1, 1).convertTo(xi, rtype, alpha, beta);    &#125;  &#125;  return data;&#125;int main(int argc, const char* argv[])&#123;  vector&lt;Mat&gt; db;  //get_img();  for(int i=1; i&lt;img_num;i++)&#123;    string filename = format(&quot;Img/%d.jpg&quot;, i);    db.push_back(imread(filename, IMREAD_GRAYSCALE));  &#125;  // Build a matrix with the observations in row:    Mat data = asRowMatrix(db, CV_32FC1);    // PCA算法保持5主成分分量    int num_components = 5;    //执行pca算法    PCA pca(data, Mat(), CV_PCA_DATA_AS_ROW, num_components);    //copy  pca算法结果    Mat mean = pca.mean.clone();    Mat eigenvalues = pca.eigenvalues.clone();    Mat eigenvectors = pca.eigenvectors.clone();        //均值脸    imshow(&quot;avg&quot;, norm_0_255(mean.reshape(1, db[0].rows)));    //五个特征脸    imshow(&quot;pc1&quot;, norm_0_255(pca.eigenvectors.row(0)).reshape(1, db[0].rows));    imshow(&quot;pc2&quot;, norm_0_255(pca.eigenvectors.row(1)).reshape(1, db[0].rows));    imshow(&quot;pc3&quot;, norm_0_255(pca.eigenvectors.row(2)).reshape(1, db[0].rows));    imshow(&quot;pc4&quot;, norm_0_255(pca.eigenvectors.row(3)).reshape(1, db[0].rows));    imshow(&quot;pc5&quot;, norm_0_255(pca.eigenvectors.row(4)).reshape(1, db[0].rows));    while(1)        waitKey(0);    // Success!    return 0;&#125;</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/01.png"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/05/pca-yuan-li-fen-xi/">PCA原理分析</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA原理分析</title>
      <link href="/2019/08/05/pca-yuan-li-fen-xi/"/>
      <url>/2019/08/05/pca-yuan-li-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>参考资料<br><a href="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/PCA.pdf">PCA原理分析</a></p><h1 id="PCA的数学原理"><a href="#PCA的数学原理" class="headerlink" title="PCA的数学原理"></a>PCA的数学原理</h1><p>PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。</p><h2 id="数据的向量表示以及降维问题"><a href="#数据的向量表示以及降维问题" class="headerlink" title="数据的向量表示以及降维问题"></a>数据的向量表示以及降维问题</h2><p>一般情况下，在数据挖掘和机器学习中，数据被表示为向量。例如某个外卖商家2018年全年的流量及交易记录可以看成是一组数据的集合，其中每一天的数据是一条记录。记录的格式如下:<br>(日期, 浏览量，访客数，下单数，成交数，成交金额)<br>其中”日期”是一个记录标志而非度量值，而数据挖掘关心的大多是度量值，因此如果我们忽略日期这个字段后，我们得到一组记录，每条记录可以被表示为一个五维向量，其中一条看起来大约是这个样子：<br>$$(1000, 580, 300, 240, 3000)^T$$<br>注意这里用了转置，习惯上使用列向量来表示一条记录。本文说到的向量默认都是列向量。    </p><p>我们当然可以对这一组五维向量进行分析和挖掘，不过很多机器学习算法的复杂度和数据的维数有着密切关系，甚至与维数呈指数级关联。当然，这里区区五维的数据，也许还无所谓，但是实际机器学习中处理成千上万甚至几十万维的情况也并不罕见，在这种情况下，机器学习的资源消耗是不可接受的，因此我们必须对数据进行降维。</p><p>降维当然意味着信息的丢失，不过鉴于实际数据本身常常存在的相关性，我们可以想办法在降维的同时将信息的损失尽量降低。    </p><p>举一个例子，假如某学籍数据有两列M和F，其中M列的取值是如何此学生为男性取值1，为女性取值0；而F列是学生为女性取值1，男性取值0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当M为1时F必定为0，反之当M为0时F必定为1。在这种情况下，我们将M或F去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。<br>当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“ <strong>相关关系</strong>”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。<br>这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。    </p><p>上面给出的是降维的朴素思想描述，可以有助于直观理解降维的动机和可行性，但并不具有操作指导意义。例如，我们到底删除哪一列损失的信息才最小？亦或根本不是单纯删除几列，而是通过某些变换将原始数据变为更少的列但又使得丢失的信息最小？到底如何度量丢失信息的多少？如何根据原始数据决定具体的降维操作步骤？下面对降维问题进行数学化和形式化的讨论</p><h2 id="向量的表示及基变换"><a href="#向量的表示及基变换" class="headerlink" title="向量的表示及基变换"></a>向量的表示及基变换</h2><h3 id="内积与投影"><a href="#内积与投影" class="headerlink" title="内积与投影"></a>内积与投影</h3><p>下面先来看一个高中就学过的向量运算：内积。两个维数相同的向量的内积被定义为：</p><p>$$(a_1, a_2, \dots ,a_n)^T \cdot (b_1, b_2, \dots , b_n)^T = a_1b_1 + a_2b_2 + \dots + a_nb_n)$$<br>内积运算将两个向量映射为一个实数。其计算方式非常容易理解，但是其意义并不明显。下面我们分析内积的几何意义。假设A和B是两个n维向量，我们知道n维向量可以等价表示为n维空间中的一条从原点发射的有向线段，为了简单起见我们假设A和B均为二维向量,则 $A = (x_1,y_1)$, $B = (x_2,y_2)$. 则在二维平面上A和B可以用两条发自原点的有向线段表示，见下图：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/01.png"><br>好，现在我们从A点向B所在直线引一条垂线。我们知道垂线与B的交点叫做A在B上的投影，再设A与B的夹角是a，则投影的矢量长度为|A|cos(a),其中 $|A| = \sqrt{x_1^2 + y_1^2}$ 是向量A的模，也就是A线段的标量长度。<br>注意这里我们专门区分了矢量长度和标量长度，标量长度总是大于等于0，值就是线段的长度；而矢量长度可能为负，其绝对值是线段长度，而符号取决于其方向与标准方向相同或相反。<br>到这里还是看不出内积和这东西有什么关系，不过如果我们将内积表示为另一种我们熟悉的形式：<br>$$ A \cdot B = |A||B|cos(a)$$</p><p>现在事情似乎是有点眉目了：A与B的内积等于A到B的投影长度乘以B的模。再进一步，如果我们假设B的模为1，即让|B|=1，那么就变成了：<br>$$A \cdot B = |A|cos(a)$$<br>也就是说， <strong>设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度！</strong>这就是内积的一种几何解释，也是我们得到的第一个重要结论。在后面的推导中，将反复使用这个结论。</p><h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>下面我们继续在二维空间内讨论向量。上文说过，一个二维向量可以对应二维笛卡尔直角坐标系中从原点出发的一个有向线段。例如下面这个向量：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/02.png"><br>在代数表示方面，我们经常用线段终点的点坐标表示向量，例如上面的向量可以表示为(3,2)，这是我们再熟悉不过的向量表示。<br>不过我们常常忽略， <strong>只有一个(3,2)本身是不能够精确表示一个向量的</strong>。我们仔细看一下，这里的3实际表示的是向量在x轴上的投影值是3，在y轴上的投影值是2。也就是说我们其实隐式引入了一个定义：以x轴和y轴上正方向长度为1的向量为标准。那么一个向量(3,2)实际是说在x轴投影为3而y轴的投影为2。注意投影是一个矢量，所以可以为负。<br>更正式的说，向量(x,y)实际上表示线性组合：<br>$$x(1,0)^T + y(0,1)^T$$<br>不难证明所有二维向量都可以表示为这样的线性组合。此处(1,0)和(0,1)叫做二维空间中的一组基。<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/03.png"><br>所以， <strong>要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了</strong>。只不过我们经常省略第一步，而默认以(1,0)和(0,1)为基。<br>我们之所以默认选择(1,0)和(0,1)为基，当然是比较方便，因为它们分别是x和y轴正方向上的单位向量，因此就使得二维平面上点坐标和向量一一对应，非常方便。但实际上任何两个线性无关的二维向量都可以成为一组基，所谓线性无关在二维平面内可以直观认为是两个不在一条直线上的向量。    </p><p>例如，(1,1)和(-1,1)也可以成为一组基。一般来说，我们希望基的模是1，因为从内积的意义可以看到，如果基的模是1，那么就可以方便的用向量点乘基而直接获得其在新基上的坐标了！实际上，对应任何一个向量我们总可以找到其同方向上模为1的向量，只要让两个分量分别除以模就好了。例如，上面的基可以变为 $(\frac{1}{\sqrt 2},\frac{1}{\sqrt 2})$ 和 $(\frac{-1}{\sqrt 2},\frac{1}{\sqrt 2})$.<br>现在，我们想获得(3,2)在新基上的坐标，即在两个方向上的投影矢量值，那么根据内积的几何意义，我们只要分别计算(3,2)和两个基的内积，不难得到新的坐标为 $(\frac{5}{\sqrt 2},\frac{-1}{\sqrt 2})$。下图给出了新的基以及(3,2)在新基上坐标值的示意图：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/05.png"><br>一要求就是线性无关，非正交的基也是可以的。不过因为正交基有较好的性质，所以一般使用的基都是正交的。</p><h3 id="基变换的矩阵表示"><a href="#基变换的矩阵表示" class="headerlink" title="基变换的矩阵表示"></a>基变换的矩阵表示</h3><p>下面我们找一种简便的方式来表示基变换。还是拿上面的例子，想一下，将(3,2)变换为新基上的坐标，就是用(3,2)与第一个基做内积运算，作为第一个新的坐标分量，然后用(3,2)与第二个基做内积运算，作为第二个新坐标的分量。实际上，我们可以用矩阵相乘的形式简洁的表示这个变换：<br>$$\begin{pmatrix}<br>1/ \sqrt 2 &amp; 1/ \sqrt 2 \\<br>-1/ \sqrt 2 &amp; 1/ \sqrt 2 \<br>\end{pmatrix}<br>\begin{pmatrix}<br>3 \\<br>2 \<br>\end{pmatrix} = \begin{pmatrix}<br>5 / \sqrt 2 \\<br>-1/ \sqrt 2 \<br>\end{pmatrix}$$</p><p>太漂亮了！其中矩阵的两行分别为两个基，乘以原向量，其结果刚好为新基的坐标。可以稍微推广一下，如果我们有m个二维向量，只要将二维向量按列排成一个两行m列矩阵，然后用“基矩阵”乘以这个矩阵，就得到了所有这些向量在新基下的值。例如 $(1,1)，(2,2)，(3,3)$，想变换到刚才那组基上，则可以这样表示：</p><p>$$\begin{pmatrix}<br>1 / \sqrt 2 &amp; 1/ \sqrt 2 \\<br>-1 / \sqrt 2 &amp; 1/ \sqrt 2 \<br>\end{pmatrix}<br>\begin{pmatrix}<br>1 &amp; 2 &amp; 3 \\<br>1 &amp; 2 &amp; 3 \<br>\end{pmatrix} = \begin{pmatrix}<br>2 / \sqrt 2 &amp; 4 / \sqrt 2 &amp; 6 / \sqrt 2 \\<br>0 &amp; 0 &amp; 0 \<br>\end{pmatrix}$$</p><p>于是一组向量的基变换被干净的表示为矩阵的相乘。<br><strong>一般的，如果我们有M个N维向量，想将其变换为由R个N维向量表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果，其中AB的第m列为A中第m列变换后的结果。</strong><br>数学表示为：<br>$$\begin{pmatrix}<br>p_1 \\<br>p_2 \\<br>\vdots \\<br>p_R \<br>\end{pmatrix}<br>\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \dots &amp; a_M \<br>\end{pmatrix} = \begin{pmatrix}<br>p_1a_1 &amp; p_1a_2 &amp; \dots &amp; p_1a_M \\<br>p_2a_1 &amp; p_2a_2 &amp; \dots &amp; p_2a_M \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>p_Ra_1 &amp; p_Ra_2 &amp; \dots &amp; p_Ra_M \<br>\end{pmatrix}$$<br>其中 $p_i$是一个行向量，表示第i个基， $a_j$是一个列向量，表示第j个原始数据记录。<br>特别要注意的是，这里R可以小于N，而R决定了变换后数据的维数。也就是说，我们可以将一N维数据变换到更低维度的空间中去，变换后的维度取决于基的数量。因此这种矩阵相乘的表示也可以表示降维变换。<br>最后，上述分析同时给矩阵相乘找到了一种物理解释： <strong>两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去</strong>。更抽象的说，一个矩阵可以表示一种线性变换。很多同学在学线性代数时对矩阵相乘的方法感到奇怪，但是如果明白了矩阵相乘的物理意义，其合理性就一目了然了。    </p><h3 id="协方差矩阵及优化目标"><a href="#协方差矩阵及优化目标" class="headerlink" title="协方差矩阵及优化目标"></a>协方差矩阵及优化目标</h3><p>上面我们讨论了选择不同的基可以对同样一组数据给出不同的表示，而且如果基的数量少于向量本身的维数，则可以达到降维的效果。但是我们还没有回答一个最最关键的问题：如何选择基才是最优的。或者说，如果我们有一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基才能最大程度保留原有的信息？<br>要完全数学化这个问题非常繁杂，这里我们用一种非形式化的直观方法来看这个问题。</p><p>为了避免过于抽象的讨论，我们仍以一个具体的例子展开。假设我们的数据由五条记录组成，将它们表示成矩阵形式：<br>$$ \begin{pmatrix}<br>1 &amp; 1 &amp;2 &amp; 4 &amp; 2 \\<br>1 &amp; 3 &amp; 3 &amp; 4 &amp; 4 \<br>\end{pmatrix}$$<br>其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，我们首先将每个字段内所有值都减去字段均值，其结果是将每个字段都变为均值为0（这样做的道理和好处后面会看到）。<br>我们看上面的数据，第一个字段均值为2，第二个字段均值为3，所以变换后：<br>$$ \begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \<br>\end{pmatrix}$$<br>我们可以看下五条数据在平面直角坐标系内的样子：<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/PCA%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/06.png"><br>现在问题来了：如果我们必须使用一维来表示这些数据，又希望尽量保留原始的信息，你要如何选择？    </p><p>通过上一节对基变换的讨论我们知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。这是一个实际的二维降到一维的问题。    </p><p>那么如何选择这个方向（或者说基）才能尽量保留最多的原始信息呢？一种直观的看法是：希望投影后的投影值尽可能分散。    </p><p>以上图为例，可以看出如果向x轴投影，那么最左边的两个点会重叠在一起，中间的两个点也会重叠在一起，于是本身四个各不相同的二维点投影后只剩下两个不同的值了，这是一种严重的信息丢失，同理，如果向y轴投影最上面的两个点和分布在x轴上的两个点也会重叠。所以看来x和y轴都不是最好的投影选择。我们直观目测，如果向通过第一象限和第三象限的斜线投影，则五个点在投影后还是可以区分的。<br>下面，我们用数学方法表述这个问题。</p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>上文说到，我们希望投影后投影值尽可能分散，而这种分散程度，可以用数学上的方差来表述。此处，一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即：<br>$$Var(a)=\frac{1}{m} \sum_{i=1}^{m}(a_i- \mu)^2$$<br>由于上面我们已经将每个字段的均值都化为0了，因此方差可以直接用每个元素的平方和除以元素个数表示：<br>$$Var(a) = \frac{1}{m} \sum_{i=1}^{m}a_i^2$$<br>于是上面的问题被形式化表述为：寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。    </p><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>对于上面二维降成一维的问题来说，找到那个使得方差最大的方向就可以了。不过对于更高维，还有一个问题需要解决。考虑三维降到二维问题。与之前相同，首先我们希望找到一个方向使得投影后方差最大，这样就完成了第一个方向的选择，继而我们选择第二个投影方向。<br>如果我们还是单纯只选择方差最大的方向，很明显，这个方向与第一个方向应该是“几乎重合在一起”，显然这样的维度是没有用的，因此，应该有其他约束条件。从直观上说，让两个字段尽可能表示更多的原始信息，我们是不希望它们之间存在（线性）相关性的，因为相关性意味着两个字段不是完全独立，必然存在重复表示的信息。<br>数学上可以用两个字段的协方差表示其相关性，由于已经让每个字段均值为0，则：<br>$$Cov(a,b)=\frac{1}{m} \sum_{i=1}^{m}a_ib_i$$<br>可以看到，在字段均值为0的情况下，两个字段的协方差简洁的表示为其内积除以元素数m。</p><p>当协方差为0时，表示两个字段完全独立。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p><p>至此，我们得到了降维问题的优化目标：<strong>将一组N维向量降为K维（K大于0，小于N），其目标是选择K个单位（模为1）正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）</strong>。</p><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><p>上面我们导出了优化目标，但是这个目标似乎不能直接作为操作指南（或者说算法），因为它只说要什么，但根本没有说怎么做。所以我们要继续在数学上研究计算方案。</p><p>我们看到，最终要达到的目的与字段内方差及字段间协方差有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。于是我们来了灵感：</p><p>假设我们只有a和b两个字段，那么我们将它们按行组成矩阵X：</p><p>$$ X = \begin{pmatrix}<br>a_1 &amp; a_2 &amp; \dots &amp; a_m \\<br>b_1 &amp; b_2 &amp; \dots &amp; b_m \<br>\end{pmatrix}$$<br>然后我们用X乘以X的转置，并乘上系数 $\frac{1}{m}$：<br>$$\frac{1}{m} \begin{pmatrix}<br>\frac{1}{m} \sum_{i=1}^{m}a_i^2 &amp; \frac{1}{m} \sum_{i=1}^{m}a_ib_i \\<br>\frac{1}{m} \sum_{i=1}^{m}a_ib_i &amp; \frac{1}{m} \sum_{i=1}^{m}b_i^2 \<br>\end{pmatrix}$$</p><p>奇迹出现了！这个矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。两者被统一到了一个矩阵的。</p><p>根据矩阵相乘的运算法则，这个结论很容易被推广到一般情况：</p><p><strong>设我们有m个n维数据记录，将其按列排成n乘m的矩阵X，设 $C = \frac{1}{m}XX^T$,则C是一个对称矩阵，其对角线分别个各个字段的方差，而第i行j列和j行i列元素相同，表示i和j两个字段的协方差。</strong></p><h3 id="协方差矩阵对角化"><a href="#协方差矩阵对角化" class="headerlink" title="协方差矩阵对角化"></a>协方差矩阵对角化</h3><p>根据上述推导，我们发现要达到优化目前，等价于将协方差矩阵对角化：即除对角线外的其它元素化为0，并且在对角线上将元素按大小从上到下排列，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系：</p><p>设原始数据矩阵X对应的协方差矩阵为C，而P是一组基按行组成的矩阵，设Y=PX，则Y为X对P做基变换后的数据。设Y的协方差矩阵为D，我们推导一下D与C的关系：<br>$$\begin{align}<br>D &amp;= \frac{1}{m}YY^T \\<br>  &amp;= \frac{1}{m}(PX)(PX)^T \\<br>  &amp;= \frac{1}{m}PXX^T P^T \\<br>  &amp;= P(\frac{1}{m}XX^T)P^T \\<br>  &amp;= PCP^T<br>\end{align}$$</p><p>现在事情很明白了！我们要找的P不是别的，而是能让原始协方差矩阵对角化的P。换句话说，优化目标变成了寻找一个矩阵P，满足 $PCP^T$ 是一个对角矩阵，并且对角元素按从大到小依次排列，那么P的前K行就是要寻找的基，用P的前K行组成的矩阵乘以X就使得X从N维降到了K维并满足上述优化条件。<br>现在所有焦点都聚焦在了协方差矩阵对角化问题上，有时，我们真应该感谢数学家的先行，因为矩阵对角化在线性代数领域已经属于被玩烂了的东西，所以这在数学上根本不是问题。</p><p>由上文知道，协方差矩阵C是一个是对称矩阵，在线性代数上，实对称矩阵有一系列非常好的性质：</p><ol><li>实对称矩阵不同特征值对应的特征向量必然正交</li><li>设特征向量λ重数为r，则必然存在r个线性无关的特征向量对应于λ，因此可以将这r个特征向量单位正交化。<br>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为 $e_1,e_2,\dots,e_n,$ 我们将其按列组成矩阵：<br>$$E = \begin{pmatrix}<br>e_1 &amp; e_2 &amp; \dots &amp; e_n \<br>\end{pmatrix}$$<br>则对协方差矩阵C有如下结论：<br>$$E_TCE = \Lambda = \begin{pmatrix}<br>\lambda_1 &amp; &amp; &amp; \\<br>&amp; \lambda_2 &amp; &amp; \\<br>&amp; &amp; \ddots &amp; \\<br>&amp; &amp; &amp; \lambda_n \<br>\end{pmatrix}$$<br>其中 $Lambda$为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。</li></ol><p>以上结论不再给出严格的数学证明，对证明感兴趣的朋友可以参考线性代数书籍关于“实对称矩阵对角化”的内容。</p><p>到这里，我们发现我们已经找到了需要的矩阵P：<br>$$P = E^T$$</p><p>P是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是C的一个特征向量。如果设P按照Λ中特征值的从大到小，将特征向量从上到下排列，则用P的前K行组成的矩阵乘以原始数据矩阵X，就得到了我们需要的降维后的数据矩阵Y。</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Face Detection</title>
      <link href="/2019/08/03/face-detection/"/>
      <url>/2019/08/03/face-detection/</url>
      
        <content type="html"><![CDATA[<h1 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h1><h2 id="OpenCV模块"><a href="#OpenCV模块" class="headerlink" title="OpenCV模块"></a>OpenCV模块</h2><ul><li>core：简洁核心模块，基本函数，基本数据结构</li><li>imgproc：图像处理模块，线性和非线性图像滤波，几何图像转换，颜色空间转换，直方图等。</li><li>video：视频分析模块，运动估计，背景消除，物体跟踪算法</li><li>calib3d：基本多视角几何算法，单体和立体相机的标定，对象姿势估计，双目立体匹配算法和元素的三维重建</li><li>features2d：包含了显著特征检测算法，描述算子和算子匹配算法</li><li>objdetect：物体检测和一些预定义的物体的检测（如人脸，眼睛，杯子，人，汽车等)</li><li>ml：多种机器学习算法，如K均值，支持向量机和神经网络</li><li>highgui：简单易用接口，有视频捕捉，图像和视频编码功能，简单UI接口，iOS的是其中一个子集</li><li>gpu：GPU加速算法，iOS不可用</li><li>ocl：OpenCL通用算法，iOS不可用</li><li>其它辅助模块，如用户贡献的算法</li></ul><h2 id="人脸检测-1"><a href="#人脸检测-1" class="headerlink" title="人脸检测"></a>人脸检测</h2><h2 id="检测图片中的人脸"><a href="#检测图片中的人脸" class="headerlink" title="检测图片中的人脸"></a>检测图片中的人脸</h2><p>在OpenCV中，主要使用两种特征进行人脸检测，Haar特征和LBP特征，下面使用的是LBP特征。<br>实现人脸检测主要依赖于detectMultiScale()函数</p><pre><code class="line-numbers language-cpp">CV_WRAP virtual void detectMultiScale( const Mat&amp; image,  CV_OUT vector&lt;Rect&gt;&amp; objects,  double scaleFactor=1.1,  int minNeighbors=3, int flags=0,  Size minSize=Size(),  Size maxSize=Size() );</code></pre><p>各参数含义如下：<br><strong>const Mat&amp; image</strong>: 需要被检测的图像（灰度图）。<br><strong>vector<Rect>&amp; objects</strong>: 保存被检测出的人脸位置坐标序列。<br><strong>double scaleFactor</strong>: 每次图片缩放的比例。<br><strong>int minNeighbors</strong>: 每一个人脸至少要检测到多少次才算是真的人脸。<br><strong>doubleint flags</strong>： 决定是缩放分类器来检测，还是缩放图像。<br><strong>Size()</strong>: 表示人脸的最大最小尺寸。</p><p>具体实现代码如下:</p><pre><code class="line-numbers language-cpp">#include&lt;opencv2/highgui/highgui.hpp&gt;#include&lt;opencv2/imgproc/imgproc.hpp&gt;#include&lt;opencv2/objdetect/objdetect.hpp&gt;#include&lt;iostream&gt;#include&lt;opencv2/core.hpp&gt;using namespace std;using namespace cv;#define CV_COLOR_GREEN cv::Scalar(0, 255, 0)CascadeClassifier faceCascade;int main(int argc, char* argv[])&#123; Mat img; CascadeClassifier faceDetector(&quot;lbpcascade_frontalface.xml&quot;);//读取分类器 img = imread(argv[1]);  //读取检测的图片原图 vector&lt;Rect&gt; objects;  //存放检测的对象 faceDetector.detectMultiScale(img, objects);  //执行检测 for (int i = 0; i &lt; objects.size(); i++) //遍历检测到的脸 &#123;  rectangle(img, objects[i], CV_COLOR_RED);  //画出检测到的脸 &#125; imshow(&quot;result&quot;, img);  //显示结果 waitKey(0); return 0;&#125;</code></pre><p>检测结果:<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/2.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/3.png"></p><h3 id="检测视频中的人脸"><a href="#检测视频中的人脸" class="headerlink" title="检测视频中的人脸"></a>检测视频中的人脸</h3><p>原理就是对视频逐帧处理，1s大约分为30帧。</p><pre><code class="line-numbers language-cpp">#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;#define CV_COLOR_GREEN cv::Scalar(0, 255, 0)CascadeClassifier faceCascade;int main(int argc, char** argv)&#123;  //打开摄像头  VideoCapture cap(0);  if(!cap.isOpened())  &#123;    return -1;  &#125;  //读取分类器  CascadeClassifier faceDetector(&quot;lbpcascade_frontalface.xml&quot;);  vector&lt;Rect&gt; objects;  Mat frame;  Mat edges;  bool stop = false;  while(!stop)&#123;    cap &gt;&gt; frame;    if (frame.empty())      stop = true;    double scaleFactor=1.1;    int minNeighbors = 3;    //int flags = 1;    //cvtColor(frame, edges, CV_BGR2GRAY);    //GaussianBlur(edges, edges, Size(7,7), 1.5, 1.5);    faceDetector.detectMultiScale(frame, objects,scaleFactor, minNeighbors);    for(int i = 0; i &lt; objects.size(); i++)&#123;      rectangle(frame, objects[i], CV_COLOR_GREEN);      rectangle(edges, objects[i], CV_COLOR_GREEN);    &#125;    //imshow(&quot;edge&quot;, edges);    imshow(&quot;frame&quot;, frame);    if (waitKey(30) &gt;= 0)      stop = true;  &#125;  return 0;&#125;</code></pre><p>识别结果:</p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/4.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/Face-Detection/5.png"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
          <category> 人脸检测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Face_Detection </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Local Binary Patterns</title>
      <link href="/2019/08/01/local-binary-patterns/"/>
      <url>/2019/08/01/local-binary-patterns/</url>
      
        <content type="html"><![CDATA[<h1 id="LBP算法"><a href="#LBP算法" class="headerlink" title="LBP算法"></a>LBP算法</h1><p>LBP（Local Binary Patterns，局部二值模式）是一种能够有效地度量和提取图像局部纹理信息的算子，具有旋转不变性和灰度不变性等显著的优点。它是人脸识别中一种提取特征的重要方法，具有对光照不敏感的特性，但是对姿态和表情的鲁棒性不强。</p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>纹理是由于物体表面物理属性不同所引起的能够表示某个特定表面特征的灰度或颜色信息。纹理反映了图像灰度模式的空间分布，包含了图像的表面信息及其周围环境的关系。</p><h2 id="基本的LBP算子"><a href="#基本的LBP算子" class="headerlink" title="基本的LBP算子"></a>基本的LBP算子</h2><p>局部二值模式是一种灰度范围内的纹理描述方式。最初的LBP算子定义在一个3×3的窗口，以窗口中心像素点为阈值，将相邻的像素的灰度值与其进行比较，若周围的像素值大于中心点的值，则将该像素位置标记为1,否则为0.这样一个3×3邻域内的8个点可产生一个8-bit的无符号数，再按其位置赋予不同权重求和得一整数，即可得到该窗口的 <strong>LBP</strong> 值，并用这个数反映该区域的纹理信息。<br>对比度分量C是邻域中所有大于和等于中心点像素的均值与所有小于中心点像素的均值之差。<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779ca87257597.jpg"></p><p>基本的LBP算子最大的缺陷是只覆盖了一个固定半径范围内的小区域，改进的LBP算子，将3×3邻域扩展到任意邻域，用圆形邻域代替了正方形邻域，该算子允许在半径为R的圆形邻域内有任意多个像素点。</p><ul><li>一个局部区域的纹理分布可假设为局部区域内像素灰度的联合分布密度<br>$$T = t(g_c,g_0, ….,g_{p-1})$$<br>$g_c$表示局部区域的中心点的灰度值,$g_p(p=0,1,…,p)$对应中心点周围等距分布的P个点</li><li>采用 <strong>双线性插算法</strong> 对没有完全落在像素位置的点计算灰度值。邻域内的$g_p$点的坐标可以表示为:<br>$$(x_p,y_p) = (x_c + Rcos(\frac{2\pi}{P}),y_c - Rsin(\frac{2\pi}{P}))$$<br>$(x_c,y_c)$表示中心点的坐标</li><li>将中心点$g_c$的值从邻域像素的灰度值$g_p$中减去，则局部区域的纹理可以用中心点和中心点与周边像素值之差的联合分布来表示:<br>$$T = t(g_c,g_0-g_c,….,g_{p-1}-g_c)$$</li><li>假设中心像素点$g_c$与周边点像素$g_p$的差值$g_p-g_c(p=0,1,…P)$独立于中心点$g_c$，则<br>$$T\approx t(g_c)(g_0-g_c,…,g_{p-1}-g_c)$$</li><li>实际上，$t(g_c)$只是描述了整个图像的亮度分布情况，而和图像的局部纹理无关，它不能为纹理分析提供任何有价值的信息<br>$$T\approx t(g_0-g_c,…,g_{p-1}-g_c)$$</li><li>差值的联合分布具有灰度平移不变性，即邻域中所有P+1个像素同时加上或减去某个值，其表征的纹理不变。</li><li>为了达到尺度不变的目的，只考虑差值的符号<br>$$T\approx t(s(g_0-g_c),…,s(g_p-g_c))$$</li></ul><p>$$s(x)=\begin{cases}<br>1 , \quad &amp;x &gt; 0  \\<br>0 , &amp;x \geqslant 0<br>\end{cases}<br>$$</p><p>上式得到了一个8位的二进制数，再对像素按不同位置用$2^p$进行加权求和，这样得到了一个与邻域像素点相关的唯一的 <strong>LBP</strong> 值，这个值称为 <strong>模式</strong>。这个值描述的是以$(x_c,y_c)$为中心的局部区域的纹理，可以表示为<br>$$LBP(x_c,y_c) = \sum_{p=0}^{P-1}s(g_p - g_c)2^P$$<br>上式意味着差值的符号转化成一个P-bit的二进制数，进而转化成为一个取值范围为0-$2^p$的离散的LBP值，或者说转化为一种LBP模式。</p><ul><li>局部区域的灰度分布或纹理，可以用这个LBP值或LBP模式近似描述为:<br>$$T\approx t(LBP(x_c,y_c))$$<br>LBP算子对于任何单调的灰度变化具有鲁棒性，用符号$LBP_P^R$表示在半径为R的圆形邻域内有P个像素点$g_p(p=0,1,…,P)$的LBP算子<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779b84ac47631.jpg"></li></ul><h2 id="LBP等价模式"><a href="#LBP等价模式" class="headerlink" title="LBP等价模式"></a>LBP等价模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当某个局部二进制模式所对应的循环二进制数从０到１或从１到０最多有两次跳变时，该局部二进制模式所对应的二进制就称为一个等价模式类。比如00000000,11111111,10001111都是等价类。</p><h3 id="检验方法"><a href="#检验方法" class="headerlink" title="检验方法"></a>检验方法</h3><p>检验某种模式是否是等价模式的简单办法是将其和其移动一位后的二进制模式按位相减的绝对值求和<br>$$U(G_p) = |s(g_{p-1}-g_c)-s(g_0-g_c)|+\sum_{p=1}^{P-1}|s(g_p-g_c)-s(g_{p-1}-g_c)$$<br>若某种模式计算得到的 $U(G_p)$小于或等于２，则将其归于等价模式<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779c949196019.jpg"></p><h2 id="旋转不变的LBP算子"><a href="#旋转不变的LBP算子" class="headerlink" title="旋转不变的LBP算子"></a>旋转不变的LBP算子</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>不断旋转圆形邻域得到一系列的初始定义的LBP值，取其最小值作为该邻域的LBP值，用公式表示为:<br>$$LBP_{P,R}^{ri} = min(ROR(LBP_{P,R}^{ri},i)|i=0,1,…,P-1)$$<br>$LBP^{ri}$表示旋转不变的LBP算子，$ROR(x,i)$函数为旋转函数，表示将x循环右移i(i&lt;P)位。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>对于图像旋转，表现的更为鲁棒，并且LBP模式的种类进一步减少，使纹理识别更加容易。</li><li>丢失了方向信息<br><img loading="lazy" src="https://i.loli.net/2019/07/31/5d415779b8fed91298.jpg"></li></ul><h2 id="旋转不变的的等价模式"><a href="#旋转不变的的等价模式" class="headerlink" title="旋转不变的的等价模式"></a>旋转不变的的等价模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将等价模式类进行旋转得到旋转不变的等价模式</p><p>$$LBP_{P,R}^{riu2} = \begin{cases}<br>\sum_{P=0}^{P-1}s(g_p-g_c), &amp; U(G_p) \leq 2 \\<br>P + 1, &amp; U(G_p) &gt;2<br>\end{cases}<br>$$</p><p>其中$U(G_p)$表示0到1或1到0跳变的次数，$LBP^{riu2}$被称为旋转不变的等价模式</p><h2 id="几种LBP算子的维数比较"><a href="#几种LBP算子的维数比较" class="headerlink" title="几种LBP算子的维数比较"></a>几种LBP算子的维数比较</h2><table><thead><tr><th align="center">LBP</th><th align="center">原始模式数</th><th align="center">等价模式</th><th align="center">旋转不变等价模式</th></tr></thead><tbody><tr><td align="center">$LBP_P^R$</td><td align="center">$2^P$</td><td align="center">$P(P-1) + 2$</td><td align="center">$P+1$</td></tr><tr><td align="center">$LBP_8^1$</td><td align="center">256</td><td align="center">58(+1)</td><td align="center">9</td></tr><tr><td align="center">$LBP_{16}^2$</td><td align="center">65536</td><td align="center">242(+1)</td><td align="center">17</td></tr><tr><td align="center">$LBP_{24}^3$</td><td align="center">16777216</td><td align="center">554(+1)</td><td align="center">25</td></tr></tbody></table><h1 id="LBP特征实现"><a href="#LBP特征实现" class="headerlink" title="LBP特征实现"></a>LBP特征实现</h1><h2 id="原始LBP特征"><a href="#原始LBP特征" class="headerlink" title="原始LBP特征"></a>原始LBP特征</h2><pre><code class="line-numbers language-cpp">//Original_LBPMat get_original_LBP_feature(Mat img)&#123;  Mat result;  result.create(img.rows - 2, img.cols -2, img.type());  result.setTo(0);  for (int i = 1; i &lt; img.rows - 1; i++)&#123;    for (int j = 1; j &lt; img.cols -1; j++)&#123;      uchar center = img.at&lt;uchar&gt;(i, j);      uchar lbpcode = 0;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j - 1) &gt;= center) &lt;&lt; 7;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j) &gt;= center) &lt;&lt; 6;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j + 1) &gt;= center) &lt;&lt; 5;      lbpcode |= (img.at&lt;uchar&gt;(i, j -1) &gt;= center) &lt;&lt; 4;      lbpcode |= (img.at&lt;uchar&gt;(i, j + 1) &gt;= center) &lt;&lt; 3;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j - 1) &gt;= center) &lt;&lt; 2;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j) &gt;= center) &lt;&lt; 1;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j + 1) &gt;= center) &lt;&lt; 0;      result.at&lt;uchar&gt;(i - 1, j - 1) = lbpcode;    &#125;  &#125;  return result;&#125;</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/31/5d4161dac5f0b23887.png"></p><h2 id="圆形LBP特征"><a href="#圆形LBP特征" class="headerlink" title="圆形LBP特征"></a>圆形LBP特征</h2><pre><code class="line-numbers language-cpp">//Circular_LBP_featureMat get_circular_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  //循环处理每个像素  for(int i=radius;i&lt;img.rows-radius;i++)  &#123;      for(int j=radius;j&lt;img.cols-radius;j++)      &#123;          //获得中心像素点的灰度值          uchar center = img.at&lt;uchar&gt;(i,j);          uchar lbpCode = 0;          for(int k=0;k&lt;neighbors;k++)          &#123;              //根据公式计算第k个采样点的坐标，这个地方可以优化，不必每次都进行计算radius*cos，radius*sin              float x = i + static_cast&lt;float&gt;(radius * \                  cos(2.0 * CV_PI * k / neighbors));              float y = j - static_cast&lt;float&gt;(radius * \                  sin(2.0 * CV_PI * k / neighbors));                //根据取整结果进行双线性插值，得到第k个采样点的灰度值                //1.分别对x，y进行上下取整                int x1 = static_cast&lt;int&gt;(floor(x));                int x2 = static_cast&lt;int&gt;(ceil(x));                int y1 = static_cast&lt;int&gt;(floor(y));                int y2 = static_cast&lt;int&gt;(ceil(y));                //将坐标映射到0-1之间                float tx = x - x1;                float ty = y - y1;                //根据0-1之间的x，y的权重计算公式计算权重                float w1 = (1-tx) * (1-ty);                float w2 =    tx  * (1-ty);                float w3 = (1-tx) *    ty;                float w4 =    tx  *    ty;                //3.根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(x1,y1) * w1 + img.at&lt;uchar&gt;(x1,y2) *w2 + img.at&lt;uchar&gt;(x2,y1) * w3 +img.at&lt;uchar&gt;(x2,y2) *w4;                //通过比较获得LBP值，并按顺序排列起来                lbpCode |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;            result.at&lt;uchar&gt;(i-radius,j-radius) = lbpCode;        &#125;    &#125;  return result;&#125;</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/08/01/5d42b5d2e345026549.png"></p><p>第一幅图设置半径为4,第二幅图设置半径为1,可以看到半径越小处理的越精细。</p><h2 id="旋转不变LBP特征"><a href="#旋转不变LBP特征" class="headerlink" title="旋转不变LBP特征"></a>旋转不变LBP特征</h2><pre><code class="line-numbers language-cpp">//Rotation_Invariant_LBP_featureMat get_rotation_invariant_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  for(int k=0;k&lt;neighbors;k++)    &#123;        //计算采样点对于中心点坐标的偏移量rx，ry        float rx = static_cast&lt;float&gt;(radius * cos(2.0 * CV_PI * k / neighbors));        float ry = -static_cast&lt;float&gt;(radius * sin(2.0 * CV_PI * k / neighbors));        //为双线性插值做准备        //对采样点偏移量分别进行上下取整        int x1 = static_cast&lt;int&gt;(floor(rx));        int x2 = static_cast&lt;int&gt;(ceil(rx));        int y1 = static_cast&lt;int&gt;(floor(ry));        int y2 = static_cast&lt;int&gt;(ceil(ry));        //将坐标偏移量映射到0-1之间        float tx = rx - x1;        float ty = ry - y1;        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关        float w1 = (1-tx) * (1-ty);        float w2 =    tx  * (1-ty);        float w3 = (1-tx) *    ty;        float w4 =    tx  *    ty;        //循环处理每个像素        for(int i=radius;i&lt;img.rows-radius;i++)        &#123;            for(int j=radius;j&lt;img.cols-radius;j++)            &#123;                //获得中心像素点的灰度值                uchar center = img.at&lt;uchar&gt;(i,j);                //根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(i+x1,j+y1) * w1 + img.at&lt;uchar&gt;(i+x1,j+y2) *w2 + img.at&lt;uchar&gt;(i+x2,j+y1) * w3 +img.at&lt;uchar&gt;(i+x2,j+y2) *w4;                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得                result.at&lt;uchar&gt;(i-radius,j-radius) |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;        &#125;    &#125;    //进行旋转不变处理    for(int i=0;i&lt;result.rows;i++)    &#123;        for(int j=0;j&lt;result.cols;j++)        &#123;            uchar currentValue = result.at&lt;uchar&gt;(i,j);            uchar minValue = currentValue;            for(int k=1;k&lt;neighbors;k++)        //循环左移            &#123;                uchar temp = (currentValue&gt;&gt;(neighbors-k)) | (currentValue&lt;&lt;k);                if(temp &lt; minValue)                &#123;                    minValue = temp;                &#125;            &#125;            result.at&lt;uchar&gt;(i,j) = minValue;        &#125;    &#125;    return result;&#125;</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/08/01/5d42b5d30749958722.png"></p><p>第一幅图neighbors值设置为8,第二幅设置为6,可以看出neighbors值越大，得到的LBP特征亮度越高。</p><h2 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h2><pre><code class="line-numbers language-cpp">#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;//Original_LBPMat get_original_LBP_feature(Mat img)&#123;  Mat result;  result.create(img.rows - 2, img.cols -2, img.type());  result.setTo(0);  for (int i = 1; i &lt; img.rows - 1; i++)&#123;    for (int j = 1; j &lt; img.cols -1; j++)&#123;      uchar center = img.at&lt;uchar&gt;(i, j);      uchar lbpcode = 0;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j - 1) &gt;= center) &lt;&lt; 7;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j) &gt;= center) &lt;&lt; 6;      lbpcode |= (img.at&lt;uchar&gt;(i - 1, j + 1) &gt;= center) &lt;&lt; 5;      lbpcode |= (img.at&lt;uchar&gt;(i, j -1) &gt;= center) &lt;&lt; 4;      lbpcode |= (img.at&lt;uchar&gt;(i, j + 1) &gt;= center) &lt;&lt; 3;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j - 1) &gt;= center) &lt;&lt; 2;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j) &gt;= center) &lt;&lt; 1;      lbpcode |= (img.at&lt;uchar&gt;(i + 1, j + 1) &gt;= center) &lt;&lt; 0;      result.at&lt;uchar&gt;(i - 1, j - 1) = lbpcode;    &#125;  &#125;  return result;&#125;//Circular_LBP_featureMat get_circular_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  //循环处理每个像素  for(int i=radius;i&lt;img.rows-radius;i++)  &#123;      for(int j=radius;j&lt;img.cols-radius;j++)      &#123;          //获得中心像素点的灰度值          uchar center = img.at&lt;uchar&gt;(i,j);          uchar lbpCode = 0;          for(int k=0;k&lt;neighbors;k++)          &#123;              //根据公式计算第k个采样点的坐标，这个地方可以优化，不必每次都进行计算radius*cos，radius*sin              float x = i + static_cast&lt;float&gt;(radius * \                  cos(2.0 * CV_PI * k / neighbors));              float y = j - static_cast&lt;float&gt;(radius * \                  sin(2.0 * CV_PI * k / neighbors));                //根据取整结果进行双线性插值，得到第k个采样点的灰度值                //1.分别对x，y进行上下取整                int x1 = static_cast&lt;int&gt;(floor(x));                int x2 = static_cast&lt;int&gt;(ceil(x));                int y1 = static_cast&lt;int&gt;(floor(y));                int y2 = static_cast&lt;int&gt;(ceil(y));                //将坐标映射到0-1之间                float tx = x - x1;                float ty = y - y1;                //根据0-1之间的x，y的权重计算公式计算权重                float w1 = (1-tx) * (1-ty);                float w2 =    tx  * (1-ty);                float w3 = (1-tx) *    ty;                float w4 =    tx  *    ty;                //3.根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(x1,y1) * w1 + img.at&lt;uchar&gt;(x1,y2) *w2 + img.at&lt;uchar&gt;(x2,y1) * w3 +img.at&lt;uchar&gt;(x2,y2) *w4;                //通过比较获得LBP值，并按顺序排列起来                lbpCode |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;            result.at&lt;uchar&gt;(i-radius,j-radius) = lbpCode;        &#125;    &#125;  return result;&#125;//Rotation_Invariant_LBP_featureMat get_rotation_invariant_LBP_feature(Mat img, int radius, int neighbors)&#123;  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  for(int k=0;k&lt;neighbors;k++)    &#123;        //计算采样点对于中心点坐标的偏移量rx，ry        float rx = static_cast&lt;float&gt;(radius * cos(2.0 * CV_PI * k / neighbors));        float ry = -static_cast&lt;float&gt;(radius * sin(2.0 * CV_PI * k / neighbors));        //为双线性插值做准备        //对采样点偏移量分别进行上下取整        int x1 = static_cast&lt;int&gt;(floor(rx));        int x2 = static_cast&lt;int&gt;(ceil(rx));        int y1 = static_cast&lt;int&gt;(floor(ry));        int y2 = static_cast&lt;int&gt;(ceil(ry));        //将坐标偏移量映射到0-1之间        float tx = rx - x1;        float ty = ry - y1;        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关        float w1 = (1-tx) * (1-ty);        float w2 =    tx  * (1-ty);        float w3 = (1-tx) *    ty;        float w4 =    tx  *    ty;        //循环处理每个像素        for(int i=radius;i&lt;img.rows-radius;i++)        &#123;            for(int j=radius;j&lt;img.cols-radius;j++)            &#123;                //获得中心像素点的灰度值                uchar center = img.at&lt;uchar&gt;(i,j);                //根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at&lt;uchar&gt;(i+x1,j+y1) * w1 + img.at&lt;uchar&gt;(i+x1,j+y2) *w2 + img.at&lt;uchar&gt;(i+x2,j+y1) * w3 +img.at&lt;uchar&gt;(i+x2,j+y2) *w4;                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得                result.at&lt;uchar&gt;(i-radius,j-radius) |= (neighbor&gt;center) &lt;&lt;(neighbors-k-1);            &#125;        &#125;    &#125;    //进行旋转不变处理    for(int i=0;i&lt;result.rows;i++)    &#123;        for(int j=0;j&lt;result.cols;j++)        &#123;            uchar currentValue = result.at&lt;uchar&gt;(i,j);            uchar minValue = currentValue;            for(int k=1;k&lt;neighbors;k++)        //循环左移            &#123;                uchar temp = (currentValue&gt;&gt;(neighbors-k)) | (currentValue&lt;&lt;k);                if(temp &lt; minValue)                &#123;                    minValue = temp;                &#125;            &#125;            result.at&lt;uchar&gt;(i,j) = minValue;        &#125;    &#125;    return result;&#125;int main(int argc, char* argv[])&#123;  Mat src = imread(argv[1], 0);  Mat dst = get_original_LBP_feature(src);  Mat odst1 = get_circular_LBP_feature(src, 1, 8);  //Mat odst4 = get_circular_LBP_feature(src, 4, 8);  Mat rif8 = get_rotation_invariant_LBP_feature(src, 1, 8);  Mat rif6 = get_rotation_invariant_LBP_feature(src, 1, 6);  imshow(&quot;原始图片&quot;, src);  imshow(&quot;原始LBP&quot;, dst);  imshow(&quot;圆形LBP&quot;, odst1);  //imshow(&quot;圆形LBP4&quot;, odst4);  imshow(&quot;旋转不变LBP&quot;, rif8);  //imshow(&quot;旋转不变LBP6&quot;, rif6);  waitKey(0);  return 0;&#125;</code></pre><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> c++ </tag>
            
            <tag> LBP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>High-quality-ellipse-detection</title>
      <link href="/2019/07/29/high-quality-ellipse-detection/"/>
      <url>/2019/07/29/high-quality-ellipse-detection/</url>
      
        <content type="html"><![CDATA[<h1 id="High-quality-ellipse-detection"><a href="#High-quality-ellipse-detection" class="headerlink" title="High-quality-ellipse-detection"></a>High-quality-ellipse-detection</h1><p>个人环境:Matlab 2019a、VS2017、Opencv3.4.4，64位Windows操作系统</p><h2 id="OpenCV环境配置请看这篇"><a href="#OpenCV环境配置请看这篇" class="headerlink" title="OpenCV环境配置请看这篇"></a>OpenCV环境配置请看这篇</h2><p><a href="https://godliuyang.wang/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/">OpenCV入坑指南:环境搭建篇</a></p><h2 id="MatLab和C-混合编程环境配置"><a href="#MatLab和C-混合编程环境配置" class="headerlink" title="MatLab和C++混合编程环境配置"></a>MatLab和C++混合编程环境配置</h2><p>Matlab的安装这里不再说    </p><ol><li>在命令行里输入 <code>mex -setup</code>，选择vs就行了</li><li>执行 <code>mex -setup C++</code>完成配置<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/1.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/2.png"></li></ol><h2 id="下载Github文件"><a href="#下载Github文件" class="headerlink" title="下载Github文件"></a>下载Github文件</h2><p>download Zip即可</p><h2 id="导入依赖文件"><a href="#导入依赖文件" class="headerlink" title="导入依赖文件"></a>导入依赖文件</h2><p>将 <strong>D:\OpenCV\opencv\build\x64\vc15\lib</strong>下的 <strong>opencv_world344.lib</strong>文件复制到你的Matlab安装路径下的 <strong>microsoft</strong>文件夹下,我的是 <strong>D:\MATLAB\R2019a\extern\lib\win64\microsoft</strong></p><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/3.png"><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/4.png"></p><h2 id="在Matlab中导入文件"><a href="#在Matlab中导入文件" class="headerlink" title="在Matlab中导入文件"></a>在Matlab中导入文件</h2><h2 id="在命令行执行以下命令"><a href="#在命令行执行以下命令" class="headerlink" title="在命令行执行以下命令"></a>在命令行执行以下命令</h2><p>注意作者的命令为:</p><pre><code class="line-numbers language-matlab">mex generateEllipseCandidates.cpp -IF:\OpenCV\opencv2.4.9\build\include -IF:\OpenCV\opencv2.4.9\build\include\opencv -IF:\OpenCV\opencv2.4.9\build\include\opencv2 -LF:\OpenCV\opencv2.4.9\build\x64\vc11\lib -IF:\Matlab\settlein\extern\include -LF:\Matlab\settlein\extern\lib\win64\microsoft -lopencv_core249 -lopencv_highgui249 -lopencv_imgproc249 -llibmwlapack.lib</code></pre><p>把OpenCV和Matlab的相关文件的路径改成你的安装路径<br>我这里版本号为OpenCV3.4.4,安装路径如下,<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/5.png"><br>故修改为<code>D:\OpenCV\opencv\build...</code>,<br>由于OpenCV3.4.4只有 <strong>opencv_world344.lib</strong> 这一个lib文件，故将 <code>LF:\Matlab\settlein\extern\lib\win64\microsoft -lopencv_core249 -lopencv_highgui249 -lopencv_imgproc249 -llibmwlapack.lib</code>　修改为 <code>LD:\Matlab\R2019a\extern\lib\win64\microsoft -lopencv_world344 -llibmwlapack.lib</code></p><p>完整的命令为:</p><pre><code class="line-numbers language-matlab">mex generateEllipseCandidates.cpp -ID:\OpenCV\opencv\build\include -ID:\OpenCV\opencv\build\include\opencv -ID:\OpenCV\opencv\build\include\opencv2 -LD:\OpenCV\opencv\build\x64\vc15\lib -ID:\Matlab\R2019a\include -LD:\Matlab\R2019a\extern\lib\win64\microsoft -lopencv_world344 -llibmwlapack.lib</code></pre><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/6.png"><br>编译成功之后生成<code>generateEllipseCandidates.mexw64</code>文件<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/7.png"><br>之后再运行<code>LCS_ellipse.m</code><br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/8.png"></p><p>##　报错解决办法</p><ol><li>如图<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/9.png"><br>在.cpp文件中添加</li></ol><pre><code class="line-numbers language-cpp">using namespace std</code></pre><ol start="2"><li>如图</li></ol><p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/High-quality-ellipse-detection/10.png"><br>缺少lib文件，检查一下是不是配置出错了</p><p>参考文献:</p><ol><li><a href="https://github.com/AlanLuSun/High-quality-ellipse-detection">Arc-support Line Segments Revisited: An Efficient and High-quality Ellipse Detection</a></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ellipse function</title>
      <link href="/2019/07/28/ellipse-function/"/>
      <url>/2019/07/28/ellipse-function/</url>
      
        <content type="html"><![CDATA[<h1 id="High-quality-ellipse-detection"><a href="#High-quality-ellipse-detection" class="headerlink" title="High-quality-ellipse-detection"></a>High-quality-ellipse-detection</h1><p>高精度椭圆检测<br>参考<a href="https://github.com/AlanLuSun/High-quality-ellipse-detection">High-quality-ellipse-detection</a></p><p>关于椭圆检测的部分，实在是看不懂，我只做了得到椭圆参数绘制椭圆的部分</p><h2 id="OpenCV椭圆绘制"><a href="#OpenCV椭圆绘制" class="headerlink" title="OpenCV椭圆绘制"></a>OpenCV椭圆绘制</h2><h3 id="ellipse函数"><a href="#ellipse函数" class="headerlink" title="ellipse函数"></a>ellipse函数</h3><p>语法</p><pre><code>void cvEllipse( CvArr* img, CvPoint center, CvSize axes, double angle,                double start_angle, double end_angle, CvScalar color,                int thickness=1, int line_type=8, int shift=0 );</code></pre><p>参数:<br>img:图像。<br>center:椭圆圆心坐标。<br>axes:轴的长度。<br>angle:偏转的角度。<br>start_angle:圆弧起始角的角度。<br>end_angle:圆弧终结角的角度。<br>color:线条的颜色。<br>thickness:线条的粗细程度。<br>line_type:线条的类型,见CVLINE的描述。<br>shift:圆心坐标点和数轴的精度。    </p><p>C++代码实现</p><pre><code class="line-numbers language-cpp">#include&lt;opencv2/opencv.hpp&gt;#include&lt;opencv2/core/core.hpp&gt; // 核心组件#include&lt;opencv2/highgui/highgui.hpp&gt;  // GUI#include&lt;opencv2/imgproc/imgproc.hpp&gt;  // 图像处理using namespace cv;using namespace std;// 定义存储椭圆参数的数据结构struct Ellipse &#123;    int x0, y0, a, b;    double alpha;&#125;;int drawEllipse(Ellipse ellipses_para, Mat im);int drawEllipse(Ellipse ellipses_para, Mat im) &#123;// Draw Ellipse after detection//x0 - x coordinate of the center of the ellipse//y0 - y coordinate of the center of the ellipse//a - length of semimajor axis//b - length of semiminor axis//alpha - angle of orientation of semimajor axis    if (im.empty()) &#123;        printf(&quot;imread error!&quot;);        return -1;    &#125;    int x0, y0, a, b;    double alpha;    int thickness = 3;    int lineType = 8;    x0 = ellipses_para.x0;    y0 = ellipses_para.y0;    a = ellipses_para.a;    b = ellipses_para.b;    alpha = ellipses_para.alpha;    ellipse(im, Point(x0, y0), Size(a, b), alpha, 0, 360, Scalar(255, 255, 0), thickness, lineType);    imshow(&quot;原图&quot;, im);    waitKey();&#125;int main() &#123;    Ellipse ellipses_para;    Mat im = imread(&quot;11.bmp&quot;);    /*test        ellipses_para.x0 = 100;    ellipses_para.y0 = 100;    ellipses_para.a = 90;    ellipses_para.b = 60;    ellipses_para.alpha = 80.0;*/    drawEllipse(ellipses_para, im);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆形检测</title>
      <link href="/2019/07/26/yuan-xing-jian-ce/"/>
      <url>/2019/07/26/yuan-xing-jian-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="基于霍夫变换的圆形检测"><a href="#基于霍夫变换的圆形检测" class="headerlink" title="基于霍夫变换的圆形检测"></a>基于霍夫变换的圆形检测</h1><h2 id="霍夫变换的原理"><a href="#霍夫变换的原理" class="headerlink" title="霍夫变换的原理"></a>霍夫变换的原理</h2><p>Hough 变换就是利用图像全局特征将边缘像素连接起来组成区域封闭边界，它将图像空间转换到参数空间，在参数空间对点进行描述，达到检测图像边缘的目的。该方法把所有可能落在边缘上的点进行统计计算，根据对数据的统计结果确定属于边缘的程度。Hough 变换的实质就是对图像进行坐标变换，把平面坐标变换为参数坐标，使变换的结果更易识别和检测。<br>具体原理: <a href="https://godliuyang.wang/2019/07/26/huo-fu-bian-huan/">霍夫变换</a></p><hr><h3 id="对霍夫变换圆形检测的原理的理解"><a href="#对霍夫变换圆形检测的原理的理解" class="headerlink" title="对霍夫变换圆形检测的原理的理解:"></a>对霍夫变换圆形检测的原理的理解:</h3><p>已知圆的一般方程为:<br>$$(x-a)^2 + (y-b)^2 = r^2 $$<br>其中(a,b)代表圆心，r是圆的半径<br>依旧是把图像空间转换成参数空间，这里是将X-Y平面转化成a-b-r参数空间，则在图像空间中的一个过(x,y)点的圆，对应参数空间中高度变化的三维锥面。<br><img loading="lazy" src="https://i.loli.net/2019/07/26/5d3ab8c50fc2a28962.jpg"><br>同理，过图像空间的任意一点的圆都对应于参数空间的一个三维锥面，因此，过图像空间上同一圆的点，对应的参数空间中的三维锥面，在r平面必然相交于一点(a,b,r)，这样通过这一点就可以得到一个圆的参数。<br><img loading="lazy" src="https://i.loli.net/2019/07/26/5d3ab8c4d635d79647.jpg"><br>这里霍夫变换的圆检测就是在这三个参数组成的三维空间内进行的<br>换一种理解思路:在笛卡尔坐标下的圆的方程已给出，在极坐标系下，假设圆心为$(x_0,y_0)$,圆上的点可以表示为:<br>$$x = x_0 + rcos\theta, y = y_0 + rsin\theta$$<br>对于一个圆，假如中心像素点$(x_0,y_0)$，半径r已知，那么旋转360°，圆上的所有点就可以求得。同样，假如圆上的所有点，半径r已知，旋转360°，则会得到一个累加的极值点，那么这个点就是圆心了。</p><hr><p>理论上霍夫变换可以检测任何形状，但复杂的形状需要的参数就多，霍夫空间的维数就多，因此在程序实现上所需的内存空间以及运行效率上都不利于把标准霍夫变换应用于实际复杂图形的检测中。所以一些改进的霍夫变换就相继提出，它们的基本原理就是尽可能减小霍夫空间的维数。</p><p>在OpenCV中，HoughCircles函数实现了圆形检测，它使用的算法也是改进的霍夫变换——2-1霍夫变换（21HT）。也就是把霍夫变换分为两个阶段，从而减小了霍夫空间的维数。第一阶段用于检测圆心，第二阶段从圆心推导出圆半径。<br>检测圆心的原理是圆心是它所在圆周所有法线的交汇处，因此只要找到这个交点，即可确定圆心，该方法所用的霍夫空间与图像空间的性质相同，因此它仅仅是二维空间。检测圆半径的方法是从圆心到圆周上的任意一点的距离（即半径）是相同，只要确定一个阈值，只要相同距离的数量大于该阈值，我们就认为该距离就是该圆心所对应的圆半径，该方法只需要计算半径直方图，不使用霍夫空间。圆和半径知道了，圆自然就能求得。</p><p>21HT的具体步骤:<br>第一阶段：检测圆心</p><p>1.1、对输入图像边缘检测；</p><p>1.2、计算图形的梯度，并确定圆周线，其中圆周的梯度就是它的法线；</p><p>1.3、在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心；</p><p>1.4、在霍夫空间的4邻域内进行非最大值抑制；</p><p>1.5、设定一个阈值，霍夫空间内累加和大于该阈值的点就对应于圆心。</p><p>第二阶段：检测圆半径</p><p>2.1、计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量；</p><p>2.2、设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小；</p><p>2.3、对保留下来的距离进行排序；</p><p>2.4、找到距离相同的那些值，并计算相同值的数量；</p><p>2.5、设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径；</p><p>2.6、对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径。</p><p>HoughCircles函数的原型为：<br><code>void HoughCircles (InputArray image,OutputArray circles, int method, double dp, double minDist,double param1=100, double param2=100, int minRadius=0,int maxRadius=0 )</code><br>image为输入图像，要求是灰度图像<br>circles为输出圆向量，每个向量包括三个浮点型的元素——圆心横坐标，圆心纵坐标和圆半径<br>method为使用霍夫变换圆检测的算法，Opencv2.4.9只实现了2-1霍夫变换，它的参数是CV_HOUGH_GRADIENT<br>dp为第一阶段所使用的霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2时霍夫空间是输入图像空间的一半，以此类推<br>minDist为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认为它们是同一个圆心<br>param1为边缘检测时使用Canny算子的高阈值<br>param2为步骤1.5和步骤2.5中所共有的阈值<br>minRadius和maxRadius为所检测到的圆半径的最小值和最大值</p><h3 id="霍夫变换椭圆检测的实现"><a href="#霍夫变换椭圆检测的实现" class="headerlink" title="霍夫变换椭圆检测的实现"></a>霍夫变换椭圆检测的实现</h3><p>运行环境: vs2017 + Opencv3.4<br>由于HoughCircles函数是调用Canny函数进行边缘检测，OpenCV的Canny函数不包括平滑滤波，所以先对原图进行滤波处理，在这里使用的是高斯模糊</p><pre><code class="line-numbers language-cpp">#include &quot;opencv2/core/core.hpp&quot;#include &quot;opencv2/highgui/highgui.hpp&quot;#include &quot;opencv2/imgproc/imgproc.hpp&quot;#include &lt;iostream&gt;using namespace cv;using namespace std;int main( int argc, char** argv )&#123;     Mat src, gray;    src=imread(&quot;coins.jpg&quot;);    if( !src.data )          return -1;      cvtColor( src, gray, CV_BGR2GRAY );    //高斯模糊平滑    GaussianBlur( gray, gray, Size(9, 9), 2, 2 );    vector&lt;Vec3f&gt; circles;    //霍夫变换    HoughCircles( gray, circles, CV_HOUGH_GRADIENT, 1, gray.rows/20, 100, 60, 0, 0 );    //在原图中画出圆心和圆    for( size_t i = 0; i &lt; circles.size(); i++ )    &#123;        //提取出圆心坐标        Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));        //提取出圆半径        int radius = cvRound(circles[i][2]);        //圆心        circle( src, center, 3, Scalar(0,255,0), -1, 8, 0 );        //圆        circle( src, center, radius, Scalar(0,0,255), 3, 8, 0 );   &#125;    imshow( &quot;霍夫变换检测圆图&quot;, src );    waitKey(0);    return 0;&#125;</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/26/5d3abf54a4c3b88169.jpg"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>霍夫变换</title>
      <link href="/2019/07/26/huo-fu-bian-huan/"/>
      <url>/2019/07/26/huo-fu-bian-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h1><h2 id="介绍与应用场景"><a href="#介绍与应用场景" class="headerlink" title="介绍与应用场景"></a>介绍与应用场景</h2><p><a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2">霍夫变换</a>(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。霍夫变换运用两个坐标空间之间的变换将在一个空间中具有相同形状的曲线或直线映射到另一个坐标空间的一个点上形成峰值，从而把检测任意形状的问题转化为统计峰值问题。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>考虑点$(x_i,y_i)$及通过这个点的线,有无穷多的线通过点$(x_i,y_i)$，针对a和b的一些值，满足斜截式$y_i = ax_i + b$的所有线都通过该点。该公式也可以写为$b = -ax_i + y_i$，考虑ab平面(即<strong>参数空间</strong>)对固定点$(x_i,y_i)$得到一条线的方程。另外，第二个点$(x_j,y_j)$也有一条在参数空间中与之相关的线，这条线和与$(x_i,y_i)$<strong>相关</strong>的线交于点$(a’,b’)$，其中$a’$是斜率，$b’$是在<strong>xy平面</strong>上包含点$(x_i,y_i)$和$(x_j,y_j)$的线的截距。在<strong>参数空间</strong>中，这条线包含的所有点都有相交于$(a’,b’)$点的直线。<br>简单理解，直线由两个点$A(x_1,y_1)$和$B(x_2,y_2)$定义，在参数空间中，两条直线的唯一公共点是在原图像空间中表示连接点A和B的唯一存在的直线<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d38129f0e9f156720.jpg"><br>因此，给定很多点，判断这些点是否共线的问题，经由霍夫变换之后，变成判断一堆曲线(每一个点在$(r, \theta)$平面上代表一条曲线)是否 在 $(r,\theta)$平面上相交于同一点的问题<br>另外用法线表示法:<br>$$xcos\theta + ysin\theta = \rho$$<br>水平线的$\theta$=0,$\rho$等于正的x的截距，垂直线的$\theta=90$度，$\rho$等于正的y的截距<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d382004e2bab23873.jpg"></p><p>在坐标(i, j)的单元位置，累加器的值是 A(i, j)，对应于参数空间坐标$(\rho_i,\theta_j)$的正方形。最初， 这些单元位置为零。然后，对于每个图像平面上的非背景点$(x_k,y_k)$(就是 xy 平面)，我们令 θ 等 于在 θ 轴上允许的细分值，并通过公式$\rho = x_kcos\theta+y_ksin\theta$解出相应的 ρ 值。然后，得到的 ρ 值四 舍五入为最接近的 ρ 轴上允许的单元值。相应的累加器单元增加一个增量。在这个过程的最后， 累加单元 A(i, j)中的值 Q 就意味着 xy 平面上位于线$xcos\theta_j+ysin\theta_j = \rho_i$上的点有 Q 个。在$\rho\theta$平面上，细分的数目决定了这些点的共线的精确度。累加器数组在工具箱中叫做霍夫变换矩阵，简称霍夫变换。</p><h2 id="MATLAB工具箱函数"><a href="#MATLAB工具箱函数" class="headerlink" title="MATLAB工具箱函数"></a>MATLAB工具箱函数</h2><h3 id="hough函数"><a href="#hough函数" class="headerlink" title="hough函数"></a>hough函数</h3><p>默认语法</p><pre><code class="line-numbers language-matlab">[H, theta, rho] = hough(f)</code></pre><p>H是霍夫变换矩阵，theta和rho是$\theta$和$\rho$的值<br>下面这个例子可以加深对霍夫变换的理解</p><pre><code class="line-numbers language-matlab">f = zeros(101,101);f(1,1) = 1;f(101,1) = 1;f(1,101) = 1;f(101, 101) = 1;f(51, 51) = 1;% H = hough(f);[H, theta, rho] = hough(f);imshow(H, [],&#39;XData&#39;, theta,&#39;YData&#39;, rho, &#39;InitialMagnification&#39;, &#39;fit&#39;)axis on, axis normalxlabel(&#39;\theta&#39;),ylabel(&#39;\rho&#39;)</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d381e6cd3ce994397.jpg"><br>观察图可以看打到三条曲线在+45度和-45度处的交点指出:f中有两组三个共线的点。两条曲线在$(\rho,\theta)$ = (0,-90)、(-100,-90)、(0,0)、(100,0)处的交点指出:有4组位于<strong>垂直线</strong>和<strong>水平线</strong>上的公共点</p><h3 id="houghpeaks函数"><a href="#houghpeaks函数" class="headerlink" title="houghpeaks函数"></a>houghpeaks函数</h3><p>寻找指定的峰值数<br>默认语法</p><pre><code class="line-numbers language-matlab">peaks = houghpeaks(H, NumPeaks)</code></pre><p>H是霍夫变换矩阵</p><h3 id="houghlines函数"><a href="#houghlines函数" class="headerlink" title="houghlines函数"></a>houghlines函数</h3><p>决定线的起点和终点<br>默认语法</p><pre><code class="line-numbers language-matlab">lines = houghlines(f, theta, rho, peaks)</code></pre><p>输出lines是结构数组，长度等于找到的线段。结构中的每个元素可以看成一条线，并含有下列字段:    </p><ol><li>point1:两元素向量[r1,c1]，指定了线段终点的行列坐标。</li><li>point2:两元素向量[r2,c2]，指定了线段其他终点的行列坐标。</li><li>theta:与线相关的霍夫变换的以度计量的角度。</li><li>rho:与线相关的霍夫变换的$\rho$轴位置。</li></ol><h3 id="MATLAB使用霍夫变换检测和连接线"><a href="#MATLAB使用霍夫变换检测和连接线" class="headerlink" title="MATLAB使用霍夫变换检测和连接线"></a>MATLAB使用霍夫变换检测和连接线</h3><pre><code class="line-numbers language-matlab">f = imread(&#39;timg1.jpg&#39;);f = rgb2gray(f);BW = edge(f,&#39;canny&#39;);[H ,theta, rho] = hough(BW, &#39;ThetaResolution&#39;, 0.2);imshow(H, [],&#39;XData&#39;, theta,&#39;YData&#39;, rho, &#39;InitialMagnification&#39;, &#39;fit&#39;)axis on, axis normalxlabel(&#39;\theta&#39;),ylabel(&#39;\rho&#39;)peaks = houghpeaks(H, 5);hold onplot(theta(peaks( :, 2)), rho(peaks(:, 1)),...    &#39;linestyle&#39;, &#39;none&#39;, &#39;marker&#39;, &#39;s&#39;, &#39;color&#39;, &#39;w&#39;);lines = houghlines(f, theta, rho, peaks);figure, imshow(f), hold onfor k = 1:length(lines)    xy = [lines(k).point1 ; lines(k).point2];    plot(xy(:,1), xy(:,2), &#39;LineWidth&#39;, 4, &#39;color&#39;, &#39;red&#39;);end</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d381d8d80bff63571.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d381de2778c421022.jpg"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV入坑指南:环境搭建篇</title>
      <link href="/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/"/>
      <url>/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h2 id="什么是OpenCV"><a href="#什么是OpenCV" class="headerlink" title="什么是OpenCV"></a>什么是OpenCV</h2><p><a href="https://opencv.org/about/">OpenCv</a>是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。<br>OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。该库也有大量的Python、Java and MATLAB/OCTAVE（版本2.5）的接口。这些语言的API接口函数可以通过在线文档获得。如今也提供对于C#、Ch、Ruby,GO的支持。</p><h2 id="OpenCV可以来做什么"><a href="#OpenCV可以来做什么" class="headerlink" title="OpenCV可以来做什么"></a>OpenCV可以来做什么</h2><p>使用OpenCV，你几乎可以做任何你能够想到的计算机视觉任务。    </p><ol><li><p>内置数据结构和输入/输出(In-build data structures and input/output)</p></li><li><p>图像处理操作(Image processing operations)</p></li><li><p>构建图形用户界面(Build GUI)</p></li><li><p>视频分析(Video analysis)</p></li><li><p>3D重建(3D reconstruction)</p></li><li><p>特征提取(Feature extraction)</p></li><li><p>目标检测(Object detection)</p></li><li><p>机器学习(Machine learning)</p></li><li><p>计算摄影(Computational photography)</p></li><li><p>形状分析(Shape analysis)</p></li><li><p>光流算法(Optical flow algorithms)</p></li><li><p>人脸和目标识别(Face and object recognition)</p></li><li><p>表面匹配(Surface matching)</p></li><li><p>文本检测和识别(Text detection and recognition)</p></li></ol><hr><h1 id="Microsoft-Visual-Studio"><a href="#Microsoft-Visual-Studio" class="headerlink" title="Microsoft Visual Studio"></a>Microsoft Visual Studio</h1><p>宇宙最强IDE(逃),不多说了</p><hr><h1 id="OpenCV-VS学习-装×-环境搭建"><a href="#OpenCV-VS学习-装×-环境搭建" class="headerlink" title="OpenCV + VS学习(装×)环境搭建"></a>OpenCV + VS学习(装×)环境搭建</h1><p>工欲善其事，必先利其器。当你准备好入坑OpenCV时，你首先要把学习环境搭建起来，光是这一关不知道劝退了多少人，我在搭建的过程中也是踩了很多坑，也遇到了各种各样刁钻的问题，现在总结一下，给自己踩过的雷做一下记录，也希望能够帮到即将入坑的你们。</p><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>为什么把这个放到第一个呢？因为这是我遇到并纠结了一天的问题！我在网上查找教程的时候很多人都没有标注这个问题，当然也是自己蠢，在所有的配置都配置完成之后，还是不能正常跑程序，又重新安装重新配置，反复好几次，都快怀疑人生了，最后才发现是版本号不对。废话不多说，下面是OpenCV版本和VS版本的对应表，选择的时候一定要擦亮眼睛。我选择的环境是VS2017+OpenCV3.4.4    </p><table><thead><tr><th align="center">Visual Studio 版本</th><th align="center">VC 版本</th></tr></thead><tbody><tr><td align="center">VS 6</td><td align="center">vc6</td></tr><tr><td align="center">VS 2003</td><td align="center">vc7</td></tr><tr><td align="center">VS 2005</td><td align="center">vc8</td></tr><tr><td align="center">VS 2008</td><td align="center">vc9</td></tr><tr><td align="center">VS 2010</td><td align="center">vc10</td></tr><tr><td align="center">VS 2013</td><td align="center">vc12</td></tr><tr><td align="center">VS 2015</td><td align="center">vc14</td></tr><tr><td align="center">VS 2017</td><td align="center">vc15</td></tr></tbody></table><p>OpenCV对VC版本的支持情况(不全)</p><table><thead><tr><th align="center">OpenCV 2.4.10</th><th align="center">vc10、vc11、vc12</th></tr></thead><tbody><tr><td align="center">OpenCV 2.4.13</td><td align="center">vc11、vc12</td></tr><tr><td align="center">OpenCV 3.4.0</td><td align="center">vc14、vc15</td></tr><tr><td align="center">OpenCv 3.4.1</td><td align="center">vc14、vc15</td></tr></tbody></table><h2 id="VS2017安装"><a href="#VS2017安装" class="headerlink" title="VS2017安装"></a>VS2017安装</h2><p>我的VS安装的时间太久了，网上教程一大堆，给你们挑一篇吧，这里就不再多说了</p><h2 id="OpenCV3-4-4下载与安装"><a href="#OpenCV3-4-4下载与安装" class="headerlink" title="OpenCV3.4.4下载与安装"></a>OpenCV3.4.4下载与安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li>官网下载<br>OpenCV官网给我们提供了下载，不过下载速度嘛～自求多福<br><a href="https://opencv.org/releases/">OpenCV下载</a>,里面有各个版本可以选择</li><li>OpenCV下载驿站<br><a href="https://blog.csdn.net/oMoDao1/article/details/80276834">OpenCV各版本汇总下载</a><br>感谢这位大哥的总结</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>找一个你能记住名字的路径安装进去就OK了，一定要记住这个路径，非常重要<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0f7a6db16095.png"></p><h2 id="系统环境变量配置"><a href="#系统环境变量配置" class="headerlink" title="系统环境变量配置"></a>系统环境变量配置</h2><ol><li>找到此电脑</li><li>依次找到 属性-&gt;高级-&gt;环境变量,找到系统变量里的Path，双击进去编辑，如图所示，添加的路径 <strong>“D:\OpenCV\opencv\bulid\x64\vc15\bin”</strong>,把”D:\OpenCV&quot;替换成你的安装路径即可</li></ol><p><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0f9cd5286868.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0fa09f948672.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0fa634780591.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c0e0fa37ce25025.png"></p><p>到这就完成了系统环境的配置了</p><h2 id="一些文件的配置"><a href="#一些文件的配置" class="headerlink" title="一些文件的配置"></a>一些文件的配置</h2><p>这一步的目的是为了解决以后可能会出现的关于缺少.dll的问题</p><p>将 <strong>“D:\OpenCV\opencv\bulid\x64\vc15\bin”</strong> 里面的三个 <strong>.dll</strong> 文件复制到 <strong>C:\Windows“</strong> 目录下的 <strong>System32</strong>和 <strong>SysWOW64</strong>目录下</p><p><img loading="lazy" src="https://i.loli.net/2019/07/28/5d3d5857adbe920715.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/28/5d3d5857bd82f79652.png"></p><h2 id="VS2017配置"><a href="#VS2017配置" class="headerlink" title="VS2017配置"></a>VS2017配置</h2><ol><li>新建一个空项目</li><li>进入属性管理器  视图-&gt;其他窗口-&gt;属性管理器<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f6359d16629.png"></li><li>选择Debug | x64 的 Microsoft.Cpp.x64.user<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156ecb8ad31557.png" alt="8.png"></li><li>选择VC++目录，对包含目录和库目录进行配置<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f2e22b74192.png"><ul><li>在包含目录里添加 <strong>D:\OpenCV\opencv\bulid\include</strong>,<strong>D:\OpenCV\opencv\bulid\include\opencv</strong>,<strong>D:\OpenCV\opencv\bulid\include\opencv2</strong><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f2132f35424.png"></li><li>在库目录里添加 <strong>D:\OpenCV\opencv\bulid\x64\vc15\lib</strong><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f492f430904.png"></li></ul></li><li>选择 链接器-&gt;输入-&gt;附加依赖项,<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f13aac74119.png" alt="12.png"><br>在里面添加 <strong>opencv_world344d.lib</strong>，这个lib文件根据你的OpenCV版本号灵活变动<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f0828190561.png"></li><li>点击应用，确定即可<br>到这里，OpenCV的所有配置工作已经完成了，要注意的是解决方案那一栏要换成x64(因为我们一直在配置的就是x64)<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156ee8b6668598.png"><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>这是一段读取并显示本地图片的代码，测试一下你的OpenCV环境是否配置好</li></ol><pre><code class="line-numbers language-cpp">#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;using namespace cv;int main()&#123;    Mat img = imread(&quot;1.bmp&quot;);    namedWindow(&quot;图片&quot;);    imshow(&quot;图片&quot;, img);    waitKey(6000);    return 0;&#125;</code></pre><p>运行结果如下：<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c15857414f57549.png"></p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><ol><li>导入包的时候不报错，但运行程序时出现一下错误<br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f55e6b74341.png" alt="15.png"><br><img loading="lazy" src="https://i.loli.net/2019/07/27/5d3c156f39a4e29681.png" alt="16.png"><br>出现这个问题，目前已知的有两个原因    <ul><li>imread函数读不到图片，即你的图片路径写的有问题<br>这里给出两种基本的路径书写形式    <ol><li>绝对路径<br>Mat img = imread(“D:\Pictures\1.bmp”);<br>一定要注意这里是双斜杠</li><li>图片路径<br>Mat img = imread(“1.bmp”);<br>使用这个的前提是图片的位置在你的工程目录下</li></ol></li><li>链接器的附加依赖项配置的有问题<br>在Debug模式下，附加依赖项添加的是 <strong>opencv_world344d.lib</strong><br>在Release模式下，附加依赖项添加的是 <strong>opencv_world344.lib</strong><br>有些教程是两个都添加，这是不对的，一定要注意。</li></ul></li></ol><hr><h1 id="MacOS-安装opencv-python"><a href="#MacOS-安装opencv-python" class="headerlink" title="MacOS 安装opencv-python"></a>MacOS 安装opencv-python</h1><h3 id="1-首先安装xcode"><a href="#1-首先安装xcode" class="headerlink" title="1. 首先安装xcode"></a>1. 首先安装xcode</h3><pre><code class="line-numbers language-bash">xcode-select --install </code></pre><h3 id="2-安装opencv-python"><a href="#2-安装opencv-python" class="headerlink" title="2. 安装opencv-python"></a>2. 安装opencv-python</h3><pre><code class="line-numbers language-bash">pip install opencv-python</code></pre><p>这默认将安装<code>opencv-python 4.2</code>, 但在 <strong>catalina</strong> 貌似不可用</p><p>所以我选择了安装低版本的opencv-python</p><pre><code class="line-numbers language-bash">pip install opencv-python==4.1.2.30</code></pre><p>或者选择安装</p><pre><code class="line-numbers language-bash">pip install opencv-python-headless</code></pre><p>这个原因未知</p><p>好了，教程到此结束，<br>接下来你就可以放心地去玩耍了，Enjoy Your OpenCV!</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/10/face-recognition-with-opencv/">Face Recognition</a></li><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/03/face-detection/">Face Detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割</title>
      <link href="/2019/07/24/tu-xiang-fen-ge/"/>
      <url>/2019/07/24/tu-xiang-fen-ge/</url>
      
        <content type="html"><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><hr><blockquote><p>整体等于部分之和<br>                —–欧几里德</p></blockquote><hr><p>图像分割把图像细分为它的组成要素或物体，细分的水平取决于要解决的问题。<br>单色分割的分割算法通常是基于图像亮度值的两个基本特征:不连续性和相似性。第一类，方法是基于亮度的突变来分割一幅图像，比如边缘;第二类，主要方法是根据事先定义好的准则把图像分割成相似的区域</p><h2 id="点、线和基本边缘检测"><a href="#点、线和基本边缘检测" class="headerlink" title="点、线和基本边缘检测"></a>点、线和基本边缘检测</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol><li>边缘像素是图像中灰度突变的像素，边缘是连接的边缘像素的集合</li><li>一条线可以视为一条边缘线段，该线段两侧的背景灰度要么远亮于该线像素的灰度，要么远暗于该线像素的灰度。孤立点可视为一条线，只是长度和宽度都是一个像素</li><li>局部变化检测可以用微分(一阶微分和二阶微分)    <ul><li>对于一阶导数的任何近似，约定:<ul><li>在恒定灰度区域必须为0</li><li>在灰度台阶和或斜坡开始处必须不为0</li><li>在沿灰度斜坡点处也必须不为0</li></ul></li><li>类似的对于二阶导数的近似<ul><li>在恒定灰度区域必须为0</li><li>在灰度台阶或斜坡开始除和结束处必须不为0</li><li>沿灰度斜坡必须为0</li></ul></li><li>一维函数展开为关于x的泰勒级数,结果差分<br>$$ \frac{\partial f}{\partial x}=f’(x)=f(x+1)-f(x)$$<br>二阶导数<br>$$ \frac{\partial ^2 f}{\partial ^2 x}=f’’(x)=f(x+1)+f(x-1)-2f(x)$$<ul><li>可以得出结论:<ul><li>一阶导数通常在图像中产生较粗的边缘</li><li>二阶导数对精细细节，如细线、孤立点和噪声有较强的响应</li><li>二阶导数在灰度斜坡和灰度台阶过渡处会产生双边缘响应</li><li>二阶导数的符号可用于确定边缘的过程是从亮到暗还是从暗到亮</li></ul></li><li>计算图像中每个像素位置的一阶导数和二阶导数的可选择方法是空间滤波器。模板在该区域中心点处的响应为<br>$$R = w_1z_1 + w_2z_2 + … + w_9z_9 = \sum_{k=1}^{9}w_kz_k$$</li></ul></li></ul></li></ol><table><thead><tr><th align="center">$w_1$</th><th align="center">$w_2$</th><th align="center">$w_3$</th></tr></thead><tbody><tr><td align="center">$w_4$</td><td align="center">$w_5$</td><td align="center">$w_6$</td></tr><tr><td align="center">$w_7$</td><td align="center">$w_8$</td><td align="center">$w_9$</td></tr></tbody></table><p>这是一个普通的3×3空间滤波器掩模</p><h3 id="孤立点检测"><a href="#孤立点检测" class="headerlink" title="孤立点检测"></a>孤立点检测</h3><ul><li>点的检测应以二阶导数为基础，这意味着使用laplace<br>$$\triangledown ^2f(x,y) = \frac{\partial ^2 f}{\partial x^2} + \frac{\partial ^2 f}{\partial y^2}$$<br>偏微分之后可求得laplace为<br>$$\triangledown ^2f(x,y) = f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$<br>点检测laplace模板</li></ul><table><thead><tr><th align="center">1</th><th align="center">1</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-8</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>如果在某点处的该模板的响应的绝对值超过了一个指定的阈值，那么就说在模板中心位置(x,y)处的该点已经被检测到。在输出图像中，这样的点被标注为1,所有其他点被标注为0<br>$$g(x,y)=\begin{cases}<br>1,\quad |R(x,y)| \geqq T\<br>0, \quad 其他<br>\end{cases}<br>$$</p><ul><li>MATLAB实现</li></ul><pre><code class="line-numbers language-matlab">f = imread(&#39;moon.jpg&#39;);f = rgb2gray(f);w = [-1 -1 -1; -1 8 -1; -1 -1 -1];g = abs(imfilter(f, w));T = max(g(:));g = g &gt;= T;figure(1);subplot(1,2,1)imshow(f)subplot(1,2,2)imshow(g)</code></pre><p>结果：<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37b3a82234833730.jpg"></p><h3 id="线检测"><a href="#线检测" class="headerlink" title="线检测"></a>线检测</h3><p>可以预期，二阶导数将导致更强的响应，并产生比一阶导数更细的线</p><p>线检测模板</p><ul><li>水平</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">-1</td><td align="center">-1</td><td align="center">-1</td></tr></tbody></table><ul><li>+45度</li></ul><table><thead><tr><th align="center">2 -</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">-1</td><td align="center">-1</td><td align="center">2</td></tr></tbody></table><ul><li>垂直</li></ul><table><thead><tr><th align="center">-1</th><th align="center">2</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr></tbody></table><ul><li>-45度</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">2</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">2</td><td align="center">-1</td><td align="center">-1</td></tr></tbody></table><p>对于恒定的背景，当线通过模板的中间一行时可能产生更大的响应。<br>每个模板的系数之和为0,这表示在恒定亮度区域内，模板的响应为0.</p><ul><li>MATLAB实现检测指定方向上的线</li></ul><pre><code class="line-numbers language-matlab">clcclearf = imread(&#39;11111.jpg&#39;);f = rgb2gray(f);figure(1);subplot(2,3,1)imshow(f);w = [-1, 2, -1; -1 2 -1; -1 2 -1];% g = imfilter(tofloat(f),w);g = imfilter(f,w);subplot(2,3,2)imshow(g, [ ]);gtop = g(1:120, 1:120);% gtop = pixeldup(gtop, 4);subplot(2,3,3)imshow(gtop, [ ]);gbot = g(end - 119:end, end - 119:end);% gbot = pixeldup(gbot, 4);subplot(2,3,4)imshow(gbot, [ ]);g = abs(g);subplot(2,3,5)imshow(g, [])T = max(g(:));g = g &gt;= T;subplot(2,3,6);imshow(g)</code></pre><p>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37b3a815b7125153.jpg"><br>可能会用到的M函数pixeldup</p><pre><code class="line-numbers language-matlab">function B=pixeldup(A,m,n)%pixeldup用来重复像素的，在水平方向复制m倍，在垂直方向复制n倍，m，n必须为整数，n没有赋值默认为m%检查输入参数个数if nargin&lt;2    error(&#39;At least two inputs are required.&#39;);    endif nargin==2    n=m;    endu=1:size(A,1);%产生一个向量，其向量中元素的个数为A的行数%复制向量中每个元素m次m=round(m);%防止m为非整数u=u(ones(1,m),:);u=u(:);%在垂直方向重复操作v=1:size(A,2);n=round(n);v=v(ones(1,n),:);v=v(:);B=A(u,v);</code></pre><p><strong>慎用tofloat函数</strong></p><h3 id="基本边缘检测"><a href="#基本边缘检测" class="headerlink" title="基本边缘检测"></a>基本边缘检测</h3><h4 id="边缘模型"><a href="#边缘模型" class="headerlink" title="边缘模型"></a>边缘模型</h4><ul><li>台阶模型<br>在一个像素的距离上发生两次灰度级间理想的过渡</li><li>斜坡模型<br>数字图像存在被模糊或有噪声的边缘，这时的边缘被建模成一个更接近灰度斜坡的剖面，斜坡的斜度与边缘的模糊程度成反比</li><li>屋顶模型<br>通过一个区域的线的模型，屋顶边缘的基底(宽度)由该线的宽度和尖锐度决定<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d382004cd3e437707.jpg"></li></ul><p>结合前面提到的一阶导数和二阶导数的性质，可以得出结论:</p><ol><li>一阶导数的幅值可用于检测图像中的某个点处是否存在一个边缘</li><li>二阶导数的符号可用于确定一个边缘像素位于该边缘的暗的一侧还是亮的一侧</li><li>对图像的每个边缘，二阶导数生成两个值</li><li>二阶导数的零交叉点可用于定位粗边缘的中心</li></ol><ul><li>执行边缘检测的三个步骤:    <ol><li>为降噪对图像进行平滑处理</li><li>边缘点的检测</li><li>边缘定位</li></ol></li></ul><h4 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h4><h5 id="梯度概念"><a href="#梯度概念" class="headerlink" title="梯度概念"></a>梯度概念</h5><p>梯度是一个可以确定图像f的(x,y)位置处的边缘方向和强度的工具，用 $\triangledown f$来表示，用 <strong>向量</strong>来定义</p><p>$$\triangledown f = \begin{bmatrix} g_x \ g_y \ \end{bmatrix} = \begin{bmatrix} \frac{\partial f}{\partial x} \ \frac{\partial f}{\partial x} \end{bmatrix}$$</p><h5 id="梯度性质"><a href="#梯度性质" class="headerlink" title="梯度性质"></a>梯度性质</h5><ol><li><p>梯度向量大小。<br>$\triangledown f$的大小为M(x,y)<br>$$\triangledown f = mag(\triangledown f)=[g_x^2+g_y^2]^{<br>1/2}= [(\partial f/\partial x)^2+(\partial f/\partial y)^2]^{1/2}$$<br>这是梯度向量方向变化率的值。其中$g_x$,$g_y$和M(x,y)都是和原图像大小相同的图像。称M(x,y)为梯度图像。</p></li><li><p>梯度向量的方向<br>$$\alpha (x,y) = tan^{-1}(\frac{g_x}{g_y})$$<br>同理，　$\alpha(x,y)$也是由$g_x$和$g_y$阵列创建的尺寸相同的图像。<br>任意点(x,y)处的一个边缘的方向与该点处梯度向量的方向$\alpha(x,y)$正交。<br>梯度向量有时也称为边缘法线</p></li><li><p>梯度指出f在(x,y)处的最大变化率的方向</p></li></ol><h5 id="梯度算子"><a href="#梯度算子" class="headerlink" title="梯度算子"></a>梯度算子</h5><h6 id="一维模板"><a href="#一维模板" class="headerlink" title="一维模板"></a>一维模板</h6><p>$$g_x = \frac{\partial f(x,y)}{\partial x} = f(x+1,y) - f(x,y)$$<br>和<br>$$g_y = \frac{\partial f(x,y)}{\partial y} = f(x,y+1)-f(x,y)$$</p><h6 id="二维模板"><a href="#二维模板" class="headerlink" title="二维模板"></a>二维模板</h6><p>罗伯特交叉梯度算子(Roberts),ROberts算子以求对角像素之差为基础:<br>$$g_x = \frac{\partial f}{\partial x} = (z_9 - z_5)$$<br>和<br>$$g_y = \frac{\partial f}{\partial y} = (z_8 - z_6)$$</p><h6 id="3×3模板"><a href="#3×3模板" class="headerlink" title="3×3模板"></a>3×3模板</h6><ol><li><p>Prewitt算子<br>$$g_x = (z_7 + z_8 + z_9)-(z_1 + z_2 + z_3)$$<br>和<br>$$g_y = (z_3 + z_6 + z_9) - (z_1 + z_4 + z_7)$$</p></li><li><p>Sobel算子</p></li></ol><p>$$g_x = (z_7 + 2z_8 + z_9)-(z_1 +2 z_2 + z_3)$$<br>和<br>$$g_y = (z_3 + 2z_6 + z_9) - (z_1 +2 z_4 + z_7)$$</p><p>在中心位置处使用2可以平滑图像</p><p>注意:所有模板中的系数之和为0，这意味着恒定灰度的响应为0.</p><h4 id="使用函数edge的边缘检测"><a href="#使用函数edge的边缘检测" class="headerlink" title="使用函数edge的边缘检测"></a>使用函数edge的边缘检测</h4><ul><li>语法</li></ul><pre><code class="line-numbers language-matlab">[g,t] = edge(f, &#39;method&#39;, parameters);</code></pre><p>f是输入图像，method是边缘检测方法，parameters是附加参数</p><h4 id="边缘检测算子"><a href="#边缘检测算子" class="headerlink" title="边缘检测算子"></a>边缘检测算子</h4><p>图像邻域如下图所示:</p><table><thead><tr><th align="center">$z_1$</th><th align="center">$z_2$</th><th align="center">$z_3$</th></tr></thead><tbody><tr><td align="center">$z_4$</td><td align="center">$z_5$</td><td align="center">$z_6$</td></tr><tr><td align="center">$z_7$</td><td align="center">$z_8$</td><td align="center">$z_9$</td></tr></tbody></table><h5 id="Sobel边缘检测算子"><a href="#Sobel边缘检测算子" class="headerlink" title="Sobel边缘检测算子"></a>Sobel边缘检测算子</h5><ul><li>Sobel边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-2</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><p>$$g_x=(z_7+2z_8+z_9)-(z_1+2z_2+z_3)$$</p><table><thead><tr><th align="center">-1</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">-2</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_y = (z_3+2z_6+z_9)-(z_1+2z_4+z_7)$$<br>每一行和每一列的中心像素用2来加权以提供平滑</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;sobel&#39;, T, dir);</code></pre><p>f是输入的图像，T是指定的阀值，dir是指定的检测边缘的首选方向:’horizontal’,’vertical’,’both’(默认值)<br>t是可选的，T未指定，则t自动设置</p><h5 id="Prewitt边缘检测算子"><a href="#Prewitt边缘检测算子" class="headerlink" title="Prewitt边缘检测算子"></a>Prewitt边缘检测算子</h5><ul><li>Prewitt边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>$$g_x = (z_7 + z_8 + z_9)-(z_1 + z_2 + z_3)$$</p><table><thead><tr><th align="center">-1</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_y = (z_3 + z_6 + z_9) - (z_1 + z_4 + z_7)$$</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;prewitt&#39;, T ,dir);</code></pre><p>计算简单，但容易产生噪声</p><h5 id="Roberts边缘检测算子"><a href="#Roberts边缘检测算子" class="headerlink" title="Roberts边缘检测算子"></a>Roberts边缘检测算子</h5><ul><li>Roberts边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_x = z_9 - z_5$$</p><table><thead><tr><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>$$g_y = z_8 - z_6$$</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;roberts&#39;, T , dir);</code></pre><h5 id="LoG检测算子"><a href="#LoG检测算子" class="headerlink" title="LoG检测算子"></a>LoG检测算子</h5><ul><li>LoG</li></ul><p>考虑高斯函数<br>$$G(x,y) = e^{-\frac{x^2 + y^2}{2\sigma ^2}}$$<br>$\sigma$是标准差。这是平滑函数，如果和图像卷积，会使图像变模糊，模糊程度由$\sigma$决定<br>这个函数的Laplace算法是:<br>$$\triangledown^2G(x,y) = \frac{\partial ^2 G(x,y)}{\partial x^2}+\frac{\partial ^2 G(x,y)}{\partial y^2} = [\frac{x^2 + y^2-2\sigma ^2}{\sigma ^4}]^{e^{-\frac{x^2 + y^2}{2\sigma ^2}}}$$</p><p>用$\triangledown ^2G(x,y)$卷积(滤波)这幅图像与先用平滑函数对图像卷积，再对结果进行Laplace变换的结果是一样的<br>用$\triangledown ^2G(x,y)$卷积图像，可以得到两个效果:平滑图像(因而减少了噪声);计算Laplace，从而产生双边缘图像，然后在双边缘之间定位由发现的零交叉组成的边缘</p><ul><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;log&#39;, T , sigma);</code></pre><p>sigma默认值是2</p><h5 id="零交叉检测算子"><a href="#零交叉检测算子" class="headerlink" title="零交叉检测算子"></a>零交叉检测算子</h5><ul><li>基于LoG，卷积使用特殊的滤波函数H来完成</li><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;zerocross&#39;, T , H);</code></pre><h5 id="Canny检测算子"><a href="#Canny检测算子" class="headerlink" title="Canny检测算子"></a>Canny检测算子</h5><ul><li>edge函数中最强的边缘检测算子</li><li>MATLAB语法</li></ul><pre><code class="line-numbers language-matlab">[g, t] = edge(f, &#39;canny&#39;, T , sigma);</code></pre><h4 id="MATLAB实现"><a href="#MATLAB实现" class="headerlink" title="MATLAB实现"></a>MATLAB实现</h4><ul><li>几种边缘检测算法的比较(Sobel,LoG,Canny)</li></ul><pre><code class="line-numbers language-matlab">f = imread(&#39;timg1.jpg&#39;); imshow(f),title(&#39;currect image&#39;);f = rgb2gray(f);%Default Output[gSobel_default,ts] = edge(f, &#39;sobel&#39;);[gLoG_default, tlog] = edge(f, &#39;log&#39;);[gCanny_default, tc] = edge(f,&#39;canny&#39;);%Best OutputgSobel_best = edge(f,&#39;sobel&#39;,0.165);gLoG_best = edge(f,&#39;log&#39;,0.008, 2.25);gCanny_best = edge(f,&#39;canny&#39;,[0.05, 0.4], 1.5);figure,imshow(f),title(&#39;Gary images&#39;);figure,imshow(gSobel_default),title(&#39;gSobel default&#39;);figure,imshow(gSobel_best),title(&#39;gSobel best&#39;);figure,imshow(gLoG_default),title(&#39;gLoG default&#39;);figure,imshow(gLoG_best),title(&#39;gLoG best&#39;);figure,imshow(gCanny_default),title(&#39;gCanny default&#39;);figure,imshow(gCanny_best),title(&#39;gCanny best&#39;);</code></pre><p>其中最佳输出的阀值是根据得到的ts,tlog,tc的值来确定的<br>结果:<br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b4bec1777947.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b5886d994031.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b3ad9b270352.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b573bae72055.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b61724d14715.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b51df2874618.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b65663011930.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/24/5d37d6b3e566366232.jpg"><br>综合结果来看，Canny边缘检测算子可以得到最好的结果</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo大坑</title>
      <link href="/2019/07/22/hexo-da-keng/"/>
      <url>/2019/07/22/hexo-da-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="坑一、Template-render-error-模板渲染错误"><a href="#坑一、Template-render-error-模板渲染错误" class="headerlink" title="坑一、Template render error 模板渲染错误"></a>坑一、Template render error 模板渲染错误</h2><p>写了一下午博文，高高兴兴地hexo g却发现报错了！<br><code>INFO  Start processing FATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html Nunjucks Error:  [Line 2, Column 6] unexpected token: &#125;&#125;  at formatNunjucksError (/home/kevin/blog/node_modules/hexo/lib/extend/tag.js:102:13)     at Promise.fromCallback.catch.err (/home/kevin/blog/node_modules/hexo/lib/extend/tag.js:124:34)     at tryCatcher (/home/kevin/blog/node_modules/bluebird/js/release/util.js:16:23)     at Promise._settlePromiseFromHandler (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:517:31)     at Promise._settlePromise (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:574:18)     at Promise._settlePromise0 (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:619:10)     at Promise._settlePromises (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:695:18)     at _drainQueueStep (/home/kevin/blog/node_modules/bluebird/js/release/async.js:138:12)     at _drainQueue (/home/kevin/blog/node_modules/bluebird/js/release/async.js:131:9)     at Async._drainQueues (/home/kevin/blog/node_modules/bluebird/js/release/async.js:147:5)     at Immediate.Async.drainQueues [as _onImmediate] (/home/kevin/blog/node_modules/bluebird/js/release/async.js:17:14)     at processImmediate (internal/timers.js:443:21)</code></p><p>原因是nunjucks模板标签导致MD文件解析报错的问题，我试验了一下，在md文档中出现<code>双大括号</code>,<code>左大括号+#</code>,<code>左大括号+%</code>等都会报错(原谅我这么打，因为我打出来符号的话这篇博客就发不出来了)，下面是一位大神的<a href="http://xcoding.tech/2018/08/08/hexo/%E5%A6%82%E4%BD%95%E4%BB%8E%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3hexo%E4%B8%8D%E5%85%BC%E5%AE%B9%7B%7B%7D%7D%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/">解决办法</a>，他提供了几种解决办法，讲的很详细，可以参考一下</p><p>我觉得有点麻烦就没采用(说多了就是菜～),下面是我的办法:</p><ol><li>既然出现上面的内容就会报错，那就尽量避免出现呗…(说的都是废话)</li><li>使用<code>\lbrace</code>代替<code>\&#123;</code>,使用<code>\rbrace</code>代替<code>\&#125;</code><br>推荐大神的解决办法，一劳永逸，以后就不用管了</li></ol><h2 id="坑二、Markdown的空行"><a href="#坑二、Markdown的空行" class="headerlink" title="坑二、Markdown的空行"></a>坑二、Markdown的空行</h2><p>在写表格的时候要把表格体前后各空一行，不然你写的表格是这样式儿的，崩溃啊！<br><img loading="lazy" src="https://cdn.jsdelivr.net/gh/liuyaanng/Blog_source@master/blog_images/hexo%E5%A4%A7%E5%9D%91/1.png"></p><p>有可能是hexo解析的问题，我在使用markdown-preview的时候看的是正常的</p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2020/09/18/mo-gai-hexo-bo-ke/">魔改hexo博客</a></li><li><a href="https://godliuyang.wang/2020/09/15/cdn-for-blog/">CDN_for_blog</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形态学图像处理</title>
      <link href="/2019/07/22/xing-tai-xue-tu-xiang-chu-li/"/>
      <url>/2019/07/22/xing-tai-xue-tu-xiang-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="形态学图像处理"><a href="#形态学图像处理" class="headerlink" title="形态学图像处理"></a>形态学图像处理</h1><p>从这里开始过渡，从输入输出都是图像，过渡到图像分析方法，输出以某种方法来描述图像的内容。</p><h2 id="集合理论基础"><a href="#集合理论基础" class="headerlink" title="集合理论基础"></a>集合理论基础</h2><p>令Z为整数集合，用于产生的数字图像的抽样处理可以看做是把xy平面分割成网格状，其中每个网格的<strong>中心坐标</strong>是来自笛卡尔积$Z^2$中的一对元素。在集合理论中，如果(x,y)是来自$Z^2$的整数,f是分配给每个不同坐标的对(x,y)的亮度值的映射，那么函数f(x,y)被成为数字图像。如果亮度值也为整数，那么这幅图像就变成了二维图像。<br>集合的基本操作:$\in$,$\notin$,$\cup$,$\cap$,+,-.除了这些基本操作，形态学操作还需要两个算子，他们特别针对元素均为像素坐标的集合</p><ol><li>集合的反射$\hat{B}$<br>$$ \hat{B} = {w|w=-b,b\in B}$$</li><li>点z=($z_1$,$z_2$)集合的平移${(A)}_z$<br>$$ (A)_z = {c|c=a+z,a\in A}$$<h3 id="二值图像、集合及逻辑算子"><a href="#二值图像、集合及逻辑算子" class="headerlink" title="二值图像、集合及逻辑算子"></a>二值图像、集合及逻辑算子</h3>形态学理论把二值图像看成是前景(1值)像素的集合,集合的元素属于$Z^2$如果A和B都是二值图像，那么$C=A\cup B$也是二值图像<br>$$C(x,y)=\begin{cases}<br>1,\quad A(x,y)或B(x,y)为1,或者两者均为1\<br>0 \quad 其他<br>\end{cases}<br>$$<h3 id="在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算"><a href="#在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算" class="headerlink" title="在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算"></a>在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算</h3></li></ol><table><thead><tr><th>集合运算</th><th align="center">二值图像的MATLAb语句</th><th>名称</th></tr></thead><tbody><tr><td>$A\cap B$</td><td align="center">A &amp; B</td><td>与</td></tr><tr><td>$A\cup B$</td><td align="center">A $\rvert$ B</td><td>或</td></tr><tr><td>$A^c$</td><td align="center">~B</td><td>非</td></tr><tr><td>$A-B$</td><td align="center">A &amp;~ B</td><td>差</td></tr></tbody></table><h2 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h2><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀是使图像中的目标”生长”或”变粗”的操作。程度由一种被称为<strong>结构元</strong>的形状来控制<br>A被B膨胀，表示为$A \oplus B$,作为集合操作<br>$$ A\oplus B={ z|\hat{B}_z\cap A\not= \emptyset}$$<br>约定: $A \oplus B$ 的第一个操作数是图像，第二个操作数是结构元，结构元通常比图像小的多。<br><img loading="lazy" src="https://i.loli.net/2019/07/22/5d35670a79cd611294.jpg"></p><ul><li>工具箱函数imdilate(A, B)来执行膨胀</li></ul><pre><code class="line-numbers language-matlab">f = imread(&#39;1111.jpg&#39;);B = [0 1 0; 1 1 1; 0 1 0];%自定义结构元D = imdilate(f, B);subplot(1,2,1),imshow(f);title(&#39;原图&#39;)subplot(1,2,2),imshow(D);title(&#39;膨胀后的图&#39;)</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/22/5d3564132fa1741100.jpg"></p><h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3><p>腐蚀”收缩”或”细化”二值图像中的物体。像膨胀一样，收缩的方法和程度由结构元控制。<br>A被B腐蚀表示为$A\ominus B$,定义为:<br>$$ A\ominus B = {z| (B)_z\subseteq A} = {z| (B)_z\cap A^c = \emptyset}$$<br><img loading="lazy" src="https://i.loli.net/2019/07/23/5d36cefa2813d95731.jpg"></p><p>工具箱函数imerode(A,B)来执腐蚀</p><pre><code class="line-numbers language-matlab">f = imread(&#39;tig.jpg&#39;);B = [0 1 0; 1 1 1; 0 1 0];%自定义结构元R = imerode(f, B);subplot(1,2,1),imshow(f);title(&#39;原图&#39;)subplot(1,2,2),imshow(R);title(&#39;腐蚀后的图&#39;)</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/22/5d356b5f7eed962952.jpg"></p><h3 id="结构元"><a href="#结构元" class="headerlink" title="结构元"></a>结构元</h3><p>strel函数，用来构造各种大小和形状的结构元</p><pre><code class="line-numbers language-matlab">se = strel(shape, parameters);</code></pre><p>shape是希望形状的字符串，parameters是描述形状信息的参数列表<br><img loading="lazy" src="https://i.loli.net/2019/07/22/5d35670a85b4f22579.jpg"><br><img loading="lazy" src="https://i.loli.net/2019/07/22/5d35670a63e2817742.jpg"><br>注意生成的se含有两项</p><ol><li>se.Neighborhood:[ ×  logical ]</li><li>se.Demensionality: 2</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>频域滤波器及其应用</title>
      <link href="/2019/07/20/pin-yu-lu-bo-qi-ji-qi-ying-yong/"/>
      <url>/2019/07/20/pin-yu-lu-bo-qi-ji-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="频域滤波器"><a href="#频域滤波器" class="headerlink" title="频域滤波器"></a>频域滤波器</h1><h2 id="低通滤波器"><a href="#低通滤波器" class="headerlink" title="低通滤波器"></a>低通滤波器</h2><h3 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h3><p>在以原点为圆心，以$D_0$为半径的圆内无衰减通过所有频率，而在圆外切断所有频率的二维低通滤波器，称为理想低通滤波器(ILPF)，定义为<br>$$y=\begin{cases}<br>1,\quad D(x,y)\leq 0\<br>0, \quad D(x,y) &gt; 0<br>\end{cases}$$<br>$D_0$是一个常数，D(u,v)是频率域中心点(u,v)与频率矩形中心的距离，即<br>$$ D(u,v)=\lbrack{(u-\frac{P}{2})^2+(v-\frac{Q}{2})^2}\rbrack^\frac{1}{2} $$<br>过渡点称为<strong>截止频率</strong><br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f0cb755202.jpg"></p><h3 id="布特沃斯低通滤波器"><a href="#布特沃斯低通滤波器" class="headerlink" title="布特沃斯低通滤波器"></a>布特沃斯低通滤波器</h3><p>截止频率位于距原点$D_0$处的n阶布特沃斯低通滤波器(BLPF)的传递函数的定义为:<br>$$H(u,v)=\frac{1}{1+{[D(u,v)/D_0]}^{2n}}$$<br>截止频率点是当D(u,v) = $D_0$时的点<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f101518273.jpg"></p><h3 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a>高斯低通滤波器</h3><p>二维形式:<br>$$H(u,v) = e^{-D^2(u,v)/2{D_0}^2} $$<br>$D_0$ 是截止频率<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f163e99741.jpg"></p><h3 id="使用低通滤波器平滑图像"><a href="#使用低通滤波器平滑图像" class="headerlink" title="使用低通滤波器平滑图像"></a>使用低通滤波器平滑图像</h3><h4 id="1-高斯低通滤波器"><a href="#1-高斯低通滤波器" class="headerlink" title="1. 高斯低通滤波器"></a>1. 高斯低通滤波器</h4><pre><code class="line-numbers language-matlab">f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);[f, revertclass] = tofloat(f);PQ = paddedsize(size(f));[U, V] = dftuv(PQ(1), PQ(2));D = hypot(U, V);D0 = 0.05*PQ(2);F = fft2(f, PQ(1), PQ(2));H = exp(-(D .^ 2)/(2 * (D0^2))); %高斯低通滤波器g = dftfilt(f, H);g = revertclass(g);figure, imshow(fftshift(H));figure, imshow(log(1 + abs(fftshift(F))), [])figure, imshow(g);</code></pre><p>滤波结果：<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d02f5468855048.jpg"></p><p>除了之前说的几个M函数外，还需要用到<code>dftfilt()</code>函数</p><pre><code class="line-numbers language-matlab">function g=dftfilt(f,H)%DFTFILT Performs frequency domain filtering.%   G=DFTFILT(F,H) filters F in the frequency domain using the%   filter transfer function H. The output, G, is the filtered%   image, which has the same size as F. DFTFILT automatically pads%   F to be the same size as H. Function PADDEDSIZE can be used%   to determine an appropriate size for H.%%   DFTFILT assumes that F is real and that H is a real, uncentered,%   circularly-symmetric filter function.%Obtain the FFT of the padded input.F=fft2(f,size(H,1),size(H,2));%Perform filtering.g=real(ifft2(H.*F));%Crop to original size.g=g(1:size(f,1),1:size(f,2));</code></pre><h4 id="2-Butterworth滤波"><a href="#2-Butterworth滤波" class="headerlink" title="2. Butterworth滤波"></a>2. Butterworth滤波</h4><p>该函数输入为灰度图像，自由设置截止频率$D_0$和BLPF的阶数n，输出为滤波后的图像(已归一化到[0,255])</p><pre><code class="line-numbers language-matlab">function [image_out] = Bfilter(image_in, D0, N)% Butterworth滤波器，在频率域进行滤波% 输入为需要进行滤波的灰度图像，Butterworth滤波器的截止频率D0，阶数N% 输出为滤波之后的灰度图像[m, n] = size(image_in);P = 2 * m;Q = 2 * n;fp = zeros(P, Q);%对图像填充0,并且乘以(-1)^(x+y) 以移到变换中心for i = 1 : m    for j = 1 : n        fp(i, j) = double(image_in(i, j)) * (-1)^(i+j);    endend% 对填充后的图像进行傅里叶变换F1 = fft2(fp);% 生成Butterworth滤波函数，中心在(m+1,n+1)Bw = zeros(P, Q);a = D0^(2 * N);for u = 1 : P    for v = 1 : Q        temp = (u-(m+1.0))^2 + (v-(n+1.0))^2;        Bw(u, v) = 1 / (1 + (temp^N) / a);    endend%进行滤波G = F1 .* Bw;% 反傅里叶变换gp = ifft2(G);% 处理得到的图像image_out = zeros(m, n, &#39;uint8&#39;);gp = real(gp);g = zeros(m, n);for i = 1 : m    for j = 1 : n        g(i, j) = gp(i, j) * (-1)^(i+j);    endendmmax = max(g(:));mmin = min(g(:));range = mmax-mmin;for i = 1 : m    for j = 1 : n        image_out(i,j) = uint8(255 * (g(i, j)-mmin) / range);    endendend</code></pre><p>测试BLPF的阶数为2,截止频率分别为10,40,80,150,450</p><pre><code class="line-numbers language-matlab">clear all;close all;clc;image1 = imread(&#39;2.jpg&#39;);image2 = Bfilter(image1, 10, 2);image3 = Bfilter(image1, 40, 2);image4 = Bfilter(image1, 80, 2);image5 = Bfilter(image1, 150, 2);image6 = Bfilter(image1, 450, 2);% 显示图像subplot(2,3,1), imshow(image1), title(&#39;原图像&#39;);subplot(2,3,2), imshow(image2), title(&#39;D0 = 10, n = 2&#39;);subplot(2,3,3), imshow(image3), title(&#39;D0 = 40, n = 2&#39;);subplot(2,3,4), imshow(image4), title(&#39;D0 = 80, n = 2&#39;);subplot(2,3,5), imshow(image5), title(&#39;D0 = 150, n = 2&#39;);subplot(2,3,6), imshow(image6), title(&#39;D0 = 450, n = 2&#39;);</code></pre><p>滤波结果如下:<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d02f43bc610556.jpg"><br>分析结果:    </p><ol><li>模糊的平滑过渡是截止频率增大的函数</li><li>滤波后输出三副连续的色图，原因是rgb图像的分三次呈现<br>一副彩图是由三色组成,红绿蓝三色，图像读取到matlab后，有三个参数m × n × 3, 代表的是三色叠加，处理之后的图将三色展开分别呈现了，所以才会出现三副连续的色图<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d80a09a9124012.jpg"></li></ol><p>换成彩色图可以明显看到<br><img loading="lazy" src="https://i.loli.net/2019/07/20/5d32d80a3073491464.jpg"></p><h2 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h2><p>图像的锐化可以在频率与通过高通滤波器来实现<br>一个高通滤波器可以由一个低通滤波器来实现:<br>$$H_{HP}(u,v)=1-H_{LP}(u,v)$$<br>被低通滤波器衰减的频率可以通过高通滤波器</p><h3 id="理想高通滤波器"><a href="#理想高通滤波器" class="headerlink" title="理想高通滤波器"></a>理想高通滤波器</h3><p>二维理想高通滤波器可以定义为<br>$$ H(u,v)=\begin{cases}<br>1,\quad D(u,v)\leq D_0\<br>0,\quad D(u,v)&gt;D_0<br>\end{cases}<br>$$<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1c410443073.jpg"></p><h3 id="布特沃斯高通滤波器"><a href="#布特沃斯高通滤波器" class="headerlink" title="布特沃斯高通滤波器"></a>布特沃斯高通滤波器</h3><p>截止频率为$D_0$的n阶布特沃斯高通滤波器(BHPF)的定义为:<br>$$ H(u,v)=\frac{1}{1+[D_0/D(u,v)]^{2n}}$$<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1c376281237.jpg"></p><h3 id="高斯高通滤波器"><a href="#高斯高通滤波器" class="headerlink" title="高斯高通滤波器"></a>高斯高通滤波器</h3><p>截止频率处在距频率矩形中心距离为$D_0$的高斯高通滤波器(GHPF)的传递函数如下:<br>$$H(u,v)=1-e^{-D^2(u,v)/2D_0^2}$$<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1c3f7954220.jpg"></p><h3 id="使用高通滤波器锐化图像"><a href="#使用高通滤波器锐化图像" class="headerlink" title="使用高通滤波器锐化图像"></a>使用高通滤波器锐化图像</h3><p>使用高通滤波器来锐化图像，与平滑图像类似，只是将低通滤波器换成了高通滤波器，具体步骤不再赘述</p><pre><code class="line-numbers language-matlab">f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);[f, revertclass] = tofloat(f);PQ = paddedsize(size(f));[U, V] = dftuv(PQ(1), PQ(2));D = hypot(U, V);D0 = 0.05*PQ(1);F = fft2(f, PQ(1), PQ(2));H = hpfilter(&#39;gaussian&#39;,PQ(1), PQ(2), D0);g = dftfilt(f, H);g = revertclass(g);figure(1)subplot(2,2,1);imshow(f,[]);title(&#39;原图像&#39;)subplot(2,2,2);imshow(fftshift(H));title(&#39;高斯高通滤波器&#39;);subplot(2,2,3);imshow(log(1 + abs(fftshift(F))), [])title(&#39;滤波后图像谱&#39;);subplot(2,2,4);imshow(g);title(&#39;滤波后图像&#39;);</code></pre><p>同样这里需要的是高通滤波函数hpfilter()</p><pre><code class="line-numbers language-matlab">function [H] = hpfilter(type,M,N,D0,n)%HPFILTER Computes freq. domain highpass filters%        THIS IS NOT A STANDARD MATLAB FUNCTION%        H = hpfilter (type,M,N,D0,n) creates the%        transfer function of a highpass filter, H, of%        the specified type and size MxN. Possible%        values for type, D0, and n are:%%        &#39;ideal&#39;                Ideal highpass filter with%                        cutoff frequency D0. If%                        supplied, n is ignored.%        &#39;btw&#39;                Butterworth highpass filter%                        of order n, and cutoff D0.%        &#39;gaussn&#39;            Gaussian highpass filter with%                        cutoff (standard deviation)D0.%                        If supplied, n is ignored.%        M and N should be even numbers for DFT%        filtering.%%        Class support: double, uint8, uint16%        The output is of class double%       The transfer function Hhp of a highpass filter%       is 1 - Hlp, where Hlp is the transfer function of%       the corresponding lowpass filter.  Thus, we can%       use function lpfilter to generate highpass filters%       If filter is btw, make sure that n is provided%       Otherwise, pass n=1 as an arbitrary value to%       prevent error messageif nargin == 4    n = 1; %default value of nendHlp = lpfilter(type,M,N,D0,n);H = 1 - Hlp;%       End of function</code></pre><p>锐化结果:</p><ol><li>IHPF<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341eae3a6b123891.jpg"></li><li>BHPF<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341bf1f13e453488.jpg"></li><li>GHPF<br><img loading="lazy" src="https://i.loli.net/2019/07/21/5d341eae4fa8d96779.jpg"></li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>频域滤波</title>
      <link href="/2019/07/19/pin-yu-lu-bo/"/>
      <url>/2019/07/19/pin-yu-lu-bo/</url>
      
        <content type="html"><![CDATA[<h1 id="频域滤波"><a href="#频域滤波" class="headerlink" title="频域滤波"></a>频域滤波</h1><ol><li>对图像平滑的低通滤波</li><li>对图像锐化的高通滤波</li><li>去除周期的选择性滤波</li></ol><h2 id="二维傅里叶变换"><a href="#二维傅里叶变换" class="headerlink" title="二维傅里叶变换"></a>二维傅里叶变换</h2><ul><li><p>二维傅里叶变换:<br>$$ F(u,v)=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x,y)e^{-j2\pi(ux + vy)},\mathrm{d}x \mathrm{d}y $$</p></li><li><p>二维傅里叶逆变换：<br>$$ f(x,y) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(u,v)e^{j2\pi(ux + vy)},dxdy $$</p></li></ul><h2 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h2><p>f(x,y)代表一幅大小为M×N的图像，其中x=0,1,……,M-1,y=0,1,…..,N-1,DFT如下</p><p>$$ F(u,v)=\int_{x=0}^{M-1} \int_{y=0}^{N-1} f(x,y)e^{-j2\pi(\frac{ux}{M}+\frac{vy}{N})},\mathrm{d}x \mathrm{d}y $$</p><p>IDFT：</p><p>$$ f(x,y)=\frac{1}{MN}\int_{x=0}^{M-1} \int_{y=0}^{N-1} F(u,v)e^{j2\pi(\frac{ux}{M}+\frac{vy}{N})},\mathrm{d}x \mathrm{d}y $$</p><p>这里的F(u,v)被称为展开的傅里叶级数</p><p>频域原点出的变换的值F(0,0)称为傅里叶变换的直流(dc)分量，F(0,0)等于f(0,0)平均值的MN倍。要注意的是在MATLAB中索引是从1开始的而不是从0开始的</p><h2 id="MATLAB实现对图像的Fourier变换和逆变换"><a href="#MATLAB实现对图像的Fourier变换和逆变换" class="headerlink" title="MATLAB实现对图像的Fourier变换和逆变换"></a>MATLAB实现对图像的Fourier变换和逆变换</h2><ul><li>Fourier变换，f为原图像</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; F = fft2(f);</code></pre><ul><li>Fourier谱</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; S = abs(F);</code></pre><p>该函数计算的是数组中每个元素的幅值( $ \sqrt{r^2+i^2} $ )<br>可以在这里观察到4个角的亮点，这就是周期特性的结果，不便观察</p><ul><li>将交换的原点移动到频域矩形的中心</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; Fc = fftshift(F)</code></pre><p>频谱范围大，不便观察</p><ul><li>取模，缩放</li></ul><pre><code class="line-numbers language-matlab">S2 = log(1 + abs(Fc));</code></pre><ul><li>Fourier逆变换</li></ul><pre><code class="line-numbers language-matlab">&gt;&gt; f = ifft2(F);</code></pre><p>下面是完整代码</p><pre><code class="line-numbers language-matlab">img=imread(&#39;moon.jpg&#39;);subplot(2,2,1);    imshow(img);    title(&#39;原图&#39;);f=rgb2gray(img);    %对于RGB图像必须做的一步，也可以用im2double函数F=fft2(f);          %Fourier变换F1=log(abs(F)+1);   %取模,缩放subplot(2,2,2);    imshow(F1,[]);    title(&#39;傅里叶变换频谱图&#39;);Fs=fftshift(F);      %将频谱图中零频率成分移动至频谱图中心S=log(abs(Fs)+1);    %取模并进行缩放subplot(2,2,3);    imshow(S,[]);    title(&#39;频移后的频谱图&#39;);fr=real(ifft2(ifftshift(Fs)));  %频率域反变换到空间域，并取实部ret=im2uint8(mat2gray(fr));    %更改图像类型subplot(2,2,4);    imshow(ret);    title(&#39;逆傅里叶变换&#39;);</code></pre><p>结果<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d3043778b4e114553.jpg"><br>如果使用<code>&gt;&gt; f = im2double(img)</code>进行处理，则会出现以下结果<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d304377bcc9554917.jpg"></p><ul><li>分析    </li></ul><ol><li>图像Fourier变换之后立即imshow会报错<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d3043779bef722309.jpg"><br>这是因为经过fourier变换之后的图像矩阵为复数矩阵，包含实部和虚部，此时进行<code>abs(f)</code>取复数矩阵的模，再显示。</li><li><code>rgb2gray()</code>和<code>im2double()</code>的使用<br>这一点要特别注意，对于RGB图像，<code>imread()</code>是已三维矩阵的形式来存储的，要先进行类型转换，否则会出现空白    </li><li><code>rgb2gray()</code>转换为灰度图像,得到的图像呈灰色基调，见‘结果’</li><li><code>im2double()</code>转换成双精度图像，得到的图像呈白色基调，见‘结果’<br>其他图像处理结果<br><img loading="lazy" src="https://i.loli.net/2019/07/18/5d304377bd0c676784.jpg"></li></ol><p><img loading="lazy" src="https://i.loli.net/2019/07/18/5d304377b0b2610307.jpg"><br>可以看到Fourier逆变换处理之后的图片为原图的灰度图片。</p><h2 id="对图像Fourier变换的意义分析"><a href="#对图像Fourier变换的意义分析" class="headerlink" title="对图像Fourier变换的意义分析"></a>对图像Fourier变换的意义分析</h2><p>对于一个图像，其频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间的梯度。设f为一个能量有限的模拟信号，其傅里叶变换代表f的频谱。从纯粹的数学意义上来看，Fourier变换是将一个函数转换成一系列的周期函数来进行处理的。从物理角度来看，Fourier变换是将图像从空间域转换到频率域，逆变换是将图像从频率域转换到空间域。也就是说，Fourier变换是将图像的灰度分布函数变换成图像的频率分布函数。<strong>这里要注意是灰度分布函数</strong>,下面还会说到。</p><p>Fourie逆变换是将图像的频率分布函数转换成灰度分布函数(原始图像的灰度分布函数),图像的概念前边说过，用一个二维矩阵来表示空间上的各点，z=f(x,y)，但空间是三维的，因此空间上的物体在另一个维度上的关系必须由梯度来表示。</p><p>Fourier频谱图上的明暗点，意义是指图像上的某一点与邻域点差异的强弱，即梯度的大小。</p><p>对频谱移频到原点之后，可以看出图像的频率分布是以原点为圆心，对称分布的.</p><h2 id="DFT滤波"><a href="#DFT滤波" class="headerlink" title="DFT滤波"></a>DFT滤波</h2><h3 id="滤波步骤"><a href="#滤波步骤" class="headerlink" title="滤波步骤"></a>滤波步骤</h3><ol><li>用函数<code>tofloat</code>把输入图像转换成浮点图像<pre><code class="line-numbers language-matlab">&gt;&gt; [f, revertclass] = tofloat(f);</code></pre></li><li>用函数<code>paddedsize</code>来获得填充参数<pre><code class="line-numbers language-matlab">&gt;&gt; PQ = paddedsize(size(f));</code></pre></li><li>得到有填充的Fourier变换<pre><code class="line-numbers language-matlab">&gt;&gt; F = fft2(f,PQ(1), PQ(2));</code></pre></li><li>生成大小为PQ(1)×PQ(2)的滤波函数H,函数类型要满足如下图所示,<br><img loading="lazy" src="https://i.loli.net/2019/07/19/5d318dcf343b438405.jpg"><br>如果是类似这样的<br><img loading="lazy" src="https://i.loli.net/2019/07/19/5d318dcf4915275796.jpg">    <pre><code class="line-numbers language-matlab">&gt;&gt; H = lpfilter(&#39;gaussian&#39;,PQ(1),PQ(2),2*sig);</code></pre>在使用滤波器之前，要先<code>H = fftshift(H)</code></li><li>用滤波器乘以FFT变换<pre><code class="line-numbers language-matlab">&gt;&gt; G = H .* F;</code></pre></li><li>获得G的逆Fourier变换<pre><code class="line-numbers language-matlab">&gt;&gt; g = ifft2(G);</code></pre></li><li>修剪左上部矩形为原始大小<pre><code class="line-numbers language-matlab">&gt;&gt; g = g(1:size(f, 1), 1:size(f, 2));</code></pre></li><li>把滤波后的图像变换为输入图像的类<pre><code class="line-numbers language-matlab">&gt;&gt; g = revertclass(g);</code></pre><h3 id="Matlab实现"><a href="#Matlab实现" class="headerlink" title="Matlab实现"></a>Matlab实现</h3></li></ol><pre><code class="line-numbers language-matlab">f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);%未填充的滤波[M,N] = size(f);[f, revertclass] = tofloat(f);F = fft2(f);sig = 10;H = lpfilter(&#39;gaussian&#39;, M, N, sig);G = H.*F;g = ifft2(G);g = revertclass(g);figure(1);subplot(1,2,1);imshow(g)title(&#39;未填充的滤波&#39;);%已填充的滤波PQ = paddedsize(size(f));Fp = fft2(f,PQ(1),PQ(2));Hp = lpfilter(&#39;gaussian&#39;,PQ(1),PQ(2),2*sig);Gp = Hp.*Fp;gp = ifft2(Gp);gpc = gp(1:size(f,1),1:size(f,2));gpc = revertclass(gpc);subplot(1,2,2);imshow(gpc);title(&#39;已填充的滤波&#39;);</code></pre><p>这里展示了不填充滤波和填充滤波的两种情况，结果<br><img loading="lazy" src="https://i.loli.net/2019/07/19/5d318dcf1e88071166.jpg"><br>可以观察到未填充滤波处理后图像的垂直边缘未模糊</p><p>涉及到的函数    </p><ul><li>paddedsize函数</li></ul><pre><code class="line-numbers language-matlab">function PQ = paddedsize(AB, CD, PARAM)if nargin == 1PQ = 2*AB;elseif nargin == 2 &amp; ~ischar(CD) %如果CD不为字符串PQ = AB + CD -1;PQ = 2 *ceil(PQ / 2);elseif nargin == 2 %如果CD处为字符串m = max(AB);P = 2^nextpow2(2*m); %取2的整数次幂PQ = [P, P];elseif nargin == 3m = max([AB CD]);P = 2^nextpow2(2*m);PQ = [P, P];elseerror(&#39;wrong number of inputs.&#39;)end</code></pre><ul><li>lpfilter函数</li></ul><pre><code class="line-numbers language-matlab">function [ H, D ] = lpfilter( type,M,N,D0,n )%LPFILTER creates the transfer function of a lowpass filter.%   Detailed explanation goes here%use function dftuv to set up the meshgrid arrays needed for computing%the required distances.[U, V] = dftuv(M,N);%compute the distances D(U,V)D = sqrt(U.^2 + V.^2);%begin filter computationsswitch type    case &#39;ideal&#39;        H = double(D &lt;= D0);    case &#39;btw&#39;        if nargin == 4            n = 1;        end        H = 1./(1+(D./D0).^(2*n));    case &#39;gaussian&#39;        H = exp(-(D.^2)./(2*(D0^2)));    otherwise        error(&#39;Unkown filter type&#39;);end</code></pre><ul><li>dftuv函数</li></ul><pre><code class="line-numbers language-matlab">function [ U,V ] = dftuv( M, N )%DFTUV 实现频域滤波器的网格函数%   Detailed explanation goes hereu = 0:(M - 1);v = 0:(N - 1);idx = find(u &gt; M/2); %找大于M/2的数据u(idx) = u(idx) - M; %将大于M/2的数据减去Midy = find(v &gt; N/2);v(idy) = v(idy) - N;[V, U] = meshgrid(v, u);</code></pre><ul><li>总结：</li></ul><ol><li>图像平滑之后，变得更柔和，但也会更模糊    </li><li>会出现的问题:图像的边缘部分往往也处于高频，会被滤除</li></ol><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空间滤波</title>
      <link href="/2019/07/17/kong-jian-lu-bo/"/>
      <url>/2019/07/17/kong-jian-lu-bo/</url>
      
        <content type="html"><![CDATA[<h1 id="空间滤波基础"><a href="#空间滤波基础" class="headerlink" title="空间滤波基础"></a>空间滤波基础</h1><h2 id="滤波的原理："><a href="#滤波的原理：" class="headerlink" title="滤波的原理："></a>滤波的原理：</h2><p>空间滤波是采用滤波处理的图像增强的方法，理论基础是空间卷积和空间相关，目的是改善图片质量</p><h2 id="线性空间滤波"><a href="#线性空间滤波" class="headerlink" title="线性空间滤波"></a>线性空间滤波</h2><ul><li>移动滤波的模板w称为滤波器</li><li>相关 与 卷积：<br>相关是指模板w按下图所示的方式进行图像数组的处理。在原理上，卷积是相同的处理过程，只不过在w通过之前先将它选旋转180度<br><img loading="lazy" src="https://i.loli.net/2019/07/16/5d2d9d9ea213761403.jpg"><br>相关与卷积操作说明<br><img loading="lazy" src="https://i.loli.net/2019/07/16/5d2d9dffdbc4911045.jpg"><br>需要注意的地方：    </li></ul><ol><li>相关是滤波器位移的函数</li><li>滤波器w与一个只包含一个1其余全是0的函数相关，得到的是旋转了180度的滤波器w，将这个函数称之为<strong>离散单位冲激</strong><br>结论: 一个函数与离散单位冲激相关，在该冲激位置产生这个函数的一个翻转版本<br>一个函数与离散单位冲激相关激卷积，得到的是在该冲激处的这个函数的拷贝，这个复制的性质称为筛选<br>这种定义推广到图像如下图所示<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2e77c7afba429201.jpg"><br>为了便于表达，以公式形式总结两种形式</li></ol><ul><li>大小为m×n的滤波模板w(x,y)与函数f(x,y)的相关<pre><code>   ![](https://i.loli.net/2019/07/17/5d2e78e52323950837.jpg)</code></pre></li><li>大小为m×n的滤波模板w(x,y)与函数f(x,y)的卷积<br>$$w(x,y)\bigstar f(x,y)=\sum_{s=-a}^{a}\sum_{t=-b}^{b}w(s,t)f(x+s,y+t)$$</li></ul><ul><li><p>Matlab的实现:<br>工具箱使用imfilter来实现线性空间滤波，语法如下:</p><pre><code class="line-numbers language-matlab">g = imfilter(f, w, filtering_mode, boundary_options, size_options)</code></pre><p>默认值为相关，若想执行卷积操作，有以下两种做法：</p><pre><code class="line-numbers language-matlab">g = imfilter(f, w, &#39;conv&#39;)</code></pre><p>或者使用<code>rot90(w, 2)</code>来将w旋转180度</p><pre><code class="line-numbers language-matlab">g = imfilter(f, rot90(w, 2))</code></pre><p>f是输入图像，w为滤波模板，g为滤波结果<br>其他参数如下<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2e84e556ad615011.jpg"><br>使用matlab实现为</p><pre><code class="line-numbers language-matlab">f = imread(&#39;filter.jpg&#39;);F = im2double(f);imshow(F);title(&#39;current image&#39;);w = ones(31);gd = imfilter(F, w);figure,imshow(gd, [ ]);title(&#39;Default&#39;);gr = imfilter(F, w, &#39;replicate&#39;);figure,imshow(gr, [ ]);title(&#39;replicate&#39;);gs = imfilter(F, w, &#39;symmetric&#39;);figure,imshow(gs, [ ]);title(&#39;symmetric&#39;);gc = imfilter(F, w, &#39;circular&#39;);figure,imshow(gc, [ ]);title(&#39;circular&#39;);g = imfilter(f, w, &#39;replicate&#39;);figure,imshow(g, [ ]);title(&#39;replicate unit8&#39;);</code></pre><p>这里开始读取的filter.jpg为uint8格式，故在处理之前先使用<code>im2double</code>将其转化为double类型以提高精度<br>滤波结果如下<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2e8517ac67e80281.jpg"></p></li></ul><h2 id="非线性空间滤波："><a href="#非线性空间滤波：" class="headerlink" title="非线性空间滤波："></a>非线性空间滤波：</h2><p>线性空间滤波基于计算乘积和，即线性操作，非线性空间滤波基于涉及邻域像素内的非线性操作，例如，使每个中心点的响应等于邻域内像素最大值的操作可以称为是非线性滤波操作      </p><ul><li>Matlab工具</li></ul><ol><li>nlfilter：直接执行二维操作</li><li>coldilt：按列组织数据，更多采用</li></ol><h2 id="标准的-空间滤波器"><a href="#标准的-空间滤波器" class="headerlink" title="标准的 空间滤波器"></a>标准的 <strong>空间滤波器</strong></h2><h3 id="线性空间滤波器"><a href="#线性空间滤波器" class="headerlink" title="线性空间滤波器"></a>线性空间滤波器</h3><ul><li><p>可以使用fspecial实现，生成滤波器w</p><pre><code class="line-numbers language-matlab">w = fspecial(&#39;type&#39;, parameters)</code></pre><p>  ‘type’表示滤波器的类型，’parameters’进一步定义指定的滤波器<br>  应用参数如下：<br>  <img loading="lazy" src="https://i.loli.net/2019/07/17/5d2eba0f5055d41026.jpg"><br>  <img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ec9491164776894.jpg"></p></li><li><p>Laplace滤波器的实现</p><ul><li><p>原理：<br>图像f(x,y)的laplace算子：<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ec90e6a75162149.jpg"><br>Laplace算子增强公式：<br>$$g(x,y) = f(x,y)+c[\triangledown ^2 f(x,y)]$$<br>注意：如果模板的中心系数为正，c为1;如果为负，c为0.</p><pre><code class="line-numbers language-matlab">fspecial(&#39;laplacian&#39;, alpha)</code></pre><p>可以实现更为一般的laplace模板</p></li></ul><ul><li><p>下面是用laplace滤波器增强图像的例子：<br>首先设置滤波器</p><pre><code class="line-numbers language-matlab">&gt;&gt; w = fspecial(&#39;laplacian&#39;, 0);</code></pre><p><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed6fcca83142276.jpg"></p><p>输入的图像为unit8类，</p><pre><code class="line-numbers language-matlab">&gt;&gt; g1 = imfilter(f, w, &#39;replicate&#39;);&gt;&gt; imshow(g1);</code></pre><p>得到结果，但存在问题，所有像素都是正的。原因：滤波器的中心参数为负值，为了解决这一问题，可以在滤波前将f转换为浮点数</p><pre><code class="line-numbers language-matlab">&gt;&gt; ff = tofloat(f);&gt;&gt; g2 = imfilter(ff, w, &#39;replicate&#39;);&gt;&gt; imshow(g2);</code></pre><p>这里tofloat为M-IPT函数，实现代码如下：</p><pre><code class="line-numbers language-matlab">function [out,revertclass] = tofloat(inputimage)%Copy the book of Gonzalesidentify = @(x) x;tosingle = @im2single;table = &#123;&#39;uint8&#39;,tosingle,@im2uint8&#39;uint16&#39;,tosingle,@im2uint16&#39;logical&#39;,tosingle,@logical&#39;double&#39;,identify,identify&#39;single&#39;,identify,identify&#125;;classIndex = find(strcmp(class(inputimage),table(:,1)));if isempty(classIndex)error(&#39;不支持的图像类型&#39;);endout = table&#123;classIndex,2&#125;(inputimage);revertclass = table&#123;classIndex,3&#125;;</code></pre><p>导入workspace即可</p><p>最后用原始图像减去laplace图像来恢复失去的灰度层次(因为中心参数为负值)</p><pre><code class="line-numbers language-matlab">&gt;&gt; g = ff - g2;imshow(g);</code></pre><p>可以看到结果比原图象要清晰<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed69eaa47174206.jpg"></p></li></ul></li></ul><h3 id="非线性空间滤波器"><a href="#非线性空间滤波器" class="headerlink" title="非线性空间滤波器"></a>非线性空间滤波器</h3><ul><li>函数ordfilt2计算统计排序(order-statistic filter)滤波器(也叫做rank filter,即排序滤波器)<br>语法为：</li></ul><pre><code class="line-numbers language-matlab">g = ordfilt2(f, order, domain)</code></pre><p>用邻域集合中的第order个元素去替换f中的每个元素的值来生成图像g，domain是由0和1组成的大小为m×n的矩阵，规定了在计算中使用的邻域中像素点的位置</p><ul><li>中值滤波器，最著名的统计排序滤波器，对应第50个百分位，对应奇数的m和n</li></ul><pre><code class="line-numbers language-matlab">g = ordfilt2(f, (m*n + 1)/2, ones(m, n));</code></pre><ul><li>这里提供了一个专门的二维中值滤波器:</li></ul><pre><code class="line-numbers language-matlab">g = medfilt2(f, [m, n], padopt)</code></pre><p>  padopt规定了三个可能的边缘填充选项:</p><ol><li>‘zeros’,默认值</li><li>‘symmetric’,f按照镜像反射方式对称地沿边缘扩展</li><li>‘indexed’，f属于double类，用1填充;否则用0填充</li></ol><ul><li><p>中值滤波增强图像:<br>首先给图像添加黑白噪点发生概率为0.2的’椒盐噪声’</p><pre><code class="line-numbers language-matlab">&gt;&gt; fn = imnoise(f, &#39;salt &amp; pepper&#39;, 0.2)</code></pre><p>对带噪图像进行中值滤波处理</p><pre><code class="line-numbers language-matlab">&gt;&gt; gm = medfilt2(fn)</code></pre><p>注意，在这里出现了错误，==A应为二维==<br><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed759e608448713.jpg"></p><p>原因:中值滤波medfilt2,输入的图像应为二维矩阵，实际输入的为imread读取的图像加上噪声，通常是三维RGB图，是三维矩阵<br>解决办法:先用rgb2gray(f)将图像转换为灰度矩阵图像</p><pre><code class="line-numbers language-matlab">&gt;&gt; fn2 = rgb2gray(fn);&gt;&gt; gm = medfilt2(fn2);&gt;&gt; imshow(gm);</code></pre><p>减弱外圈黑点</p><pre><code class="line-numbers language-matlab">&gt;&gt; gms = medfilt2(fn2, &#39;symmetric&#39;);</code></pre></li></ul><p><img loading="lazy" src="https://i.loli.net/2019/07/17/5d2ed7776b71a55041.jpg"></p><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Digital Image Processing</title>
      <link href="/2019/07/15/digital-image-processing/"/>
      <url>/2019/07/15/digital-image-processing/</url>
      
        <content type="html"><![CDATA[<h2 id="Digital-Image-Processing-notes"><a href="#Digital-Image-Processing-notes" class="headerlink" title="Digital Image Processing notes:"></a>Digital Image Processing notes:</h2><ul><li><p>图像处理的步骤：</p><ol><li>图像获取 包括图像预处理</li><li>图像滤波与增强 使之适用于 <strong>特定应用</strong></li><li>图像复原 倾向于以图像退化的数学或概率模型为基础</li><li>彩色图像处理</li><li>压缩 减少图像存储量或降低传输图像带宽 </li><li>形态学处理</li><li>图像分割</li><li>目标识别<h3 id="数字图像基础"><a href="#数字图像基础" class="headerlink" title="数字图像基础"></a>数字图像基础</h3></li></ol></li><li><p>灰度概念<br>  灰度是表明图像明暗的数值，即黑白图像中点的颜色深度，范围一般是0-255,白色为255,黑色为0,归一化处理之后[0,1],0代表黑色，1代表白色。</p></li><li><p>图像取样与量化</p><ul><li>对坐标值数字化称为取样，对幅度值数字化称为量化</li></ul></li><li><p>数字的图像表示<br>  将连续图像取样表示为一个二维阵列 $f(x,y)$</p><ol><li>函数图表示：用x和y两个坐标轴来表示空间位置，第三个坐标为f(灰度)值，即 $f(x,y,z)$，</li><li>一般的表示：显示的是 $f(x,y)$在监视器或照片上的情况，每个点的灰度与该点处的f值成正比，例如归一化[0,1],三个等间隔点分别为0,0.5,1</li><li>矩阵： 将 $f(x,y)$的值打印成矩阵<br>注意坐标为右手笛卡尔系</li></ol></li><li><p>对比度： 最高和最低的灰度级的差</p></li><li><p>典型灰度级：<br>$$2^k$$<br>称为一副’k bit图像’</p></li><li><p>图像内插</p><ul><li>最邻近内插</li><li>双线性内插</li><li>双三次内插</li></ul></li><li><p>图像处理的算术操作</p><ul><li>图片相加  平均 -&gt; 降噪</li><li>图片相减  增强图像差别</li><li>图片想乘除  校正阴影</li></ul></li><li><p>灰度变换</p><ul><li>s = T(r)</li><li>Matlab中的灰度变换函数<br><code>imadjust(f,[LOW_IN,HIGH_IN],[LOW_OUT,HIGH_OUT],grmma)</code></li></ul></li><li><p>直方图的处理和函数绘图</p><ul><li><p>生成图像的直方图</p><pre><code class="line-numbers language-matlab">  &gt;&gt; h = imhist(f)</code></pre></li><li><p>也可以用条形图来表示</p><pre><code class="line-numbers language-matlab">&gt;&gt; h = imhist(f,25);&gt;&gt; horz = linespace(0,255,25);&gt;&gt; bar(horz,h)&gt;&gt; axis(0 255 0 60000);&gt;&gt; set(gca, &#39;xtick&#39;, 0:50:255)&gt;&gt; set(gca, &#39;ytick&#39;, 0:20000:60000)</code></pre></li><li><p>杆状图<br><code>stem(horz, z , &#39;LineSpec&#39;, &#39;fill&#39;)</code></p></li><li><p>plot函数<br><code>plot(horz, z, &#39;LineSpec&#39;)</code></p></li><li><p>当处理函数句柄时<br><code>fplot(fhandle, limits, &#39;LineSpec&#39;)</code></p></li></ul></li></ul><div><h1>推荐文章<span style="font-size:0.45em; color:gray"></span></h1><ul><li><a href="https://godliuyang.wang/2019/08/07/pca-suan-fa-shi-xian/">PCA算法实现</a></li><li><a href="https://godliuyang.wang/2019/08/01/local-binary-patterns/">Local Binary Patterns</a></li><li><a href="https://godliuyang.wang/2019/07/29/high-quality-ellipse-detection/">High-quality-ellipse-detection</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Digital Image Processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

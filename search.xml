<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Day19</title>
      <link href="/2019/08/02/day19/"/>
      <url>/2019/08/02/day19/</url>
      
        <content type="html"><![CDATA[<h1 id="基于LBP的人脸检测"><a href="#基于LBP的人脸检测" class="headerlink" title="基于LBP的人脸检测"></a>基于LBP的人脸检测</h1><p>在图片人脸检测的基础上加上视频流。<br>原理就是对视频逐帧处理，1s大约分为30帧。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/highgui/highgui.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/imgproc/imgproc.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/core/core.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/objdetect/objdetect.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> CV_COLOR_GREEN cv::Scalar(0, 255, 0)</span>CascadeClassifier faceCascade<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//打开摄像头</span>  VideoCapture <span class="token function">cap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cap<span class="token punctuation">.</span><span class="token function">isOpened</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//读取分类器</span>  CascadeClassifier <span class="token function">faceDetector</span><span class="token punctuation">(</span><span class="token string">"lbpcascade_frontalface.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  vector<span class="token operator">&lt;</span>Rect<span class="token operator">></span> objects<span class="token punctuation">;</span>  Mat frame<span class="token punctuation">;</span>  Mat edges<span class="token punctuation">;</span>  <span class="token keyword">bool</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span><span class="token punctuation">{</span>    cap <span class="token operator">>></span> frame<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> scaleFactor<span class="token operator">=</span><span class="token number">1.1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> minNeighbors <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//int flags = 1;</span>    <span class="token comment" spellcheck="true">//cvtColor(frame, edges, CV_BGR2GRAY);</span>    <span class="token comment" spellcheck="true">//GaussianBlur(edges, edges, Size(7,7), 1.5, 1.5);</span>    faceDetector<span class="token punctuation">.</span><span class="token function">detectMultiScale</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> objects<span class="token punctuation">,</span>scaleFactor<span class="token punctuation">,</span> minNeighbors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">rectangle</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> objects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> CV_COLOR_GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">rectangle</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> objects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> CV_COLOR_GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//imshow("edge", edges);</span>    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"frame"</span><span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>      stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>识别结果:</p><p><img src="https://i.loli.net/2019/08/02/5d43e017d9e1227148.png" alt><br><img src="https://i.loli.net/2019/08/02/5d43e017f281538470.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day18</title>
      <link href="/2019/08/01/day18/"/>
      <url>/2019/08/01/day18/</url>
      
        <content type="html"><![CDATA[<h1 id="LBP算法实现及人脸检测"><a href="#LBP算法实现及人脸检测" class="headerlink" title="LBP算法实现及人脸检测"></a>LBP算法实现及人脸检测</h1><h2 id="OpenCV模块"><a href="#OpenCV模块" class="headerlink" title="OpenCV模块"></a>OpenCV模块</h2><ul><li>core：简洁核心模块，基本函数，基本数据结构</li><li>imgproc：图像处理模块，线性和非线性图像滤波，几何图像转换，颜色空间转换，直方图等。</li><li>video：视频分析模块，运动估计，背景消除，物体跟踪算法</li><li>calib3d：基本多视角几何算法，单体和立体相机的标定，对象姿势估计，双目立体匹配算法和元素的三维重建</li><li>features2d：包含了显著特征检测算法，描述算子和算子匹配算法</li><li>objdetect：物体检测和一些预定义的物体的检测（如人脸，眼睛，杯子，人，汽车等)</li><li>ml：多种机器学习算法，如K均值，支持向量机和神经网络</li><li>highgui：简单易用接口，有视频捕捉，图像和视频编码功能，简单UI接口，iOS的是其中一个子集</li><li>gpu：GPU加速算法，iOS不可用</li><li>ocl：OpenCL通用算法，iOS不可用</li><li>其它辅助模块，如用户贡献的算法</li></ul><h2 id="原始LBP特征"><a href="#原始LBP特征" class="headerlink" title="原始LBP特征"></a>原始LBP特征</h2><pre class=" language-c++"><code class="language-c++">//Original_LBPMat get_original_LBP_feature(Mat img){  Mat result;  result.create(img.rows - 2, img.cols -2, img.type());  result.setTo(0);  for (int i = 1; i < img.rows - 1; i++){    for (int j = 1; j < img.cols -1; j++){      uchar center = img.at<uchar>(i, j);      uchar lbpcode = 0;      lbpcode |= (img.at<uchar>(i - 1, j - 1) >= center) << 7;      lbpcode |= (img.at<uchar>(i - 1, j) >= center) << 6;      lbpcode |= (img.at<uchar>(i - 1, j + 1) >= center) << 5;      lbpcode |= (img.at<uchar>(i, j -1) >= center) << 4;      lbpcode |= (img.at<uchar>(i, j + 1) >= center) << 3;      lbpcode |= (img.at<uchar>(i + 1, j - 1) >= center) << 2;      lbpcode |= (img.at<uchar>(i + 1, j) >= center) << 1;      lbpcode |= (img.at<uchar>(i + 1, j + 1) >= center) << 0;      result.at<uchar>(i - 1, j - 1) = lbpcode;    }  }  return result;}</code></pre><p><img src="https://i.loli.net/2019/07/31/5d4161dac5f0b23887.png" alt></p><h2 id="圆形LBP特征"><a href="#圆形LBP特征" class="headerlink" title="圆形LBP特征"></a>圆形LBP特征</h2><pre class=" language-c++"><code class="language-c++">//Circular_LBP_featureMat get_circular_LBP_feature(Mat img, int radius, int neighbors){  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  //循环处理每个像素  for(int i=radius;i<img.rows-radius;i++)  {      for(int j=radius;j<img.cols-radius;j++)      {          //获得中心像素点的灰度值          uchar center = img.at<uchar>(i,j);          uchar lbpCode = 0;          for(int k=0;k<neighbors;k++)          {              //根据公式计算第k个采样点的坐标，这个地方可以优化，不必每次都进行计算radius*cos，radius*sin              float x = i + static_cast<float>(radius * \                  cos(2.0 * CV_PI * k / neighbors));              float y = j - static_cast<float>(radius * \                  sin(2.0 * CV_PI * k / neighbors));                //根据取整结果进行双线性插值，得到第k个采样点的灰度值                //1.分别对x，y进行上下取整                int x1 = static_cast<int>(floor(x));                int x2 = static_cast<int>(ceil(x));                int y1 = static_cast<int>(floor(y));                int y2 = static_cast<int>(ceil(y));                //将坐标映射到0-1之间                float tx = x - x1;                float ty = y - y1;                //根据0-1之间的x，y的权重计算公式计算权重                float w1 = (1-tx) * (1-ty);                float w2 =    tx  * (1-ty);                float w3 = (1-tx) *    ty;                float w4 =    tx  *    ty;                //3.根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at<uchar>(x1,y1) * w1 + img.at<uchar>(x1,y2) *w2 + img.at<uchar>(x2,y1) * w3 +img.at<uchar>(x2,y2) *w4;                //通过比较获得LBP值，并按顺序排列起来                lbpCode |= (neighbor>center) <<(neighbors-k-1);            }            result.at<uchar>(i-radius,j-radius) = lbpCode;        }    }  return result;}</code></pre><p>结果:<br><img src="https://i.loli.net/2019/08/01/5d42b5d2e345026549.png" alt></p><p>第一幅图设置半径为4,第二幅图设置半径为1,可以看到半径越小处理的越精细。</p><h2 id="旋转不变LBP特征"><a href="#旋转不变LBP特征" class="headerlink" title="旋转不变LBP特征"></a>旋转不变LBP特征</h2><pre class=" language-c++"><code class="language-c++">//Rotation_Invariant_LBP_featureMat get_rotation_invariant_LBP_feature(Mat img, int radius, int neighbors){  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  for(int k=0;k<neighbors;k++)    {        //计算采样点对于中心点坐标的偏移量rx，ry        float rx = static_cast<float>(radius * cos(2.0 * CV_PI * k / neighbors));        float ry = -static_cast<float>(radius * sin(2.0 * CV_PI * k / neighbors));        //为双线性插值做准备        //对采样点偏移量分别进行上下取整        int x1 = static_cast<int>(floor(rx));        int x2 = static_cast<int>(ceil(rx));        int y1 = static_cast<int>(floor(ry));        int y2 = static_cast<int>(ceil(ry));        //将坐标偏移量映射到0-1之间        float tx = rx - x1;        float ty = ry - y1;        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关        float w1 = (1-tx) * (1-ty);        float w2 =    tx  * (1-ty);        float w3 = (1-tx) *    ty;        float w4 =    tx  *    ty;        //循环处理每个像素        for(int i=radius;i<img.rows-radius;i++)        {            for(int j=radius;j<img.cols-radius;j++)            {                //获得中心像素点的灰度值                uchar center = img.at<uchar>(i,j);                //根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at<uchar>(i+x1,j+y1) * w1 + img.at<uchar>(i+x1,j+y2) *w2 + img.at<uchar>(i+x2,j+y1) * w3 +img.at<uchar>(i+x2,j+y2) *w4;                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得                result.at<uchar>(i-radius,j-radius) |= (neighbor>center) <<(neighbors-k-1);            }        }    }    //进行旋转不变处理    for(int i=0;i<result.rows;i++)    {        for(int j=0;j<result.cols;j++)        {            uchar currentValue = result.at<uchar>(i,j);            uchar minValue = currentValue;            for(int k=1;k<neighbors;k++)        //循环左移            {                uchar temp = (currentValue>>(neighbors-k)) | (currentValue<<k);                if(temp < minValue)                {                    minValue = temp;                }            }            result.at<uchar>(i,j) = minValue;        }    }    return result;}</code></pre><p>结果:<br><img src="https://i.loli.net/2019/08/01/5d42b5d30749958722.png" alt></p><p>第一幅图neighbors值设置为8,第二幅设置为6,可以看出neighbors值越大，得到的LBP特征亮度越高。</p><h2 id="完整代码如下"><a href="#完整代码如下" class="headerlink" title="完整代码如下"></a>完整代码如下</h2><pre class=" language-c++"><code class="language-c++">#include <opencv2/highgui/highgui.hpp>using namespace cv;//Original_LBPMat get_original_LBP_feature(Mat img){  Mat result;  result.create(img.rows - 2, img.cols -2, img.type());  result.setTo(0);  for (int i = 1; i < img.rows - 1; i++){    for (int j = 1; j < img.cols -1; j++){      uchar center = img.at<uchar>(i, j);      uchar lbpcode = 0;      lbpcode |= (img.at<uchar>(i - 1, j - 1) >= center) << 7;      lbpcode |= (img.at<uchar>(i - 1, j) >= center) << 6;      lbpcode |= (img.at<uchar>(i - 1, j + 1) >= center) << 5;      lbpcode |= (img.at<uchar>(i, j -1) >= center) << 4;      lbpcode |= (img.at<uchar>(i, j + 1) >= center) << 3;      lbpcode |= (img.at<uchar>(i + 1, j - 1) >= center) << 2;      lbpcode |= (img.at<uchar>(i + 1, j) >= center) << 1;      lbpcode |= (img.at<uchar>(i + 1, j + 1) >= center) << 0;      result.at<uchar>(i - 1, j - 1) = lbpcode;    }  }  return result;}//Circular_LBP_featureMat get_circular_LBP_feature(Mat img, int radius, int neighbors){  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  //循环处理每个像素  for(int i=radius;i<img.rows-radius;i++)  {      for(int j=radius;j<img.cols-radius;j++)      {          //获得中心像素点的灰度值          uchar center = img.at<uchar>(i,j);          uchar lbpCode = 0;          for(int k=0;k<neighbors;k++)          {              //根据公式计算第k个采样点的坐标，这个地方可以优化，不必每次都进行计算radius*cos，radius*sin              float x = i + static_cast<float>(radius * \                  cos(2.0 * CV_PI * k / neighbors));              float y = j - static_cast<float>(radius * \                  sin(2.0 * CV_PI * k / neighbors));                //根据取整结果进行双线性插值，得到第k个采样点的灰度值                //1.分别对x，y进行上下取整                int x1 = static_cast<int>(floor(x));                int x2 = static_cast<int>(ceil(x));                int y1 = static_cast<int>(floor(y));                int y2 = static_cast<int>(ceil(y));                //将坐标映射到0-1之间                float tx = x - x1;                float ty = y - y1;                //根据0-1之间的x，y的权重计算公式计算权重                float w1 = (1-tx) * (1-ty);                float w2 =    tx  * (1-ty);                float w3 = (1-tx) *    ty;                float w4 =    tx  *    ty;                //3.根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at<uchar>(x1,y1) * w1 + img.at<uchar>(x1,y2) *w2 + img.at<uchar>(x2,y1) * w3 +img.at<uchar>(x2,y2) *w4;                //通过比较获得LBP值，并按顺序排列起来                lbpCode |= (neighbor>center) <<(neighbors-k-1);            }            result.at<uchar>(i-radius,j-radius) = lbpCode;        }    }  return result;}//Rotation_Invariant_LBP_featureMat get_rotation_invariant_LBP_feature(Mat img, int radius, int neighbors){  Mat result;  result.create(img.rows - radius * 2, img.cols - radius * 2, img.type());  result.setTo(0);  for(int k=0;k<neighbors;k++)    {        //计算采样点对于中心点坐标的偏移量rx，ry        float rx = static_cast<float>(radius * cos(2.0 * CV_PI * k / neighbors));        float ry = -static_cast<float>(radius * sin(2.0 * CV_PI * k / neighbors));        //为双线性插值做准备        //对采样点偏移量分别进行上下取整        int x1 = static_cast<int>(floor(rx));        int x2 = static_cast<int>(ceil(rx));        int y1 = static_cast<int>(floor(ry));        int y2 = static_cast<int>(ceil(ry));        //将坐标偏移量映射到0-1之间        float tx = rx - x1;        float ty = ry - y1;        //根据0-1之间的x，y的权重计算公式计算权重，权重与坐标具体位置无关，与坐标间的差值有关        float w1 = (1-tx) * (1-ty);        float w2 =    tx  * (1-ty);        float w3 = (1-tx) *    ty;        float w4 =    tx  *    ty;        //循环处理每个像素        for(int i=radius;i<img.rows-radius;i++)        {            for(int j=radius;j<img.cols-radius;j++)            {                //获得中心像素点的灰度值                uchar center = img.at<uchar>(i,j);                //根据双线性插值公式计算第k个采样点的灰度值                float neighbor = img.at<uchar>(i+x1,j+y1) * w1 + img.at<uchar>(i+x1,j+y2) *w2 + img.at<uchar>(i+x2,j+y1) * w3 +img.at<uchar>(i+x2,j+y2) *w4;                //LBP特征图像的每个邻居的LBP值累加，累加通过与操作完成，对应的LBP值通过移位取得                result.at<uchar>(i-radius,j-radius) |= (neighbor>center) <<(neighbors-k-1);            }        }    }    //进行旋转不变处理    for(int i=0;i<result.rows;i++)    {        for(int j=0;j<result.cols;j++)        {            uchar currentValue = result.at<uchar>(i,j);            uchar minValue = currentValue;            for(int k=1;k<neighbors;k++)        //循环左移            {                uchar temp = (currentValue>>(neighbors-k)) | (currentValue<<k);                if(temp < minValue)                {                    minValue = temp;                }            }            result.at<uchar>(i,j) = minValue;        }    }    return result;}int main(int argc, char* argv[]){  Mat src = imread(argv[1], 0);  Mat dst = get_original_LBP_feature(src);  Mat odst1 = get_circular_LBP_feature(src, 1, 8);  //Mat odst4 = get_circular_LBP_feature(src, 4, 8);  Mat rif8 = get_rotation_invariant_LBP_feature(src, 1, 8);  Mat rif6 = get_rotation_invariant_LBP_feature(src, 1, 6);  imshow("原始图片", src);  imshow("原始LBP", dst);  imshow("圆形LBP", odst1);  //imshow("圆形LBP4", odst4);  imshow("旋转不变LBP", rif8);  //imshow("旋转不变LBP6", rif6);  waitKey(0);  return 0;}</code></pre><h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><p>在OpenCV中，主要使用两种特征进行人脸检测，Haar特征和LBP特征，下面使用的是LBP特征。<br>实现人脸检测主要依赖于detectMultiScale()函数</p><pre class=" language-c++"><code class="language-c++">CV_WRAP virtual void detectMultiScale( const Mat& image,  CV_OUT vector<Rect>& objects,  double scaleFactor=1.1,  int minNeighbors=3, int flags=0,  Size minSize=Size(),  Size maxSize=Size() );</code></pre><p>各参数含义如下：<br><strong>const Mat&amp; image</strong>: 需要被检测的图像（灰度图）。<br><strong>vector<rect>&amp; objects</rect></strong>: 保存被检测出的人脸位置坐标序列。<br><strong>double scaleFactor</strong>: 每次图片缩放的比例。<br><strong>int minNeighbors</strong>: 每一个人脸至少要检测到多少次才算是真的人脸。<br><strong>doubleint flags</strong>： 决定是缩放分类器来检测，还是缩放图像。<br><strong>Size()</strong>: 表示人脸的最大最小尺寸。</p><p>具体实现代码如下:</p><pre class=" language-c++"><code class="language-c++">#include<opencv2/highgui/highgui.hpp>#include<opencv2/imgproc/imgproc.hpp>#include<opencv2/objdetect/objdetect.hpp>#include<iostream>#include<opencv2/core.hpp>using namespace std;using namespace cv;#define CV_COLOR_GREEN cv::Scalar(0, 255, 0)CascadeClassifier faceCascade;int main(int argc, char* argv[]){ Mat img; CascadeClassifier faceDetector("lbpcascade_frontalface.xml");//读取分类器 img = imread(argv[1]);  //读取检测的图片原图 vector<Rect> objects;  //存放检测的对象 faceDetector.detectMultiScale(img, objects);  //执行检测 for (int i = 0; i < objects.size(); i++) //遍历检测到的脸 {  rectangle(img, objects[i], CV_COLOR_RED);  //画出检测到的脸 } imshow("result", img);  //显示结果 waitKey(0); return 0;}</code></pre><p>检测结果:<br><img src="https://i.loli.net/2019/08/01/5d42b5d26727057681.png" alt><br><img src="https://i.loli.net/2019/08/01/5d42b5d26fea564434.png" alt><br><img src="https://i.loli.net/2019/08/01/5d42b5d2b360c81753.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day17</title>
      <link href="/2019/07/31/day17/"/>
      <url>/2019/07/31/day17/</url>
      
        <content type="html"><![CDATA[<h1 id="LBP算法"><a href="#LBP算法" class="headerlink" title="LBP算法"></a>LBP算法</h1><p>LBP（Local Binary Patterns，局部二值模式）是一种能够有效地度量和提取图像局部纹理信息的算子，具有旋转不变性和灰度不变性等显著的优点。它是人脸识别中一种提取特征的重要方法，具有对光照不敏感的特性，但是对姿态和表情的鲁棒性不强。</p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>纹理是由于物体表面物理属性不同所引起的能够表示某个特定表面特征的灰度或颜色信息。纹理反映了图像灰度模式的空间分布，包含了图像的表面信息及其周围环境的关系。</p><h2 id="基本的LBP算子"><a href="#基本的LBP算子" class="headerlink" title="基本的LBP算子"></a>基本的LBP算子</h2><p>局部二值模式是一种灰度范围内的纹理描述方式。最初的LBP算子定义在一个3×3的窗口，以窗口中心像素点为阈值，将相邻的像素的灰度值与其进行比较，若周围的像素值大于中心点的值，则将该像素位置标记为1,否则为0.这样一个3×3邻域内的8个点可产生一个8-bit的无符号数，再按其位置赋予不同权重求和得一整数，即可得到该窗口的 <strong>LBP</strong> 值，并用这个数反映该区域的纹理信息。<br>对比度分量C是邻域中所有大于和等于中心点像素的均值与所有小于中心点像素的均值之差。<br><img src="https://i.loli.net/2019/07/31/5d415779ca87257597.jpg" alt></p><p>基本的LBP算子最大的缺陷是只覆盖了一个固定半径范围内的小区域，改进的LBP算子，将3×3邻域扩展到任意邻域，用圆形邻域代替了正方形邻域，该算子允许在半径为R的圆形邻域内有任意多个像素点。</p><ul><li>一个局部区域的纹理分布可假设为局部区域内像素灰度的联合分布密度<br>$$T = t(g_c,g_0, ….,g_{p-1})$$<br>$g_c$表示局部区域的中心点的灰度值,$g_p(p=0,1,…,p)$对应中心点周围等距分布的P个点</li><li>采用 <strong>双线性插算法</strong> 对没有完全落在像素位置的点计算灰度值。邻域内的$g_p$点的坐标可以表示为:<br>$$(x_p,y_p) = (x_c + Rcos(\frac{2\pi}{P}),y_c - Rsin(\frac{2\pi}{P}))$$<br>$(x_c,y_c)$表示中心点的坐标</li><li>将中心点$g_c$的值从邻域像素的灰度值$g_p$中减去，则局部区域的纹理可以用中心点和中心点与周边像素值之差的联合分布来表示:<br>$$T = t(g_c,g_0-g_c,….,g_{p-1}-g_c)$$</li><li>假设中心像素点$g_c$与周边点像素$g_p$的差值$g_p-g_c(p=0,1,…P)$独立于中心点$g_c$，则<br>$$T\approx t(g_c)(g_0-g_c,…,g_{p-1}-g_c)$$</li><li>实际上，$t(g_c)$只是描述了整个图像的亮度分布情况，而和图像的局部纹理无关，它不能为纹理分析提供任何有价值的信息<br>$$T\approx t(g_0-g_c,…,g_{p-1}-g_c)$$</li><li>差值的联合分布具有灰度平移不变性，即邻域中所有P+1个像素同时加上或减去某个值，其表征的纹理不变。</li><li>为了达到尺度不变的目的，只考虑差值的符号<br>$$T\approx t(s(g_0-g_c),…,s(g_p-g_c))$$</li></ul><p>$$s(x)=\begin{cases}<br>1 , \quad &amp;x &gt; 0  \\\<br>0 , &amp;x \geqslant 0<br>\end{cases}<br>$$</p><p>上式得到了一个8位的二进制数，再对像素按不同位置用$2^p$进行加权求和，这样得到了一个与邻域像素点相关的唯一的 <strong>LBP</strong> 值，这个值称为 <strong>模式</strong>。这个值描述的是以$(x_c,y_c)$为中心的局部区域的纹理，可以表示为<br>$$LBP(x_c,y_c) = \sum_{p=0}^{P-1}s(g_p - g_c)2^P$$<br>上式意味着差值的符号转化成一个P-bit的二进制数，进而转化成为一个取值范围为0-$2^p$的离散的LBP值，或者说转化为一种LBP模式。</p><ul><li>局部区域的灰度分布或纹理，可以用这个LBP值或LBP模式近似描述为:<br>$$T\approx t(LBP(x_c,y_c))$$<br>LBP算子对于任何单调的灰度变化具有鲁棒性，用符号$LBP_P^R$表示在半径为R的圆形邻域内有P个像素点$g_p(p=0,1,…,P)$的LBP算子<br><img src="https://i.loli.net/2019/07/31/5d415779b84ac47631.jpg" alt></li></ul><h2 id="LBP等价模式"><a href="#LBP等价模式" class="headerlink" title="LBP等价模式"></a>LBP等价模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当某个局部二进制模式所对应的循环二进制数从０到１或从１到０最多有两次跳变时，该局部二进制模式所对应的二进制就称为一个等价模式类。比如00000000,11111111,10001111都是等价类。</p><h3 id="检验方法"><a href="#检验方法" class="headerlink" title="检验方法"></a>检验方法</h3><p>检验某种模式是否是等价模式的简单办法是将其和其移动一位后的二进制模式按位相减的绝对值求和<br>$$U(G_p) = |s(g_{p-1}-g_c)-s(g_0-g_c)|+\sum_{p=1}^{P-1}|s(g_p-g_c)-s(g_{p-1}-g_c)$$<br>若某种模式计算得到的 $U(G_p)$小于或等于２，则将其归于等价模式<br><img src="https://i.loli.net/2019/07/31/5d415779c949196019.jpg" alt></p><h2 id="旋转不变的LBP算子"><a href="#旋转不变的LBP算子" class="headerlink" title="旋转不变的LBP算子"></a>旋转不变的LBP算子</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>不断旋转圆形邻域得到一系列的初始定义的LBP值，取其最小值作为该邻域的LBP值，用公式表示为:<br>$$LBP_{P,R}^{ri} = min(ROR(LBP_{P,R}^{ri},i)|i=0,1,…,P-1)$$<br>$LBP^{ri}$表示旋转不变的LBP算子，$ROR(x,i)$函数为旋转函数，表示将x循环右移i(i&lt;P)位。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>对于图像旋转，表现的更为鲁棒，并且LBP模式的种类进一步减少，使纹理识别更加容易。</li><li>丢失了方向信息<br><img src="https://i.loli.net/2019/07/31/5d415779b8fed91298.jpg" alt></li></ul><h2 id="旋转不变的的等价模式"><a href="#旋转不变的的等价模式" class="headerlink" title="旋转不变的的等价模式"></a>旋转不变的的等价模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将等价模式类进行旋转得到旋转不变的等价模式</p><p>$$LBP_{P,R}^{riu2} = \begin{cases}<br>\sum_{P=0}^{P-1}s(g_p-g_c), &amp; U(G_p) \leq 2 \\\<br>P + 1, &amp; U(G_p) &gt;2<br>\end{cases}<br>$$</p><p>其中$U(G_p)$表示0到1或1到0跳变的次数，$LBP^{riu2}$被称为旋转不变的等价模式</p><h2 id="几种LBP算子的维数比较"><a href="#几种LBP算子的维数比较" class="headerlink" title="几种LBP算子的维数比较"></a>几种LBP算子的维数比较</h2><table><thead><tr><th align="center">LBP</th><th align="center">原始模式数</th><th align="center">等价模式</th><th align="center">旋转不变等价模式</th></tr></thead><tbody><tr><td align="center">$LBP_P^R$</td><td align="center">$2^P$</td><td align="center">$P(P-1) + 2$</td><td align="center">$P+1$</td></tr><tr><td align="center">$LBP_8^1$</td><td align="center">256</td><td align="center">58(+1)</td><td align="center">9</td></tr><tr><td align="center">$LBP_{16}^2$</td><td align="center">65536</td><td align="center">242(+1)</td><td align="center">17</td></tr><tr><td align="center">$LBP_{24}^3$</td><td align="center">16777216</td><td align="center">554(+1)</td><td align="center">25</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day16</title>
      <link href="/2019/07/30/day16/"/>
      <url>/2019/07/30/day16/</url>
      
        <content type="html"><![CDATA[<h1 id="装环境，转战Ubuntu"><a href="#装环境，转战Ubuntu" class="headerlink" title="装环境，转战Ubuntu"></a>装环境，转战Ubuntu</h1><p>有空写教程<br><img src="https://i.loli.net/2019/07/31/5d41343d2fc3746297.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day15</title>
      <link href="/2019/07/29/day15/"/>
      <url>/2019/07/29/day15/</url>
      
        <content type="html"><![CDATA[<h1 id="High-quality-ellipse-detection"><a href="#High-quality-ellipse-detection" class="headerlink" title="High-quality-ellipse-detection"></a>High-quality-ellipse-detection</h1><p><a href="https://github.com/AlanLuSun/High-quality-ellipse-detection" target="_blank" rel="noopener">High-quality-ellipse-detection　Github传送门</a></p><p>个人环境:Matlab 2019a、VS2017、Opencv3.4.4，64位Windows操作系统</p><h2 id="OpenCV环境配置请看这篇"><a href="#OpenCV环境配置请看这篇" class="headerlink" title="OpenCV环境配置请看这篇"></a>OpenCV环境配置请看这篇</h2><p><a href="https://kevinnnm.github.io/2019/07/25/OpenCV%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E7%AF%87/">OpenCV入坑指南:环境搭建篇</a></p><h2 id="MatLab和C-混合编程环境配置"><a href="#MatLab和C-混合编程环境配置" class="headerlink" title="MatLab和C++混合编程环境配置"></a>MatLab和C++混合编程环境配置</h2><p>Matlab的安装这里不再说    </p><ol><li>在命令行里输入 <code>mex -setup</code>，选择vs就行了</li><li>执行 <code>mex -setup C++</code>完成配置<br><img src="https://i.loli.net/2019/07/29/5d3ea6561215b10575.png" alt><br><img src="https://i.loli.net/2019/07/29/5d3eaa19b300f42041.png" alt></li></ol><h2 id="下载Github文件"><a href="#下载Github文件" class="headerlink" title="下载Github文件"></a>下载Github文件</h2><p>download Zip即可</p><h2 id="导入依赖文件"><a href="#导入依赖文件" class="headerlink" title="导入依赖文件"></a>导入依赖文件</h2><p>将 <strong>D:\OpenCV\opencv\build\x64\vc15\lib</strong>下的 <strong>opencv_world344.lib</strong>文件复制到你的Matlab安装路径下的 <strong>microsoft</strong>文件夹下,我的是 <strong>D:\MATLAB\R2019a\extern\lib\win64\microsoft</strong></p><p><img src="https://i.loli.net/2019/07/29/5d3ea6564f0b271051.png" alt><br><img src="https://i.loli.net/2019/07/29/5d3ea6564ed8016435.png" alt></p><h2 id="在Matlab中导入文件"><a href="#在Matlab中导入文件" class="headerlink" title="在Matlab中导入文件"></a>在Matlab中导入文件</h2><h2 id="在命令行执行以下命令"><a href="#在命令行执行以下命令" class="headerlink" title="在命令行执行以下命令"></a>在命令行执行以下命令</h2><p>注意作者的命令为:</p><pre><code>mex generateEllipseCandidates.cpp -IF:\OpenCV\opencv2.4.9\build\include -IF:\OpenCV\opencv2.4.9\build\include\opencv -IF:\OpenCV\opencv2.4.9\build\include\opencv2 -LF:\OpenCV\opencv2.4.9\build\x64\vc11\lib -IF:\Matlab\settlein\extern\include -LF:\Matlab\settlein\extern\lib\win64\microsoft -lopencv_core249 -lopencv_highgui249 -lopencv_imgproc249 -llibmwlapack.lib</code></pre><p>把OpenCV和Matlab的相关文件的路径改成你的安装路径<br>我这里版本号为OpenCV3.4.4,安装路径如下,<br><img src="https://i.loli.net/2019/07/29/5d3ea6561fbd474647.png" alt><br>故修改为<code>D:\OpenCV\opencv\build...</code>,<br>由于OpenCV3.4.4只有 <strong>opencv_world344.lib</strong> 这一个lib文件，故将 <code>LF:\Matlab\settlein\extern\lib\win64\microsoft -lopencv_core249 -lopencv_highgui249 -lopencv_imgproc249 -llibmwlapack.lib</code>　修改为 <code>LD:\Matlab\R2019a\extern\lib\win64\microsoft -lopencv_world344 -llibmwlapack.lib</code></p><p>完整的命令为:</p><pre><code>mex generateEllipseCandidates.cpp -ID:\OpenCV\opencv\build\include -ID:\OpenCV\opencv\build\include\opencv -ID:\OpenCV\opencv\build\include\opencv2 -LD:\OpenCV\opencv\build\x64\vc15\lib -ID:\Matlab\R2019a\include -LD:\Matlab\R2019a\extern\lib\win64\microsoft -lopencv_world344 -llibmwlapack.lib</code></pre><p><img src="https://i.loli.net/2019/07/29/5d3ea65639bdf67747.png" alt><br>编译成功之后生成<code>generateEllipseCandidates.mexw64</code>文件<br><img src="https://i.loli.net/2019/07/29/5d3ea6564e0c183020.png" alt><br>之后再运行<code>LCS_ellipse.m</code><br><img src="https://i.loli.net/2019/07/29/5d3ea657cb9e659639.png" alt="7.png"></p><p>##　报错解决办法</p><ol><li>如图<br><img src="https://i.loli.net/2019/07/29/5d3eabf1c942443319.png" alt><br>在.cpp文件中添加<pre class=" language-C++"><code class="language-C++">using namespace std</code></pre></li><li>如图</li></ol><p><img src="https://i.loli.net/2019/07/29/5d3eabf1d457769964.png" alt><br>缺少lib文件，检查一下是不是配置出错了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day14</title>
      <link href="/2019/07/28/day14/"/>
      <url>/2019/07/28/day14/</url>
      
        <content type="html"><![CDATA[<h1 id="High-quality-ellipse-detection"><a href="#High-quality-ellipse-detection" class="headerlink" title="High-quality-ellipse-detection"></a>High-quality-ellipse-detection</h1><p>高精度椭圆检测<br>参考<a href="https://github.com/AlanLuSun/High-quality-ellipse-detection" target="_blank" rel="noopener">High-quality-ellipse-detection</a></p><p>关于椭圆检测的部分，实在是看不懂，我只做了得到椭圆参数绘制椭圆的部分</p><h2 id="OpenCV椭圆绘制"><a href="#OpenCV椭圆绘制" class="headerlink" title="OpenCV椭圆绘制"></a>OpenCV椭圆绘制</h2><h3 id="ellipse函数"><a href="#ellipse函数" class="headerlink" title="ellipse函数"></a>ellipse函数</h3><p>语法</p><pre><code>void cvEllipse( CvArr* img, CvPoint center, CvSize axes, double angle,                double start_angle, double end_angle, CvScalar color,                int thickness=1, int line_type=8, int shift=0 );</code></pre><p>参数:<br>img:图像。<br>center:椭圆圆心坐标。<br>axes:轴的长度。<br>angle:偏转的角度。<br>start_angle:圆弧起始角的角度。<br>end_angle:圆弧终结角的角度。<br>color:线条的颜色。<br>thickness:线条的粗细程度。<br>line_type:线条的类型,见CVLINE的描述。<br>shift:圆心坐标点和数轴的精度。    </p><p>C++代码实现</p><pre class=" language-C++"><code class="language-C++">#include<opencv2/opencv.hpp>#include<opencv2/core/core.hpp> // 核心组件#include<opencv2/highgui/highgui.hpp>  // GUI#include<opencv2/imgproc/imgproc.hpp>  // 图像处理using namespace cv;using namespace std;// 定义存储椭圆参数的数据结构struct Ellipse {    int x0, y0, a, b;    double alpha;};int drawEllipse(Ellipse ellipses_para, Mat im);int drawEllipse(Ellipse ellipses_para, Mat im) {// Draw Ellipse after detection//x0 - x coordinate of the center of the ellipse//y0 - y coordinate of the center of the ellipse//a - length of semimajor axis//b - length of semiminor axis//alpha - angle of orientation of semimajor axis    if (im.empty()) {        printf("imread error!");        return -1;    }    int x0, y0, a, b;    double alpha;    int thickness = 3;    int lineType = 8;    x0 = ellipses_para.x0;    y0 = ellipses_para.y0;    a = ellipses_para.a;    b = ellipses_para.b;    alpha = ellipses_para.alpha;    ellipse(im, Point(x0, y0), Size(a, b), alpha, 0, 360, Scalar(255, 255, 0), thickness, lineType);    imshow("原图", im);    waitKey();}int main() {    Ellipse ellipses_para;    Mat im = imread("11.bmp");    /*test        ellipses_para.x0 = 100;    ellipses_para.y0 = 100;    ellipses_para.a = 90;    ellipses_para.b = 60;    ellipses_para.alpha = 80.0;*/    drawEllipse(ellipses_para, im);    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day13</title>
      <link href="/2019/07/27/day13/"/>
      <url>/2019/07/27/day13/</url>
      
        <content type="html"><![CDATA[<h1 id="边缘检测之梯度详解"><a href="#边缘检测之梯度详解" class="headerlink" title="边缘检测之梯度详解"></a>边缘检测之梯度详解</h1><p>梯度的概念和性质在边缘检测中比较重要，所以我又仔细看了一下相关知识点，总结一下。</p><h2 id="梯度概念"><a href="#梯度概念" class="headerlink" title="梯度概念"></a>梯度概念</h2><p>梯度是一个可以确定图像f的(x,y)位置处的边缘方向和强度的工具，用 $\triangledown f$来表示，用 <strong>向量</strong>来定义</p><p>$$\triangledown f = \begin{bmatrix} g_x \\ g_y \\ \end{bmatrix} = \begin{bmatrix} \frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial x} \end{bmatrix}$$</p><h2 id="梯度性质"><a href="#梯度性质" class="headerlink" title="梯度性质"></a>梯度性质</h2><ol><li><p>梯度向量大小。<br>$\triangledown f$的大小为M(x,y)<br>$$\triangledown f = mag(\triangledown f)=[g_x^2+g_y^2]^{<br>1/2}= [(\partial f/\partial x)^2+(\partial f/\partial y)^2]^{1/2}$$<br>这是梯度向量方向变化率的值。其中$g_x$,$g_y$和M(x,y)都是和原图像大小相同的图像。称M(x,y)为梯度图像。</p></li><li><p>梯度向量的方向<br>$$\alpha (x,y) = tan^{-1}(\frac{g_x}{g_y})$$<br>同理，　$\alpha(x,y)$也是由$g_x$和$g_y$阵列创建的尺寸相同的图像。<br>任意点(x,y)处的一个边缘的方向与该点处梯度向量的方向$\alpha(x,y)$正交。<br>梯度向量有时也称为边缘法线</p></li><li><p>梯度指出f在(x,y)处的最大变化率的方向</p></li></ol><h2 id="梯度算子"><a href="#梯度算子" class="headerlink" title="梯度算子"></a>梯度算子</h2><h3 id="一维模板"><a href="#一维模板" class="headerlink" title="一维模板"></a>一维模板</h3><p>$$g_x = \frac{\partial f(x,y)}{\partial x} = f(x+1,y) - f(x,y)$$<br>和<br>$$g_y = \frac{\partial f(x,y)}{\partial y} = f(x,y+1)-f(x,y)$$</p><h3 id="二维模板"><a href="#二维模板" class="headerlink" title="二维模板"></a>二维模板</h3><p>罗伯特交叉梯度算子(Roberts),ROberts算子以求对角像素之差为基础:<br>$$g_x = \frac{\partial f}{\partial x} = (z_9 - z_5)$$<br>和<br>$$g_y = \frac{\partial f}{\partial y} = (z_8 - z_6)$$</p><h3 id="3×3模板"><a href="#3×3模板" class="headerlink" title="3×3模板"></a>3×3模板</h3><h4 id="Prewitt算子"><a href="#Prewitt算子" class="headerlink" title="Prewitt算子"></a>Prewitt算子</h4><p>$$g_x = (z_7 + z_8 + z_9)-(z_1 + z_2 + z_3)$$<br>和<br>$$g_y = (z_3 + z_6 + z_9) - (z_1 + z_4 + z_7)$$</p><h4 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h4><p>$$g_x = (z_7 + 2z_8 + z_9)-(z_1 +2 z_2 + z_3)$$<br>和<br>$$g_y = (z_3 + 2z_6 + z_9) - (z_1 +2 z_4 + z_7)$$</p><p>在中心位置处使用2可以平滑图像</p><p>注意:所有模板中的系数之和为0，这意味着恒定灰度的响应为0.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day12</title>
      <link href="/2019/07/26/day12/"/>
      <url>/2019/07/26/day12/</url>
      
        <content type="html"><![CDATA[<h1 id="基于霍夫变换的圆形检测"><a href="#基于霍夫变换的圆形检测" class="headerlink" title="基于霍夫变换的圆形检测"></a>基于霍夫变换的圆形检测</h1><h2 id="霍夫变换的原理"><a href="#霍夫变换的原理" class="headerlink" title="霍夫变换的原理"></a>霍夫变换的原理</h2><p>Hough 变换就是利用图像全局特征将边缘像素连接起来组成区域封闭边界，它将图像空间转换到参数空间，在参数空间对点进行描述，达到检测图像边缘的目的。该方法把所有可能落在边缘上的点进行统计计算，根据对数据的统计结果确定属于边缘的程度。Hough 变换的实质就是对图像进行坐标变换，把平面坐标变换为参数坐标，使变换的结果更易识别和检测。</p><hr><h3 id="对霍夫变换圆形检测的原理的理解"><a href="#对霍夫变换圆形检测的原理的理解" class="headerlink" title="对霍夫变换圆形检测的原理的理解:"></a>对霍夫变换圆形检测的原理的理解:</h3><p>已知圆的一般方程为:<br>$$(x-a)^2 + (y-b)^2 = r^2 $$<br>其中(a,b)代表圆心，r是圆的半径<br>依旧是把图像空间转换成参数空间，这里是将X-Y平面转化成a-b-r参数空间，则在图像空间中的一个过(x,y)点的圆，对应参数空间中高度变化的三维锥面。<br><img src="https://i.loli.net/2019/07/26/5d3ab8c50fc2a28962.jpg" alt><br>同理，过图像空间的任意一点的圆都对应于参数空间的一个三维锥面，因此，过图像空间上同一圆的点，对应的参数空间中的三维锥面，在r平面必然相交于一点(a,b,r)，这样通过这一点就可以得到一个圆的参数。<br><img src="https://i.loli.net/2019/07/26/5d3ab8c4d635d79647.jpg" alt><br>这里霍夫变换的圆检测就是在这三个参数组成的三维空间内进行的<br>换一种理解思路:在笛卡尔坐标下的圆的方程已给出，在极坐标系下，假设圆心为$(x_0,y_0)$,圆上的点可以表示为:<br>$$x = x_0 + rcos\theta, y = y_0 + rsin\theta$$<br>对于一个圆，假如中心像素点$(x_0,y_0)$，半径r已知，那么旋转360°，圆上的所有点就可以求得。同样，假如圆上的所有点，半径r已知，旋转360°，则会得到一个累加的极值点，那么这个点就是圆心了。</p><hr><p>理论上霍夫变换可以检测任何形状，但复杂的形状需要的参数就多，霍夫空间的维数就多，因此在程序实现上所需的内存空间以及运行效率上都不利于把标准霍夫变换应用于实际复杂图形的检测中。所以一些改进的霍夫变换就相继提出，它们的基本原理就是尽可能减小霍夫空间的维数。</p><p>在OpenCV中，HoughCircles函数实现了圆形检测，它使用的算法也是改进的霍夫变换——2-1霍夫变换（21HT）。也就是把霍夫变换分为两个阶段，从而减小了霍夫空间的维数。第一阶段用于检测圆心，第二阶段从圆心推导出圆半径。<br>检测圆心的原理是圆心是它所在圆周所有法线的交汇处，因此只要找到这个交点，即可确定圆心，该方法所用的霍夫空间与图像空间的性质相同，因此它仅仅是二维空间。检测圆半径的方法是从圆心到圆周上的任意一点的距离（即半径）是相同，只要确定一个阈值，只要相同距离的数量大于该阈值，我们就认为该距离就是该圆心所对应的圆半径，该方法只需要计算半径直方图，不使用霍夫空间。圆和半径知道了，圆自然就能求得。</p><p>21HT的具体步骤:<br>第一阶段：检测圆心</p><p>1.1、对输入图像边缘检测；</p><p>1.2、计算图形的梯度，并确定圆周线，其中圆周的梯度就是它的法线；</p><p>1.3、在二维霍夫空间内，绘出所有图形的梯度直线，某坐标点上累加和的值越大，说明在该点上直线相交的次数越多，也就是越有可能是圆心；</p><p>1.4、在霍夫空间的4邻域内进行非最大值抑制；</p><p>1.5、设定一个阈值，霍夫空间内累加和大于该阈值的点就对应于圆心。</p><p>第二阶段：检测圆半径</p><p>2.1、计算某一个圆心到所有圆周线的距离，这些距离中就有该圆心所对应的圆的半径的值，这些半径值当然是相等的，并且这些圆半径的数量要远远大于其他距离值相等的数量；</p><p>2.2、设定两个阈值，定义为最大半径和最小半径，保留距离在这两个半径之间的值，这意味着我们检测的圆不能太大，也不能太小；</p><p>2.3、对保留下来的距离进行排序；</p><p>2.4、找到距离相同的那些值，并计算相同值的数量；</p><p>2.5、设定一个阈值，只有相同值的数量大于该阈值，才认为该值是该圆心对应的圆半径；</p><p>2.6、对每一个圆心，完成上面的2.1～2.5步骤，得到所有的圆半径。</p><p>HoughCircles函数的原型为：<br>void HoughCircles(InputArray image,OutputArray circles, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0,int maxRadius=0 )<br>image为输入图像，要求是灰度图像<br>circles为输出圆向量，每个向量包括三个浮点型的元素——圆心横坐标，圆心纵坐标和圆半径<br>method为使用霍夫变换圆检测的算法，Opencv2.4.9只实现了2-1霍夫变换，它的参数是CV_HOUGH_GRADIENT<br>dp为第一阶段所使用的霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2时霍夫空间是输入图像空间的一半，以此类推<br>minDist为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认为它们是同一个圆心<br>param1为边缘检测时使用Canny算子的高阈值<br>param2为步骤1.5和步骤2.5中所共有的阈值<br>minRadius和maxRadius为所检测到的圆半径的最小值和最大值</p><h3 id="霍夫变换椭圆检测的实现"><a href="#霍夫变换椭圆检测的实现" class="headerlink" title="霍夫变换椭圆检测的实现"></a>霍夫变换椭圆检测的实现</h3><p>运行环境: vs2017 + Opencv3.4<br>由于HoughCircles函数是调用Canny函数进行边缘检测，OpenCV的Canny函数不包括平滑滤波，所以先对原图进行滤波处理，在这里使用的是高斯模糊</p><pre><code>#include &quot;opencv2/core/core.hpp&quot;#include &quot;opencv2/highgui/highgui.hpp&quot;#include &quot;opencv2/imgproc/imgproc.hpp&quot;#include &lt;iostream&gt;using namespace cv;using namespace std;int main( int argc, char** argv ){     Mat src, gray;    src=imread(&quot;coins.jpg&quot;);    if( !src.data )          return -1;      cvtColor( src, gray, CV_BGR2GRAY );    //高斯模糊平滑    GaussianBlur( gray, gray, Size(9, 9), 2, 2 );    vector&lt;Vec3f&gt; circles;    //霍夫变换    HoughCircles( gray, circles, CV_HOUGH_GRADIENT, 1, gray.rows/20, 100, 60, 0, 0 );    //在原图中画出圆心和圆    for( size_t i = 0; i &lt; circles.size(); i++ )    {        //提取出圆心坐标        Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));        //提取出圆半径        int radius = cvRound(circles[i][2]);        //圆心        circle( src, center, 3, Scalar(0,255,0), -1, 8, 0 );        //圆        circle( src, center, radius, Scalar(0,0,255), 3, 8, 0 );   }    imshow( &quot;霍夫变换检测圆图&quot;, src );    waitKey(0);    return 0;}</code></pre><p>结果:<br><img src="https://i.loli.net/2019/07/26/5d3abf54a4c3b88169.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV入坑指南:环境搭建篇</title>
      <link href="/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/"/>
      <url>/2019/07/25/opencv-ru-keng-zhi-nan-huan-jing-da-jian-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h2 id="什么是OpenCV"><a href="#什么是OpenCV" class="headerlink" title="什么是OpenCV"></a>什么是OpenCV</h2><p><a href="https://opencv.org/about/" target="_blank" rel="noopener">OpenCv</a>是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。<br>OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。该库也有大量的Python、Java and MATLAB/OCTAVE（版本2.5）的接口。这些语言的API接口函数可以通过在线文档获得。如今也提供对于C#、Ch、Ruby,GO的支持。</p><h2 id="OpenCV可以来做什么"><a href="#OpenCV可以来做什么" class="headerlink" title="OpenCV可以来做什么"></a>OpenCV可以来做什么</h2><p>使用OpenCV，你几乎可以做任何你能够想到的计算机视觉任务。    </p><ol><li><p>内置数据结构和输入/输出(In-build data structures and input/output)</p></li><li><p>图像处理操作(Image processing operations)</p></li><li><p>构建图形用户界面(Build GUI)</p></li><li><p>视频分析(Video analysis)</p></li><li><p>3D重建(3D reconstruction)</p></li><li><p>特征提取(Feature extraction)</p></li><li><p>目标检测(Object detection)</p></li><li><p>机器学习(Machine learning)</p></li><li><p>计算摄影(Computational photography)</p></li><li><p>形状分析(Shape analysis)</p></li><li><p>光流算法(Optical flow algorithms)</p></li><li><p>人脸和目标识别(Face and object recognition)</p></li><li><p>表面匹配(Surface matching)</p></li><li><p>文本检测和识别(Text detection and recognition)</p></li></ol><hr><h1 id="Microsoft-Visual-Studio"><a href="#Microsoft-Visual-Studio" class="headerlink" title="Microsoft Visual Studio"></a>Microsoft Visual Studio</h1><p>宇宙最强IDE(逃),不多说了</p><hr><h1 id="OpenCV-VS学习-装×-环境搭建"><a href="#OpenCV-VS学习-装×-环境搭建" class="headerlink" title="OpenCV + VS学习(装×)环境搭建"></a>OpenCV + VS学习(装×)环境搭建</h1><p>工欲善其事，必先利其器。当你准备好入坑OpenCV时，你首先要把学习环境搭建起来，光是这一关不知道劝退了多少人，我在搭建的过程中也是踩了很多坑，也遇到了各种各样刁钻的问题，现在总结一下，给自己踩过的雷做一下记录，也希望能够帮到即将入坑的你们。</p><h2 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h2><p>为什么把这个放到第一个呢？因为这是我遇到并纠结了一天的问题！我在网上查找教程的时候很多人都没有标注这个问题，当然也是自己蠢，在所有的配置都配置完成之后，还是不能正常跑程序，又重新安装重新配置，反复好几次，都快怀疑人生了，最后才发现是版本号不对。废话不多说，下面是OpenCV版本和VS版本的对应表，选择的时候一定要擦亮眼睛。我选择的环境是VS2017+OpenCV3.4.4    </p><table><thead><tr><th align="center">Visual Studio 版本</th><th align="center">VC 版本</th></tr></thead><tbody><tr><td align="center">VS 6</td><td align="center">vc6</td></tr><tr><td align="center">VS 2003</td><td align="center">vc7</td></tr><tr><td align="center">VS 2005</td><td align="center">vc8</td></tr><tr><td align="center">VS 2008</td><td align="center">vc9</td></tr><tr><td align="center">VS 2010</td><td align="center">vc10</td></tr><tr><td align="center">VS 2013</td><td align="center">vc12</td></tr><tr><td align="center">VS 2015</td><td align="center">vc14</td></tr><tr><td align="center">VS 2017</td><td align="center">vc15</td></tr></tbody></table><p>OpenCV对VC版本的支持情况(不全)</p><table><thead><tr><th align="center">OpenCV 2.4.10</th><th align="center">vc10、vc11、vc12</th></tr></thead><tbody><tr><td align="center">OpenCV 2.4.13</td><td align="center">vc11、vc12</td></tr><tr><td align="center">OpenCV 3.4.0</td><td align="center">vc14、vc15</td></tr><tr><td align="center">OpenCv 3.4.1</td><td align="center">vc14、vc15</td></tr></tbody></table><h2 id="VS2017安装"><a href="#VS2017安装" class="headerlink" title="VS2017安装"></a>VS2017安装</h2><p>我的VS安装的时间太久了，网上教程一大堆，给你们挑一篇吧，这里就不再多说了</p><h2 id="OpenCV3-4-4下载与安装"><a href="#OpenCV3-4-4下载与安装" class="headerlink" title="OpenCV3.4.4下载与安装"></a>OpenCV3.4.4下载与安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ol><li>官网下载<br>OpenCV官网给我们提供了下载，不过下载速度嘛～自求多福<br><a href="https://opencv.org/releases/" target="_blank" rel="noopener">OpenCV下载</a>,里面有各个版本可以选择</li><li>OpenCV下载驿站<br><a href="https://blog.csdn.net/oMoDao1/article/details/80276834" target="_blank" rel="noopener">OpenCV各版本汇总下载</a><br>感谢这位大哥的总结</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>找一个你能记住名字的路径安装进去就OK了，一定要记住这个路径，非常重要<br><img src="https://i.loli.net/2019/07/27/5d3c0e0f7a6db16095.png" alt></p><h2 id="系统环境变量配置"><a href="#系统环境变量配置" class="headerlink" title="系统环境变量配置"></a>系统环境变量配置</h2><ol><li>找到此电脑</li><li>依次找到 属性-&gt;高级-&gt;环境变量,找到系统变量里的Path，双击进去编辑，如图所示，添加的路径 <strong>“D:\OpenCV\opencv\bulid\x64\vc15\bin”</strong>,把”D:\OpenCV\”替换成你的安装路径即可</li></ol><p><img src="https://i.loli.net/2019/07/27/5d3c0e0f9cd5286868.png" alt><br><img src="https://i.loli.net/2019/07/27/5d3c0e0fa09f948672.png" alt><br><img src="https://i.loli.net/2019/07/27/5d3c0e0fa634780591.png" alt><br><img src="https://i.loli.net/2019/07/27/5d3c0e0fa37ce25025.png" alt></p><p>到这就完成了系统环境的配置了</p><h2 id="一些文件的配置"><a href="#一些文件的配置" class="headerlink" title="一些文件的配置"></a>一些文件的配置</h2><p>这一步的目的是为了解决以后可能会出现的关于缺少.dll的问题</p><p>将 <strong>“D:\OpenCV\opencv\bulid\x64\vc15\bin”</strong> 里面的三个 <strong>.dll</strong> 文件复制到 <strong>C:\Windows“</strong> 目录下的 <strong>System32</strong>和 <strong>SysWOW64</strong>目录下</p><p><img src="https://i.loli.net/2019/07/28/5d3d5857adbe920715.png" alt><br><img src="https://i.loli.net/2019/07/28/5d3d5857bd82f79652.png" alt></p><h2 id="VS2017配置"><a href="#VS2017配置" class="headerlink" title="VS2017配置"></a>VS2017配置</h2><ol><li>新建一个空项目</li><li>进入属性管理器  视图-&gt;其他窗口-&gt;属性管理器<br><img src="https://i.loli.net/2019/07/27/5d3c156f6359d16629.png" alt></li><li>选择Debug | x64 的 Microsoft.Cpp.x64.user<br><img src="https://i.loli.net/2019/07/27/5d3c156ecb8ad31557.png" alt="8.png"></li><li>选择VC++目录，对包含目录和库目录进行配置<br><img src="https://i.loli.net/2019/07/27/5d3c156f2e22b74192.png" alt><ul><li>在包含目录里添加 <strong>D:\OpenCV\opencv\bulid\include</strong>,<strong>D:\OpenCV\opencv\bulid\include\opencv</strong>,<strong>D:\OpenCV\opencv\bulid\include\opencv2</strong><br><img src="https://i.loli.net/2019/07/27/5d3c156f2132f35424.png" alt></li><li>在库目录里添加 <strong>D:\OpenCV\opencv\bulid\x64\vc15\lib</strong><br><img src="https://i.loli.net/2019/07/27/5d3c156f492f430904.png" alt></li></ul></li><li>选择 链接器-&gt;输入-&gt;附加依赖项,<br><img src="https://i.loli.net/2019/07/27/5d3c156f13aac74119.png" alt="12.png"><br>在里面添加 <strong>opencv_world344d.lib</strong>，这个lib文件根据你的OpenCV版本号灵活变动<br><img src="https://i.loli.net/2019/07/27/5d3c156f0828190561.png" alt></li><li>点击应用，确定即可<br>到这里，OpenCV的所有配置工作已经完成了，要注意的是解决方案那一栏要换成x64(因为我们一直在配置的就是x64)<br><img src="https://i.loli.net/2019/07/27/5d3c156ee8b6668598.png" alt><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>这是一段读取并显示本地图片的代码，测试一下你的OpenCV环境是否配置好</li></ol><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/core/core.hpp></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/highgui/highgui.hpp></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Mat img <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"1.bmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">namedWindow</span><span class="token punctuation">(</span><span class="token string">"图片"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"图片"</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：<br><img src="https://i.loli.net/2019/07/27/5d3c15857414f57549.png" alt></p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><ol><li>导入包的时候不报错，但运行程序时出现一下错误<br><img src="https://i.loli.net/2019/07/27/5d3c156f55e6b74341.png" alt="15.png"><br><img src="https://i.loli.net/2019/07/27/5d3c156f39a4e29681.png" alt="16.png"><br>出现这个问题，目前已知的有两个原因    <ul><li>imread函数读不到图片，即你的图片路径写的有问题<br>这里给出两种基本的路径书写形式    <ol><li>绝对路径<br>Mat img = imread(“D:\\Pictures\\1.bmp”);<br>一定要注意这里是双斜杠</li><li>图片路径<br>Mat img = imread(“1.bmp”);<br>使用这个的前提是图片的位置在你的工程目录下</li></ol></li><li>链接器的附加依赖项配置的有问题<br>在Debug模式下，附加依赖项添加的是 <strong>opencv_world344d.lib</strong><br>在Release模式下，附加依赖项添加的是 <strong>opencv_world344.lib</strong><br>有些教程是两个都添加，这是不对的，一定要注意。</li></ul></li></ol><hr><p>好了，教程到此结束，<br>接下来你就可以放心地去玩耍了，Enjoy Your OpenCV!</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day11</title>
      <link href="/2019/07/25/day11/"/>
      <url>/2019/07/25/day11/</url>
      
        <content type="html"><![CDATA[<h1 id="配了一天的环境，还没有装好，卒！"><a href="#配了一天的环境，还没有装好，卒！" class="headerlink" title="配了一天的环境，还没有装好，卒！"></a>配了一天的环境，还没有装好，卒！</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Day10</title>
      <link href="/2019/07/24/day10/"/>
      <url>/2019/07/24/day10/</url>
      
        <content type="html"><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><h2 id="基本边缘检测"><a href="#基本边缘检测" class="headerlink" title="基本边缘检测"></a>基本边缘检测</h2><h3 id="边缘模型"><a href="#边缘模型" class="headerlink" title="边缘模型"></a>边缘模型</h3><ul><li>台阶模型<br>在一个像素的距离上发生两次灰度级间理想的过渡</li><li>斜坡模型<br>数字图像存在被模糊或有噪声的边缘，这时的边缘被建模成一个更接近灰度斜坡的剖面，斜坡的斜度与边缘的模糊程度成反比</li><li>屋顶模型<br>通过一个区域的线的模型，屋顶边缘的基底(宽度)由该线的宽度和尖锐度决定<br><img src="https://i.loli.net/2019/07/24/5d382004cd3e437707.jpg" alt></li></ul><p>结合前面提到的一阶导数和二阶导数的性质，可以得出结论:</p><ol><li>一阶导数的幅值可用于检测图像中的某个点处是否存在一个边缘</li><li>二阶导数的符号可用于确定一个边缘像素位于该边缘的暗的一侧还是亮的一侧</li><li>对图像的每个边缘，二阶导数生成两个值</li><li>二阶导数的零交叉点可用于定位粗边缘的中心</li></ol><ul><li>执行边缘检测的三个步骤:    <ol><li>为降噪对图像进行平滑处理</li><li>边缘点的检测</li><li>边缘定位</li></ol></li></ul><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><ul><li>二维函数f(x,y)的梯度定义为一个向量：<br>$$\triangledown f = \begin{bmatrix} g_x \\ g_y \\ \end{bmatrix} = \begin{bmatrix} \frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial x} \end{bmatrix}$$<br>这个向量的幅值<br>$$\triangledown f = mag(\triangledown f)=[g_x^2+g_y^2]^{1/2}= [(\partial f/\partial x)^2+(\partial f/\partial y)^2]^{1/2}$$<br>为了简化计算，通常省略平方根或取绝对值<br>$$\triangledown f = |g_x| + |g_y|$$<br>通常用梯度没的幅值或者近似值来简单作为’梯度’<br>梯度的性质是:梯度向量指向(x,y)坐标处f的最大变换率方向。最大变化率发生的角度是:<br>$$\alpha (x,y) = tan^{-1}(\frac{g_x}{g_y})$$</li></ul><h3 id="使用函数edge的边缘检测"><a href="#使用函数edge的边缘检测" class="headerlink" title="使用函数edge的边缘检测"></a>使用函数edge的边缘检测</h3><ul><li>语法<pre><code>[g,t] = edge(f, &#39;method&#39;, parameters);</code></pre>f是输入图像，method是边缘检测方法，parameters是附加参数<h3 id="边缘检测算子"><a href="#边缘检测算子" class="headerlink" title="边缘检测算子"></a>边缘检测算子</h3>图像邻域如下图所示:</li></ul><table><thead><tr><th align="center">$z_1$</th><th align="center">$z_2$</th><th align="center">$z_3$</th></tr></thead><tbody><tr><td align="center">$z_4$</td><td align="center">$z_5$</td><td align="center">$z_6$</td></tr><tr><td align="center">$z_7$</td><td align="center">$z_8$</td><td align="center">$z_9$</td></tr></tbody></table><h4 id="Sobel边缘检测算子"><a href="#Sobel边缘检测算子" class="headerlink" title="Sobel边缘检测算子"></a>Sobel边缘检测算子</h4><ul><li>Sobel边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-2</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">2</td><td align="center">1</td></tr></tbody></table><p>$$g_x=(z_7+2z_8+z_9)-(z_1+2z_2+z_3)$$</p><table><thead><tr><th align="center">-1</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">-2</td><td align="center">0</td><td align="center">2</td></tr><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_y = (z_3+2z_6+z_9)-(z_1+2z_4+z_7)$$<br>每一行和每一列的中心像素用2来加权以提供平滑</p><ul><li>MATLAB语法<pre><code>[g, t] = edge(f, &#39;sobel&#39;, T, dir);</code></pre>f是输入的图像，T是指定的阀值，dir是指定的检测边缘的首选方向:’horizontal’,’vertical’,’both’(默认值)<br>t是可选的，T未指定，则t自动设置</li></ul><h4 id="Prewitt边缘检测算子"><a href="#Prewitt边缘检测算子" class="headerlink" title="Prewitt边缘检测算子"></a>Prewitt边缘检测算子</h4><ul><li>Prewitt边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>$$g_x = (z_7 + z_8 + z_9)-(z_1 + z_2 + z_3)$$</p><table><thead><tr><th align="center">-1</th><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">-1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_y = (z_3 + z_6 + z_9) - (z_1 + z_4 + z_7)$$</p><ul><li>MATLAB语法<pre><code>[g, t] = edge(f, &#39;prewitt&#39;, T ,dir);</code></pre>计算简单，但容易产生噪声</li></ul><h4 id="Roberts边缘检测算子"><a href="#Roberts边缘检测算子" class="headerlink" title="Roberts边缘检测算子"></a>Roberts边缘检测算子</h4><ul><li>Roberts边缘检测算子模板</li></ul><table><thead><tr><th align="center">-1</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td></tr></tbody></table><p>$$g_x = z_9 - z_5$$</p><table><thead><tr><th align="center">0</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>$$g_y = z_8 - z_6$$</p><ul><li>MATLAB语法<pre><code>[g, t] = edge(f, &#39;roberts&#39;, T , dir);</code></pre><h4 id="LoG检测算子"><a href="#LoG检测算子" class="headerlink" title="LoG检测算子"></a>LoG检测算子</h4></li><li>LoG</li></ul><p>考虑高斯函数<br>$$G(x,y) = e^{-\frac{x^2 + y^2}{2\sigma ^2}}$$<br>$\sigma$是标准差。这是平滑函数，如果和图像卷积，会使图像变模糊，模糊程度由$\sigma$决定<br>这个函数的Laplace算法是:<br>$$\triangledown^2G(x,y) = \frac{\partial ^2 G(x,y)}{\partial x^2}+\frac{\partial ^2 G(x,y)}{\partial y^2} = [\frac{x^2 + y^2-2\sigma ^2}{\sigma ^4}]^{e^{-\frac{x^2 + y^2}{2\sigma ^2}}}$$</p><p>用$\triangledown ^2G(x,y)$卷积(滤波)这幅图像与先用平滑函数对图像卷积，再对结果进行Laplace变换的结果是一样的<br>用$\triangledown ^2G(x,y)$卷积图像，可以得到两个效果:平滑图像(因而减少了噪声);计算Laplace，从而产生双边缘图像，然后在双边缘之间定位由发现的零交叉组成的边缘</p><ul><li>MATLAB语法<pre><code>[g, t] = edge(f, &#39;log&#39;, T , sigma);</code></pre>sigma默认值是2</li></ul><h4 id="零交叉检测算子"><a href="#零交叉检测算子" class="headerlink" title="零交叉检测算子"></a>零交叉检测算子</h4><ul><li>基于LoG，卷积使用特殊的滤波函数H来完成</li><li>MATLAB语法<pre><code>[g, t] = edge(f, &#39;zerocross&#39;, T , H);</code></pre><h4 id="Canny检测算子"><a href="#Canny检测算子" class="headerlink" title="Canny检测算子"></a>Canny检测算子</h4></li><li>edge函数中最强的边缘检测算子</li><li>MATLAB语法<pre><code>[g, t] = edge(f, &#39;canny&#39;, T , sigma);</code></pre><h3 id="MATLAB实现"><a href="#MATLAB实现" class="headerlink" title="MATLAB实现"></a>MATLAB实现</h3></li><li>几种边缘检测算法的比较(Sobel,LoG,Canny)<pre><code>f = imread(&#39;timg1.jpg&#39;);imshow(f),title(&#39;currect image&#39;);f = rgb2gray(f);%Default Output[gSobel_default,ts] = edge(f, &#39;sobel&#39;);[gLoG_default, tlog] = edge(f, &#39;log&#39;);[gCanny_default, tc] = edge(f,&#39;canny&#39;);</code></pre></li></ul><p>%Best Output</p><p>gSobel_best = edge(f,’sobel’,0.165);<br>gLoG_best = edge(f,’log’,0.008, 2.25);<br>gCanny_best = edge(f,’canny’,[0.05, 0.4], 1.5);</p><p>figure,imshow(f),title(‘Gary images’);<br>figure,imshow(gSobel_default),title(‘gSobel default’);<br>figure,imshow(gSobel_best),title(‘gSobel best’);<br>figure,imshow(gLoG_default),title(‘gLoG default’);<br>figure,imshow(gLoG_best),title(‘gLoG best’);<br>figure,imshow(gCanny_default),title(‘gCanny default’);<br>figure,imshow(gCanny_best),title(‘gCanny best’);</p><pre><code>其中最佳输出的阀值是根据得到的ts,tlog,tc的值来确定的结果:![](https://i.loli.net/2019/07/24/5d37d6b4bec1777947.jpg)![](https://i.loli.net/2019/07/24/5d37d6b5886d994031.jpg)![](https://i.loli.net/2019/07/24/5d37d6b3ad9b270352.jpg)![](https://i.loli.net/2019/07/24/5d37d6b573bae72055.jpg)![](https://i.loli.net/2019/07/24/5d37d6b61724d14715.jpg)![](https://i.loli.net/2019/07/24/5d37d6b51df2874618.jpg)![](https://i.loli.net/2019/07/24/5d37d6b65663011930.jpg)![](https://i.loli.net/2019/07/24/5d37d6b3e566366232.jpg)综合结果来看，Canny边缘检测算子可以得到最好的结果## 霍夫变换### 介绍与应用场景[霍夫变换](https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2)(Hough Transform)是图像处理中的一种特征提取技术，该过程在一个参数空间中通过计算累计结果的局部最大值得到一个符合该特定形状的集合作为霍夫变换结果。经典霍夫变换用来检测图像中的直线，后来霍夫变换扩展到任意形状物体的识别，多为圆和椭圆。霍夫变换运用两个坐标空间之间的变换将在一个空间中具有相同形状的曲线或直线映射到另一个坐标空间的一个点上形成峰值，从而把检测任意形状的问题转化为统计峰值问题。### 基本原理考虑点$(x_i,y_i)$及通过这个点的线,有无穷多的线通过点$(x_i,y_i)$，针对a和b的一些值，满足斜截式$y_i = ax_i + b$的所有线都通过该点。该公式也可以写为$b = -ax_i + y_i$，考虑ab平面(即**参数空间**)对固定点$(x_i,y_i)$得到一条线的方程。另外，第二个点$(x_j,y_j)$也有一条在参数空间中与之相关的线，这条线和与$(x_i,y_i)$**相关**的线交于点$(a&#39;,b&#39;)$，其中$a&#39;$是斜率，$b&#39;$是在**xy平面**上包含点$(x_i,y_i)$和$(x_j,y_j)$的线的截距。在**参数空间**中，这条线包含的所有点都有相交于$(a&#39;,b&#39;)$点的直线。    简单理解，直线由两个点$A(x_1,y_1)$和$B(x_2,y_2)$定义，在参数空间中，两条直线的唯一公共点是在原图像空间中表示连接点A和B的唯一存在的直线![](https://i.loli.net/2019/07/24/5d38129f0e9f156720.jpg)因此，给定很多点，判断这些点是否共线的问题，经由霍夫变换之后，变成判断一堆曲线(每一个点在$(r, \theta)$平面上代表一条曲线)是否 在 $(r,\theta)$平面上相交于同一点的问题另外用法线表示法:$$xcos\theta + ysin\theta = \rho$$水平线的$\theta$=0,$\rho$等于正的x的截距，垂直线的$\theta=90$度，$\rho$等于正的y的截距![](https://i.loli.net/2019/07/24/5d382004e2bab23873.jpg)在坐标(i, j)的单元位置，累加器的值是 A(i, j)，对应于参数空间坐标$(\rho_i,\theta_j)$的正方形。最初， 这些单元位置为零。然后，对于每个图像平面上的非背景点$(x_k,y_k)$(就是 xy 平面)，我们令 θ 等 于在 θ 轴上允许的细分值，并通过公式$\rho = x_kcos\theta+y_ksin\theta$解出相应的 ρ 值。然后，得到的 ρ 值四 舍五入为最接近的 ρ 轴上允许的单元值。相应的累加器单元增加一个增量。在这个过程的最后， 累加单元 A(i, j)中的值 Q 就意味着 xy 平面上位于线$xcos\theta_j+ysin\theta_j = \rho_i$上的点有 Q 个。在$\rho\theta$平面上，细分的数目决定了这些点的共线的精确度。累加器数组在工具箱中叫做霍夫变换矩阵，简称霍夫变换。### MATLAB工具箱函数#### hough函数默认语法</code></pre><p>[H, theta, rho] = hough(f)</p><pre><code>H是霍夫变换矩阵，theta和rho是$\theta$和$\rho$的值    下面这个例子可以加深对霍夫变换的理解</code></pre><p>f = zeros(101,101);</p><p>f(1,1) = 1;</p><p>f(101,1) = 1;</p><p>f(1,101) = 1;</p><p>f(101, 101) = 1;</p><p>f(51, 51) = 1;</p><p>% H = hough(f);</p><p>[H, theta, rho] = hough(f);</p><p>imshow(H, [],’XData’, theta,’YData’, rho, ‘InitialMagnification’, ‘fit’)</p><p>axis on, axis normal</p><p>xlabel(‘\theta’),ylabel(‘\rho’)</p><pre><code>结果:![](https://i.loli.net/2019/07/24/5d381e6cd3ce994397.jpg)观察图可以看打到三条曲线在+45度和-45度处的交点指出:f中有两组三个共线的点。两条曲线在$(\rho,\theta)$ = (0,-90)、(-100,-90)、(0,0)、(100,0)处的交点指出:有4组位于**垂直线**和**水平线**上的公共点#### houghpeaks函数寻找指定的峰值数    默认语法</code></pre><p>peaks = houghpeaks(H, NumPeaks)</p><pre><code>H是霍夫变换矩阵#### houghlines函数决定线的起点和终点默认语法</code></pre><p>lines = houghlines(f, theta, rho, peaks)</p><pre><code>输出lines是结构数组，长度等于找到的线段。结构中的每个元素可以看成一条线，并含有下列字段:      1. point1:两元素向量[r1,c1]，指定了线段终点的行列坐标。  2. point2:两元素向量[r2,c2]，指定了线段其他终点的行列坐标。  3. theta:与线相关的霍夫变换的以度计量的角度。  4. rho:与线相关的霍夫变换的$\rho$轴位置。#### MATLAB使用霍夫变换检测和连接线</code></pre><p>f = imread(‘timg1.jpg’);</p><p>f = rgb2gray(f);</p><p>BW = edge(f,’canny’);</p><p>[H ,theta, rho] = hough(BW, ‘ThetaResolution’, 0.2);</p><p>imshow(H, [],’XData’, theta,’YData’, rho, ‘InitialMagnification’, ‘fit’)</p><p>axis on, axis normal</p><p>xlabel(‘\theta’),ylabel(‘\rho’)</p><p>peaks = houghpeaks(H, 5);</p><p>hold on</p><p>plot(theta(peaks( :, 2)), rho(peaks(:, 1)),…</p><pre><code>&#39;linestyle&#39;, &#39;none&#39;, &#39;marker&#39;, &#39;s&#39;, &#39;color&#39;, &#39;w&#39;);</code></pre><p>lines = houghlines(f, theta, rho, peaks);</p><p>figure, imshow(f), hold on</p><p>for k = 1:length(lines)</p><pre><code>xy = [lines(k).point1 ; lines(k).point2];plot(xy(:,1), xy(:,2), &#39;LineWidth&#39;, 4, &#39;color&#39;, &#39;red&#39;);</code></pre><p>end</p><pre><code>结果:![](https://i.loli.net/2019/07/24/5d381d8d80bff63571.jpg)![](https://i.loli.net/2019/07/24/5d381de2778c421022.jpg)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day09</title>
      <link href="/2019/07/23/day09/"/>
      <url>/2019/07/23/day09/</url>
      
        <content type="html"><![CDATA[<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><hr><blockquote><p>整体等于部分之和<br>                —–欧几里德</p></blockquote><hr><p>图像分割把图像细分为它的组成要素或物体，细分的水平取决于要解决的问题。<br>单色分割的分割算法通常是基于图像亮度值的两个基本特征:不连续性和相似性。第一类，方法是基于亮度的突变来分割一幅图像，比如边缘;第二类，主要方法是根据事先定义好的准则把图像分割成相似的区域</p><h2 id="点、线和边缘检测"><a href="#点、线和边缘检测" class="headerlink" title="点、线和边缘检测"></a>点、线和边缘检测</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ol><li>边缘像素是图像中灰度突变的像素，边缘是连接的边缘像素的集合</li><li>一条线可以视为一条边缘线段，该线段两侧的背景灰度要么远亮于该线像素的灰度，要么远暗于该线像素的灰度。孤立点可视为一条线，只是长度和宽度都是一个像素</li><li>局部变化检测可以用微分(一阶微分和二阶微分)    <ul><li>对于一阶导数的任何近似，约定:<ul><li>在恒定灰度区域必须为0</li><li>在灰度台阶和或斜坡开始处必须不为0</li><li>在沿灰度斜坡点处也必须不为0</li></ul></li><li>类似的对于二阶导数的近似<ul><li>在恒定灰度区域必须为0</li><li>在灰度台阶或斜坡开始除和结束处必须不为0</li><li>沿灰度斜坡必须为0</li></ul></li><li>一维函数展开为关于x的泰勒级数,结果差分<br>$$ \frac{\partial f}{\partial x}=f’(x)=f(x+1)-f(x)$$<br>二阶导数<br>$$ \frac{\partial ^2 f}{\partial ^2 x}=f’’(x)=f(x+1)+f(x-1)-2f(x)$$<ul><li>可以得出结论:<ul><li>一阶导数通常在图像中产生较粗的边缘</li><li>二阶导数对精细细节，如细线、孤立点和噪声有较强的响应</li><li>二阶导数在灰度斜坡和灰度台阶过渡处会产生双边缘响应</li><li>二阶导数的符号可用于确定边缘的过程是从亮到暗还是从暗到亮</li></ul></li><li>计算图像中每个像素位置的一阶导数和二阶导数的可选择方法是空间滤波器。模板在该区域中心点处的响应为<br>$$R = w_1z_1 + w_2z_2 + … + w_9z_9 = \sum_{k=1}^{9}w_kz_k$$</li></ul></li></ul></li></ol><table><thead><tr><th align="center">$w_1$</th><th align="center">$w_2$</th><th align="center">$w_3$</th></tr></thead><tbody><tr><td align="center">$w_4$</td><td align="center">$w_5$</td><td align="center">$w_6$</td></tr><tr><td align="center">$w_7$</td><td align="center">$w_8$</td><td align="center">$w_9$</td></tr></tbody></table><p>这是一个普通的3×3空间滤波器掩模</p><h3 id="孤立点检测"><a href="#孤立点检测" class="headerlink" title="孤立点检测"></a>孤立点检测</h3><ul><li>点的检测应以二阶导数为基础，这意味着使用laplace<br>$$\triangledown ^2f(x,y) = \frac{\partial ^2 f}{\partial x^2} + \frac{\partial ^2 f}{\partial y^2}$$<br>偏微分之后可求得laplace为<br>$$\triangledown ^2f(x,y) = f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)$$<br>点检测laplace模板</li></ul><table><thead><tr><th align="center">1</th><th align="center">1</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-8</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>如果在某点处的该模板的响应的绝对值超过了一个指定的阈值，那么就说在模板中心位置(x,y)处的该点已经被检测到。在输出图像中，这样的点被标注为1,所有其他点被标注为0<br>$$g(x,y)=\begin{cases}<br>1,\quad |R(x,y)| \geqq T\<br>0, \quad 其他<br>\end{cases}<br>$$</p><ul><li>MATLAB实现</li></ul><pre><code>f = imread(&#39;moon.jpg&#39;);f = rgb2gray(f);w = [-1 -1 -1; -1 8 -1; -1 -1 -1];g = abs(imfilter(f, w));T = max(g(:));g = g &gt;= T;figure(1);subplot(1,2,1)imshow(f)subplot(1,2,2)imshow(g)</code></pre><p>结果：<br><img src="https://i.loli.net/2019/07/24/5d37b3a82234833730.jpg" alt></p><h3 id="线检测"><a href="#线检测" class="headerlink" title="线检测"></a>线检测</h3><p>可以预期，二阶导数将导致更强的响应，并产生比一阶导数更细的线</p><p>线检测模板</p><ul><li>水平</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">-1</td><td align="center">-1</td><td align="center">-1</td></tr></tbody></table><ul><li>+45度</li></ul><table><thead><tr><th align="center">2 -</th><th align="center">-1</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">-1</td><td align="center">-1</td><td align="center">2</td></tr></tbody></table><ul><li>垂直</li></ul><table><thead><tr><th align="center">-1</th><th align="center">2</th><th align="center">-1</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr></tbody></table><ul><li>-45度</li></ul><table><thead><tr><th align="center">-1</th><th align="center">-1</th><th align="center">2</th></tr></thead><tbody><tr><td align="center">-1</td><td align="center">2</td><td align="center">-1</td></tr><tr><td align="center">2</td><td align="center">-1</td><td align="center">-1</td></tr></tbody></table><p>对于恒定的背景，当线通过模板的中间一行时可能产生更大的响应。<br>每个模板的系数之和为0,这表示在恒定亮度区域内，模板的响应为0.</p><ul><li>MATLAB实现检测指定方向上的线<pre><code>clc</code></pre></li></ul><p>clear</p><p>f = imread(‘11111.jpg’);</p><p>f = rgb2gray(f);</p><p>figure(1);</p><p>subplot(2,3,1)</p><p>imshow(f);</p><p>w = [-1, 2, -1; -1 2 -1; -1 2 -1];</p><p>% g = imfilter(tofloat(f),w);</p><p>g = imfilter(f,w);</p><p>subplot(2,3,2)</p><p>imshow(g, [ ]);</p><p>gtop = g(1:120, 1:120);</p><p>% gtop = pixeldup(gtop, 4);</p><p>subplot(2,3,3)</p><p>imshow(gtop, [ ]);</p><p>gbot = g(end - 119:end, end - 119:end);</p><p>% gbot = pixeldup(gbot, 4);</p><p>subplot(2,3,4)</p><p>imshow(gbot, [ ]);</p><p>g = abs(g);</p><p>subplot(2,3,5)</p><p>imshow(g, [])</p><p>T = max(g(:));</p><p>g = g &gt;= T;</p><p>subplot(2,3,6);</p><p>imshow(g)</p><pre><code>结果:![](https://i.loli.net/2019/07/24/5d37b3a815b7125153.jpg)可能会用到的M函数pixeldup</code></pre><p>function B=pixeldup(A,m,n)%pixeldup用来重复像素的，在水平方向复制m倍，在垂直方向复制n倍，m，n必须为整数，n没有赋值默认为m%检查输入参数个数<br>if nargin&lt;2<br>    error(‘At least two inputs are required.’);<br>    end<br>if nargin==2<br>    n=m;<br>    end<br>u=1:size(A,1);%产生一个向量，其向量中元素的个数为A的行数%复制向量中每个元素m次m=round(m);%防止m为非整数u=u(ones(1,m),:);<br>u=u(:);%在垂直方向重复操作<br>v=1:size(A,2);<br>n=round(n);<br>v=v(ones(1,n),:);<br>v=v(:);<br>B=A(u,v);</p><pre><code>**慎用tofloat函数**</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo大坑</title>
      <link href="/2019/07/22/hexo-da-keng/"/>
      <url>/2019/07/22/hexo-da-keng/</url>
      
        <content type="html"><![CDATA[<h2 id="坑一、Template-render-error-模板渲染错误"><a href="#坑一、Template-render-error-模板渲染错误" class="headerlink" title="坑一、Template render error 模板渲染错误"></a>坑一、Template render error 模板渲染错误</h2><p>写了一下午博文，高高兴兴地hexo g却发现报错了！<br><code>INFO  Start processingFATAL Something&#39;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error:  [Line 2, Column 6] unexpected token: }} at formatNunjucksError (/home/kevin/blog/node_modules/hexo/lib/extend/tag.js:102:13)    at Promise.fromCallback.catch.err (/home/kevin/blog/node_modules/hexo/lib/extend/tag.js:124:34)    at tryCatcher (/home/kevin/blog/node_modules/bluebird/js/release/util.js:16:23)    at Promise._settlePromiseFromHandler (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:517:31)    at Promise._settlePromise (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:574:18)    at Promise._settlePromise0 (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:619:10)    at Promise._settlePromises (/home/kevin/blog/node_modules/bluebird/js/release/promise.js:695:18)    at _drainQueueStep (/home/kevin/blog/node_modules/bluebird/js/release/async.js:138:12)    at _drainQueue (/home/kevin/blog/node_modules/bluebird/js/release/async.js:131:9)    at Async._drainQueues (/home/kevin/blog/node_modules/bluebird/js/release/async.js:147:5)    at Immediate.Async.drainQueues [as _onImmediate] (/home/kevin/blog/node_modules/bluebird/js/release/async.js:17:14)    at processImmediate (internal/timers.js:443:21)</code></p><p>原因是nunjucks模板标签导致MD文件解析报错的问题，我试验了一下，在md文档中出现<code>双大括号</code>,<code>左大括号+#</code>,<code>左大括号+%</code>等都会报错(原谅我这么打，因为我打出来符号的话这篇博客就发不出来了)，下面是一位大神的<a href="http://xcoding.tech/2018/08/08/hexo/%E5%A6%82%E4%BD%95%E4%BB%8E%E6%A0%B9%E6%9C%AC%E8%A7%A3%E5%86%B3hexo%E4%B8%8D%E5%85%BC%E5%AE%B9%7B%7B%7D%7D%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决办法</a>，他提供了几种解决办法，讲的很详细，可以参考一下</p><p>我觉得有点麻烦就没采用(说多了就是菜～),下面是我的办法:</p><ol><li>既然出现上面的内容就会报错，那就尽量避免出现呗…(说的都是废话)</li><li>使用<code>\lbrace</code>代替<code>\{</code>,使用<code>\rbrace</code>代替<code>\}</code><br>推荐大神的解决办法，一劳永逸，以后就不用管了</li></ol><h2 id="坑二、Markdown的空行"><a href="#坑二、Markdown的空行" class="headerlink" title="坑二、Markdown的空行"></a>坑二、Markdown的空行</h2><p>在写表格的时候要把表格体前后各空一行，不然你写的表格是这样式儿的，崩溃啊！<br><img src="https://i.loli.net/2019/07/22/5d358cfee55f989745.png" alt></p><p>有可能是hexo解析的问题，我在使用markdown-preview的时候看的是正常的</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day08</title>
      <link href="/2019/07/22/day08/"/>
      <url>/2019/07/22/day08/</url>
      
        <content type="html"><![CDATA[<h1 id="形态学图像处理"><a href="#形态学图像处理" class="headerlink" title="形态学图像处理"></a>形态学图像处理</h1><p>从这里开始过渡，从输入输出都是图像，过渡到图像分析方法，输出以某种方法来描述图像的内容。</p><h2 id="集合理论基础"><a href="#集合理论基础" class="headerlink" title="集合理论基础"></a>集合理论基础</h2><p>令Z为整数集合，用于产生的数字图像的抽样处理可以看做是把xy平面分割成网格状，其中每个网格的<strong>中心坐标</strong>是来自笛卡尔积$Z^2$中的一对元素。在集合理论中，如果(x,y)是来自$Z^2$的整数,f是分配给每个不同坐标的对(x,y)的亮度值的映射，那么函数f(x,y)被成为数字图像。如果亮度值也为整数，那么这幅图像就变成了二维图像。<br>集合的基本操作:$\in$,$\notin$,$\cup$,$\cap$,+,-.除了这些基本操作，形态学操作还需要两个算子，他们特别针对元素均为像素坐标的集合</p><ol><li>集合的反射$\hat{B}$<br>$$ \hat{B} = \{w|w=-b,b\in B\}$$</li><li>点z=($z_1$,$z_2$)集合的平移${(A)}_z$<br>$$ (A)_z = \{c|c=a+z,a\in A\}$$<h3 id="二值图像、集合及逻辑算子"><a href="#二值图像、集合及逻辑算子" class="headerlink" title="二值图像、集合及逻辑算子"></a>二值图像、集合及逻辑算子</h3>形态学理论把二值图像看成是前景(1值)像素的集合,集合的元素属于$Z^2$如果A和B都是二值图像，那么$C=A\cup B$也是二值图像<br>$$C(x,y)=\begin{cases}<br>1,\quad A(x,y)或B(x,y)为1,或者两者均为1\<br>0 \quad 其他<br>\end{cases}<br>$$<h3 id="在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算"><a href="#在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算" class="headerlink" title="在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算"></a>在MATLAB中使用逻辑表达式在二值图像上进行逻辑运算</h3></li></ol><table><thead><tr><th>集合运算</th><th align="center">二值图像的MATLAb语句</th><th>名称</th></tr></thead><tbody><tr><td>$A\cap B$</td><td align="center">A &amp; B</td><td>与</td></tr><tr><td>$A\cup B$</td><td align="center">A $\rvert$ B</td><td>或</td></tr><tr><td>$A^c$</td><td align="center">~B</td><td>非</td></tr><tr><td>$A-B$</td><td align="center">A &amp;~ B</td><td>差</td></tr></tbody></table><h2 id="腐蚀和膨胀"><a href="#腐蚀和膨胀" class="headerlink" title="腐蚀和膨胀"></a>腐蚀和膨胀</h2><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>膨胀是使图像中的目标”生长”或”变粗”的操作。程度由一种被称为<strong>结构元</strong>的形状来控制<br>A被B膨胀，表示为$A \oplus B$,作为集合操作<br>$$ A\oplus B=\{ z|\hat{B}_z\cap A\not= \emptyset\}$$<br>约定: $A \oplus B$ 的第一个操作数是图像，第二个操作数是结构元，结构元通常比图像小的多。<br><img src="https://i.loli.net/2019/07/22/5d35670a79cd611294.jpg" alt></p><ul><li>工具箱函数imdilate(A, B)来执行膨胀<pre><code>f = imread(&#39;1111.jpg&#39;);B = [0 1 0; 1 1 1; 0 1 0];%自定义结构元D = imdilate(f, B);subplot(1,2,1),imshow(f);title(&#39;原图&#39;)subplot(1,2,2),imshow(D);title(&#39;膨胀后的图&#39;)</code></pre><img src="https://i.loli.net/2019/07/22/5d3564132fa1741100.jpg" alt><h3 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h3>腐蚀”收缩”或”细化”二值图像中的物体。像膨胀一样，收缩的方法和程度由结构元控制。<br>A被B腐蚀表示为$A\ominus B$,定义为:<br>$$ A\ominus B = \{z| (B)_z\subseteq A\} = \{z| (B)_z\cap A^c = \emptyset\}$$<br><img src="https://i.loli.net/2019/07/23/5d36cefa2813d95731.jpg" alt></li></ul><p>工具箱函数imerode(A,B)来执腐蚀</p><pre><code>f = imread(&#39;tig.jpg&#39;);B = [0 1 0; 1 1 1; 0 1 0];%自定义结构元R = imerode(f, B);subplot(1,2,1),imshow(f);title(&#39;原图&#39;)subplot(1,2,2),imshow(R);title(&#39;腐蚀后的图&#39;)</code></pre><p><img src="https://i.loli.net/2019/07/22/5d356b5f7eed962952.jpg" alt></p><h3 id="结构元"><a href="#结构元" class="headerlink" title="结构元"></a>结构元</h3><p>strel函数，用来构造各种大小和形状的结构元</p><pre><code>se = strel(shape, parameters);</code></pre><p>shape是希望形状的字符串，parameters是描述形状信息的参数列表<br><img src="https://i.loli.net/2019/07/22/5d35670a85b4f22579.jpg" alt><br><img src="https://i.loli.net/2019/07/22/5d35670a63e2817742.jpg" alt><br>注意生成的se含有两项</p><ol><li>se.Neighborhood:[ ×  logical ]</li><li>se.Demensionality: 2</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习第二周</title>
      <link href="/2019/07/21/shi-xi-di-er-zhou/"/>
      <url>/2019/07/21/shi-xi-di-er-zhou/</url>
      
        <content type="html"><![CDATA[<h1 id="第二周："><a href="#第二周：" class="headerlink" title="第二周："></a>第二周：</h1><ol><li>图像分割</li><li>点 线边缘检测</li><li>各种边缘检测算子</li><li>霍夫变换</li><li>实现基于霍夫变换的原型检测及计数</li><li>完成椭圆检测项目</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Day07</title>
      <link href="/2019/07/21/day07/"/>
      <url>/2019/07/21/day07/</url>
      
        <content type="html"><![CDATA[<h2 id="使用频率域滤波器锐化图像"><a href="#使用频率域滤波器锐化图像" class="headerlink" title="使用频率域滤波器锐化图像"></a>使用频率域滤波器锐化图像</h2><hr><h3 id="高通滤波器"><a href="#高通滤波器" class="headerlink" title="高通滤波器"></a>高通滤波器</h3><p>图像的锐化可以在频率与通过高通滤波器来实现<br>一个高通滤波器可以由一个低通滤波器来实现:<br>$$H_{HP}(u,v)=1-H_{LP}(u,v)$$<br>被低通滤波器衰减的频率可以通过高通滤波器</p><h4 id="理想高通滤波器"><a href="#理想高通滤波器" class="headerlink" title="理想高通滤波器"></a>理想高通滤波器</h4><p>二维理想高通滤波器可以定义为<br>$$ H(u,v)=\begin{cases}<br>1,\quad D(u,v)\leq D_0\<br>0,\quad D(u,v)&gt;D_0<br>\end{cases}<br>$$<br><img src="https://i.loli.net/2019/07/21/5d341bf1c410443073.jpg" alt></p><h4 id="布特沃斯高通滤波器"><a href="#布特沃斯高通滤波器" class="headerlink" title="布特沃斯高通滤波器"></a>布特沃斯高通滤波器</h4><p>截止频率为$D_0$的n阶布特沃斯高通滤波器(BHPF)的定义为:<br>$$ H(u,v)=\frac{1}{1+[D_0/D(u,v)]^{2n}}$$<br><img src="https://i.loli.net/2019/07/21/5d341bf1c376281237.jpg" alt></p><h4 id="高斯高通滤波器"><a href="#高斯高通滤波器" class="headerlink" title="高斯高通滤波器"></a>高斯高通滤波器</h4><p>截止频率处在距频率矩形中心距离为$D_0$的高斯高通滤波器(GHPF)的传递函数如下:<br>$$H(u,v)=1-e^{-D^2(u,v)/2D_0^2}$$<br><img src="https://i.loli.net/2019/07/21/5d341bf1c3f7954220.jpg" alt></p><h4 id="在MATLAB中使用高通滤波器来锐化图像"><a href="#在MATLAB中使用高通滤波器来锐化图像" class="headerlink" title="在MATLAB中使用高通滤波器来锐化图像"></a>在MATLAB中使用高通滤波器来锐化图像</h4><p>使用高通滤波器来锐化图像，与平滑图像类似，只是将低通滤波器换成了高通滤波器，具体步骤不再赘述</p><pre><code>f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);[f, revertclass] = tofloat(f);PQ = paddedsize(size(f));[U, V] = dftuv(PQ(1), PQ(2));D = hypot(U, V);D0 = 0.05*PQ(1);F = fft2(f, PQ(1), PQ(2));H = hpfilter(&#39;gaussian&#39;,PQ(1), PQ(2), D0);g = dftfilt(f, H);g = revertclass(g);figure(1)subplot(2,2,1);imshow(f,[]);title(&#39;原图像&#39;)subplot(2,2,2);imshow(fftshift(H));title(&#39;高斯高通滤波器&#39;);subplot(2,2,3);imshow(log(1 + abs(fftshift(F))), [])title(&#39;滤波后图像谱&#39;);subplot(2,2,4);imshow(g);title(&#39;滤波后图像&#39;);</code></pre><p>同样这里需要的是高通滤波函数hpfilter()</p><pre><code>function [H] = hpfilter(type,M,N,D0,n)%HPFILTER Computes freq. domain highpass filters%        THIS IS NOT A STANDARD MATLAB FUNCTION%        H = hpfilter (type,M,N,D0,n) creates the%        transfer function of a highpass filter, H, of%        the specified type and size MxN. Possible%        values for type, D0, and n are:%%        &#39;ideal&#39;                Ideal highpass filter with%                        cutoff frequency D0. If%                        supplied, n is ignored.%        &#39;btw&#39;                Butterworth highpass filter%                        of order n, and cutoff D0.%        &#39;gaussn&#39;            Gaussian highpass filter with%                        cutoff (standard deviation)D0.%                        If supplied, n is ignored.%        M and N should be even numbers for DFT%        filtering.%%        Class support: double, uint8, uint16%        The output is of class double%       The transfer function Hhp of a highpass filter%       is 1 - Hlp, where Hlp is the transfer function of%       the corresponding lowpass filter.  Thus, we can%       use function lpfilter to generate highpass filters%       If filter is btw, make sure that n is provided%       Otherwise, pass n=1 as an arbitrary value to%       prevent error messageif nargin == 4    n = 1; %default value of nendHlp = lpfilter(type,M,N,D0,n);H = 1 - Hlp;%       End of function</code></pre><p>锐化结果:</p><ol><li>IHPF<br><img src="https://i.loli.net/2019/07/21/5d341eae3a6b123891.jpg" alt></li><li>BHPF<br><img src="https://i.loli.net/2019/07/21/5d341bf1f13e453488.jpg" alt></li><li>GHPF<br><img src="https://i.loli.net/2019/07/21/5d341eae4fa8d96779.jpg" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day06</title>
      <link href="/2019/07/20/day06/"/>
      <url>/2019/07/20/day06/</url>
      
        <content type="html"><![CDATA[<h2 id="使用频率域滤波器平滑图像"><a href="#使用频率域滤波器平滑图像" class="headerlink" title="使用频率域滤波器平滑图像"></a>使用频率域滤波器平滑图像</h2><hr><h3 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h3><p>在以原点为圆心，以$D_0$为半径的圆内无衰减通过所有频率，而在圆外切断所有频率的二维低通滤波器，称为理想低通滤波器(ILPF)，定义为<br>$$y=\begin{cases}<br>1,\quad D(x,y)\leq 0\<br>0, \quad D(x,y) &gt; 0<br>\end{cases}$$<br>$D_0$是一个常数，D(u,v)是频率域中心点(u,v)与频率矩形中心的距离，即<br>$$ D(u,v)=\lbrack{(u-\frac{P}{2})^2+(v-\frac{Q}{2})^2}\rbrack^\frac{1}{2} $$<br>过渡点称为<strong>截止频率</strong><br><img src="https://i.loli.net/2019/07/21/5d341bf1f0cb755202.jpg" alt></p><h3 id="布特沃斯低通滤波器"><a href="#布特沃斯低通滤波器" class="headerlink" title="布特沃斯低通滤波器"></a>布特沃斯低通滤波器</h3><p>截止频率位于距原点$D_0$处的n阶布特沃斯低通滤波器(BLPF)的传递函数的定义为:<br>$$H(u,v)=\frac{1}{1+{[D(u,v)/D_0]}^{2n}}$$<br>截止频率点是当D(u,v) = $D_0$时的点<br><img src="https://i.loli.net/2019/07/21/5d341bf1f101518273.jpg" alt></p><h3 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a>高斯低通滤波器</h3><p>二维形式:<br>$$H(u,v) = e^{-D^2(u,v)/2{D_0}^2} $$<br>$D_0$ 是截止频率<br><img src="https://i.loli.net/2019/07/21/5d341bf1f163e99741.jpg" alt></p><h3 id="MATLAB中低通滤波器的实现"><a href="#MATLAB中低通滤波器的实现" class="headerlink" title="MATLAB中低通滤波器的实现"></a>MATLAB中低通滤波器的实现</h3><h4 id="1-高斯低通滤波器"><a href="#1-高斯低通滤波器" class="headerlink" title="1. 高斯低通滤波器"></a>1. 高斯低通滤波器</h4><pre><code>f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);[f, revertclass] = tofloat(f);PQ = paddedsize(size(f));[U, V] = dftuv(PQ(1), PQ(2));D = hypot(U, V);D0 = 0.05*PQ(2);F = fft2(f, PQ(1), PQ(2));H = exp(-(D .^ 2)/(2 * (D0^2))); %高斯低通滤波器g = dftfilt(f, H);g = revertclass(g);figure, imshow(fftshift(H));figure, imshow(log(1 + abs(fftshift(F))), [])figure, imshow(g);</code></pre><p>滤波结果：<br><img src="https://i.loli.net/2019/07/20/5d32d02f5468855048.jpg" alt></p><p>除了之前说的几个M函数外，还需要用到<code>dftfilt()</code>函数</p><pre><code>function g=dftfilt(f,H)%DFTFILT Performs frequency domain filtering.%   G=DFTFILT(F,H) filters F in the frequency domain using the%   filter transfer function H. The output, G, is the filtered%   image, which has the same size as F. DFTFILT automatically pads%   F to be the same size as H. Function PADDEDSIZE can be used%   to determine an appropriate size for H.%%   DFTFILT assumes that F is real and that H is a real, uncentered,%   circularly-symmetric filter function.%Obtain the FFT of the padded input.F=fft2(f,size(H,1),size(H,2));%Perform filtering.g=real(ifft2(H.*F));%Crop to original size.g=g(1:size(f,1),1:size(f,2));</code></pre><h4 id="2-Butterworth滤波"><a href="#2-Butterworth滤波" class="headerlink" title="2. Butterworth滤波"></a>2. Butterworth滤波</h4><p>该函数输入为灰度图像，自由设置截止频率$D_0$和BLPF的阶数n，输出为滤波后的图像(已归一化到[0,255])</p><pre><code>function [image_out] = Bfilter(image_in, D0, N)% Butterworth滤波器，在频率域进行滤波% 输入为需要进行滤波的灰度图像，Butterworth滤波器的截止频率D0，阶数N% 输出为滤波之后的灰度图像[m, n] = size(image_in);P = 2 * m;Q = 2 * n;fp = zeros(P, Q);%对图像填充0,并且乘以(-1)^(x+y) 以移到变换中心for i = 1 : m    for j = 1 : n        fp(i, j) = double(image_in(i, j)) * (-1)^(i+j);    endend% 对填充后的图像进行傅里叶变换F1 = fft2(fp);% 生成Butterworth滤波函数，中心在(m+1,n+1)Bw = zeros(P, Q);a = D0^(2 * N);for u = 1 : P    for v = 1 : Q        temp = (u-(m+1.0))^2 + (v-(n+1.0))^2;        Bw(u, v) = 1 / (1 + (temp^N) / a);    endend%进行滤波G = F1 .* Bw;% 反傅里叶变换gp = ifft2(G);% 处理得到的图像image_out = zeros(m, n, &#39;uint8&#39;);gp = real(gp);g = zeros(m, n);for i = 1 : m    for j = 1 : n        g(i, j) = gp(i, j) * (-1)^(i+j);    endendmmax = max(g(:));mmin = min(g(:));range = mmax-mmin;for i = 1 : m    for j = 1 : n        image_out(i,j) = uint8(255 * (g(i, j)-mmin) / range);    endendend</code></pre><p>测试BLPF的阶数为2,截止频率分别为10,40,80,150,450</p><pre><code>clear all;close all;clc;image1 = imread(&#39;2.jpg&#39;);image2 = Bfilter(image1, 10, 2);image3 = Bfilter(image1, 40, 2);image4 = Bfilter(image1, 80, 2);image5 = Bfilter(image1, 150, 2);image6 = Bfilter(image1, 450, 2);% 显示图像subplot(2,3,1), imshow(image1), title(&#39;原图像&#39;);subplot(2,3,2), imshow(image2), title(&#39;D0 = 10, n = 2&#39;);subplot(2,3,3), imshow(image3), title(&#39;D0 = 40, n = 2&#39;);subplot(2,3,4), imshow(image4), title(&#39;D0 = 80, n = 2&#39;);subplot(2,3,5), imshow(image5), title(&#39;D0 = 150, n = 2&#39;);subplot(2,3,6), imshow(image6), title(&#39;D0 = 450, n = 2&#39;);</code></pre><p>滤波结果如下:<br><img src="https://i.loli.net/2019/07/20/5d32d02f43bc610556.jpg" alt><br>分析结果:    </p><ol><li>模糊的平滑过渡是截止频率增大的函数</li><li>滤波后输出三副连续的色图，原因是rgb图像的分三次呈现<br>一副彩图是由三色组成,红绿蓝三色，图像读取到matlab后，有三个参数m × n × 3, 代表的是三色叠加，处理之后的图将三色展开分别呈现了，所以才会出现三副连续的色图<br><img src="https://i.loli.net/2019/07/20/5d32d80a09a9124012.jpg" alt></li></ol><p>换成彩色图可以明显看到<br><img src="https://i.loli.net/2019/07/20/5d32d80a3073491464.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown数学公式汇总</title>
      <link href="/2019/07/19/markdown-shu-xue-gong-shi-hui-zong/"/>
      <url>/2019/07/19/markdown-shu-xue-gong-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><h4 id="分数、上标、下标、方根、求和、积分"><a href="#分数、上标、下标、方根、求和、积分" class="headerlink" title="分数、上标、下标、方根、求和、积分"></a>分数、上标、下标、方根、求和、积分</h4><p>分数 <code>$\dfrac{2}{3}$</code>表示$\dfrac{2}{3}$，<code>$\tfrac{2}{3}$</code>表示$\tfrac{2}{3}$</p><pre><code>\begin{eqnarray\*}    \dfrac{1}{\sqrt 2 +    \dfrac{1}{\sqrt 2 +    \dfrac{1}{\sqrt 2 + \dotsb}}}\;    \tfrac{1}{\sqrt 2 +    \tfrac{1}{\sqrt 2 +    \tfrac{1}{\sqrt 2 + \cdots}}}\;    \frac{1}{\sqrt 2 +    \frac{1}{\sqrt 2 +    \frac{1}{\sqrt 2 + \cdots}}}\end{eqnarray\*}</code></pre><p>表示<br>\begin{eqnarray*}<br>    \dfrac{1}{\sqrt 2 +<br>    \dfrac{1}{\sqrt 2 +<br>    \dfrac{1}{\sqrt 2 + \dotsb}}}\;<br>    \tfrac{1}{\sqrt 2 +<br>    \tfrac{1}{\sqrt 2 +<br>    \tfrac{1}{\sqrt 2 + \cdots}}}\;<br>    \frac{1}{\sqrt 2 +<br>    \frac{1}{\sqrt 2 +<br>    \frac{1}{\sqrt 2 + \cdots}}}<br>\end{eqnarray*}</p><hr><p>上标$A^2$、$A^{上标}$<br><code>$$A^2 \; A^{上标} \; \mathop{A}\limits^2$$</code>表示$$A^2 \; A^{上标} \; \mathop{A}\limits^2$$</p><hr><p>下标$A_2$、$A_{下标}$<br><code>$$A_2 \; A_{下标}\; \mathop{A}\limits_2$$</code>表示$$A_2 \; A_{下标}\; \mathop{A}\limits_2$$</p><hr><p>开方数$\sqrt[开方数]{参数}$<br><code>$$\sqrt[开方数]{参数}$$</code>表示$$\sqrt[开方数]{参数}$$</p><hr><p>求和$\sum$<br>$$\sum ^2_3\;\sum \nolimits^2_3$$</p><hr><p>分$\int$<br>$$\int ^2_3\;\int \limits^2_3$$</p><hr><h4 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h4><p>$R^s_r(t_r,t_e)=(t_r-t_e)c$</p><hr><h4 id="显示公式"><a href="#显示公式" class="headerlink" title="显示公式"></a>显示公式</h4><p>$$R^s_r(t_r,t_e)=(t_r-t_e)c$$</p><hr><h4 id="带有编号的显示公式"><a href="#带有编号的显示公式" class="headerlink" title="带有编号的显示公式"></a>带有编号的显示公式</h4><p>\begin{equation}<br>    R^s_r(t_r,t_e)=(t_r-t_e)c<br>\end{equation}</p><hr><h4 id="带有编号的多行公式"><a href="#带有编号的多行公式" class="headerlink" title="带有编号的多行公式"></a>带有编号的多行公式</h4><p>\begin{eqnarray}<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c<br>\end{eqnarray}</p><hr><h4 id="取消某一编号的多行公式"><a href="#取消某一编号的多行公式" class="headerlink" title="取消某一编号的多行公式"></a>取消某一编号的多行公式</h4><p>\begin{eqnarray}<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \nonumber\\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c<br>\end{eqnarray}</p><hr><h4 id="带有指定编号的多行公式"><a href="#带有指定编号的多行公式" class="headerlink" title="带有指定编号的多行公式"></a>带有指定编号的多行公式</h4><p>\begin{eqnarray*}<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \tag{1}\\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c<br>\end{eqnarray*}</p><hr><h4 id="不带编号的多行公式"><a href="#不带编号的多行公式" class="headerlink" title="不带编号的多行公式"></a>不带编号的多行公式</h4><p>\begin{eqnarray*}<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)=(t_r-t_e)c<br>\end{eqnarray*}</p><hr><h4 id="指定对齐方式的多行公式"><a href="#指定对齐方式的多行公式" class="headerlink" title="指定对齐方式的多行公式"></a>指定对齐方式的多行公式</h4><p>\begin{eqnarray}<br>    &amp;R^s_r(t_r,t_e)&amp;=(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)&amp; = &amp;(t_r-t_e)c \\<br>    R^s_r(t_r,t_e)=&amp;(t_r-t_e)c&amp;<br>\end{eqnarray}</p><hr><h4 id="输入矩阵"><a href="#输入矩阵" class="headerlink" title="输入矩阵"></a>输入矩阵</h4><p>\begin{matrix}<br>    0 &amp; 1 \\<br>    1 &amp; 0<br>\end{matrix}</p><hr><p>\begin{pmatrix}<br>    0 &amp; -i \\<br>    i &amp; 0<br>\end{pmatrix}</p><hr><p>\begin{bmatrix}<br>    0 &amp; -1 \\<br>    1 &amp; 0<br>\end{bmatrix}</p><hr><p>\begin{Bmatrix}<br>    1 &amp; 0 \\<br>    0 &amp; -1<br>\end{Bmatrix}</p><hr><p>\begin{vmatrix}<br>    a &amp; b \\<br>    c &amp; d<br>\end{vmatrix}</p><hr><p>\begin{Vmatrix}<br>    i &amp; 0 \\<br>     0 &amp; -i<br>\end{Vmatrix}</p><hr><h4 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h4><h5 id="操作符号"><a href="#操作符号" class="headerlink" title="操作符号"></a>操作符号</h5><p>$$<br>\pm    \mp    \times    \div    \ast    \star    \circ    \bullet    \divideontimes    \ltimes    \rtimes    \cdot    \dotplus    \leftthreetimes    \rightthreetimes    \amalg    \otimes    \oplus    \ominus    \oslash    \odot    \circledcirc    \circleddash    \circledast    \bigcirc \boxdot    \boxminus    \boxplus    \boxtimes    \diamond    \bigtriangleup    \bigtriangledown    \triangleleft    \triangleright    \lhd    \rhd    \unlhd    \unrhd    \cup    \cap    \uplus    \Cup    \Cap    \wr    \setminus    \smallsetminus    \sqcap    \sqcup \wedge    \vee    \barwedge    \veebar    \doublebarwedge    \curlywedge    \curlyvee    \dagger    \ddagger    \intercal    \bigcap    \bigcup    \biguplus    \bigsqcup    \prod    \coprod    \bigwedge    \bigvee    \bigodot    \bigoplus    \bigotimes    \sum \int    \oint    \iint    \iiint    \iiiint    \idotsint    \arccos    \arcsin    \arctan    \arg    \cos    \cosh    \cot    \coth    \csc    \deg    \det    \dim    \exp    \gcd    \hom    \inf    \ker    \lg    \lim    \liminf    \limsup    \ln    \log    \max    \min    \Pr    \projlim    \sec\sin\sinh    \sup    \tan    \tanh \varlimsup    \varliminf    \varinjlim    \varprojlim<br> $$</p><h5 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h5><p>$$<br>\bowtie    \Join    \propto    \varpropto    \multimap    \pitchfork  \therefore    \because    =    \neq    \equiv    \approx    \sim    \simeq    \backsimeq    \approxeq    \cong    \ncong        \smile    \frown    \asymp    \smallfrown    \smallsmile    \between    \prec    \succ    \nprec    \nsucc    \preceq    \succeq    \npreceq    \nsucceq    \preccurlyeq    \succcurlyeq    \curlyeqprec    \curlyeqsucc    \precsim    \succsim    \precnsim    \succnsim    \precapprox    \succapprox    \precnapprox    \succnapprox    \perp    \vdash    \dashv    \nvdash    \Vdash    \Vvdash    \models    \vDash    \nvDash    \nVDash    \mid    \nmid    \parallel    \nparallel    \shortmid    \nshortmid    \shortparallel    \nshortparallel    &lt;    &gt;    \nless    \ngtr    \lessdot    \gtrdot    \ll    \gg    \lll    \ggg    \leq    \geq    \lneq    \gneq    \nleq    \ngeq    \leqq    \geqq    \lneqq    \gneqq    \lvertneqq    \gvertneqq    \nleqq    \ngeqq    \leqslant    \geqslant    \nleqslant    \ngeqslant    \eqslantless    \eqslantgtr    \lessgtr    \gtrless    \lesseqgtr    \gtreqless    \lesseqqgtr    \gtreqqless    \lesssim    \gtrsim    \lnsim    \gnsim    \lessapprox    \gtrapprox    \lnapprox    \gnapprox    \vartriangleleft    \vartriangleright    \ntriangleleft    \ntriangleright    \trianglelefteq    \trianglerighteq    \ntrianglelefteq    \ntrianglerighteq    \blacktriangleleft    \blacktriangleright    \subset    \supset    \subseteq    \supseteq    \subsetneq    \supsetneq    \varsubsetneq    \varsupsetneq    \nsubseteq    \nsupseteq    \subseteqq    \supseteqq    \subsetneqq    \supsetneqq    \nsubseteqq    \nsupseteqq    \backepsilon    \Subset    \Supset    \sqsubset    \sqsupset    \sqsubseteq    \sqsupseteq<br>$$</p><h5 id="箭头符号"><a href="#箭头符号" class="headerlink" title="箭头符号"></a>箭头符号</h5><p>$$<br>\leftarrow    \leftrightarrow    \rightarrow    \mapsto    \longleftarrow        \longleftrightarrow    \longrightarrow    \longmapsto    \downarrow    \updownarrow    \uparrow    \nwarrow        \searrow    \nearrow    \swarrow        \nleftarrow            \nleftrightarrow        \nrightarrow        \hookleftarrow        \hookrightarrow        \twoheadleftarrow        \twoheadrightarrow        \leftarrowtail        \rightarrowtail        \Leftarrow        \Leftrightarrow        \Rightarrow        \Longleftarrow        \Longleftrightarrow        \Longrightarrow            \Updownarrow        \Uparrow        \Downarrow        \nLeftarrow        \nLeftrightarrow    \nRightarrow        \leftleftarrows        \leftrightarrows        \rightleftarrows        \rightrightarrows        \downdownarrows        \upuparrows        \circlearrowleft        \circlearrowright        \curvearrowleft        \curvearrowright        \Lsh        \Rsh        \looparrowleft        \looparrowright        \dashleftarrow        \dashrightarrow        \leftrightsquigarrow        \rightsquigarrow        \Lleftarrow        \leftharpoondown        \rightharpoondown        \leftharpoonup        \rightharpoonup        \rightleftharpoons        \leftrightharpoons        \downharpoonleft        \upharpoonleft        \downharpoonright            \upharpoonright<br>$$</p><h5 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h5><p>$$<br>\downarrow    \Downarrow    \langle \rangle [ ] | | \lceil \rceil \uparrow    \Uparrow    \lfloor        \rfloor    \updownarrow    \Updownarrow    (        )    \{    \} \backslash    \lmoustache        \rmoustache    \lgroup    \rgroup    \arrowvert    \Arrowvert    \bracevert    \lvert    \rvert    \lVert        \rVert    \ulcorner    \urcorner \llcorner \lrcorner<br>$$</p><h5 id="希腊字符"><a href="#希腊字符" class="headerlink" title="希腊字符"></a>希腊字符</h5><p>$$<br>\alpha    \beta        \gamma    \delta    \epsilon    \zeta    \eta    \theta    \vartheta    \iota    \kappa    \lambda    \mu    \nu    \xi    o    \pi    \varpi    \rho    \varrho    \sigma    \varsigma    \tau    \upsilon    \phi    \varphi    \chi    \psi    \omega    A    B    \Gamma    \varGamma    \Delta    \varDelta    E    Z    H    \Theta    \varTheta    I    K    \Lambda    \varLambda    M    N    \Xi    \varXi    O    \Pi    \varPi    P    \Sigma        \Upsilon    \varUpsilon    \Phi    \varPhi    X    \varPsi    \Omega    \varOmega<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day05</title>
      <link href="/2019/07/19/day05/"/>
      <url>/2019/07/19/day05/</url>
      
        <content type="html"><![CDATA[<h2 id="使用频率域滤波器平滑图像"><a href="#使用频率域滤波器平滑图像" class="headerlink" title="使用频率域滤波器平滑图像"></a>使用频率域滤波器平滑图像</h2><hr><h3 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h3><p>在以原点为圆心，以$D_0$为半径的圆内无衰减通过所有频率，而在圆外切断所有频率的二维低通滤波器，称为理想低通滤波器(ILPF)，定义为<br>$$y=\begin{cases}<br>1,\quad D(x,y)\leq 0\<br>0, \quad D(x,y) &gt; 0<br>\end{cases}$$<br>$D_0$是一个常数，D(u,v)是频率域中心点(u,v)与频率矩形中心的距离，即<br>$$ D(u,v)=\lbrack{(u-\frac{P}{2})^2+(v-\frac{Q}{2})^2}\rbrack^\frac{1}{2} $$<br>过渡点成为<strong>截止频率</strong></p><h3 id="在MATLAB中DFT滤波的步骤"><a href="#在MATLAB中DFT滤波的步骤" class="headerlink" title="在MATLAB中DFT滤波的步骤:"></a>在MATLAB中DFT滤波的步骤:</h3><ol><li>用函数<code>tofloat</code>把输入图像转换成浮点图像<pre><code>&gt;&gt; [f, revertclass] = tofloat(f);</code></pre></li><li>用函数<code>paddedsize</code>来获得填充参数<pre><code>&gt;&gt; PQ = paddedsize(size(f));</code></pre></li><li>得到有填充的Fourier变换<pre><code>&gt;&gt; F = fft2(f,PQ(1), PQ(2));</code></pre></li><li>生成大小为PQ(1)×PQ(2)的滤波函数H,函数类型要满足如下图所示,<br><img src="https://i.loli.net/2019/07/19/5d318dcf343b438405.jpg" alt><br>如果是类似这样的<br><img src="https://i.loli.net/2019/07/19/5d318dcf4915275796.jpg" alt>    <pre><code>&gt;&gt; H = lpfilter(&#39;gaussian&#39;,PQ(1),PQ(2),2*sig);</code></pre>在使用滤波器之前，要先<code>H = fftshift(H)</code></li><li>用滤波器乘以FFT变换<pre><code>&gt;&gt; G = H .* F;</code></pre></li><li>获得G的逆Fourier变换<pre><code>&gt;&gt; g = ifft2(G);</code></pre></li><li>修剪左上部矩形为原始大小<pre><code>&gt;&gt; g = g(1:size(f, 1), 1:size(f, 2));</code></pre></li><li>把滤波后的图像变换为输入图像的类<pre><code>&gt;&gt; g = revertclass(g);</code></pre></li></ol><p>完整代码</p><pre><code>f = imread(&#39;1.jpg&#39;);f = rgb2gray(f);%未填充的滤波[M,N] = size(f);[f, revertclass] = tofloat(f);F = fft2(f);sig = 10;H = lpfilter(&#39;gaussian&#39;, M, N, sig);G = H.*F;g = ifft2(G);g = revertclass(g);figure(1);subplot(1,2,1);imshow(g)title(&#39;未填充的滤波&#39;);%已填充的滤波PQ = paddedsize(size(f));Fp = fft2(f,PQ(1),PQ(2));Hp = lpfilter(&#39;gaussian&#39;,PQ(1),PQ(2),2*sig);Gp = Hp.*Fp;gp = ifft2(Gp);gpc = gp(1:size(f,1),1:size(f,2));gpc = revertclass(gpc);subplot(1,2,2);imshow(gpc);title(&#39;已填充的滤波&#39;);</code></pre><p>这里展示了不填充滤波和填充滤波的两种情况，结果<br><img src="https://i.loli.net/2019/07/19/5d318dcf1e88071166.jpg" alt><br>可以观察到未填充滤波处理后图像的垂直边缘未模糊</p><p>涉及到的函数    </p><ul><li>paddedsize函数<pre><code>function PQ = paddedsize(AB, CD, PARAM)</code></pre></li></ul><p>if nargin == 1</p><p>PQ = 2*AB;</p><p>elseif nargin == 2 &amp; ~ischar(CD) %如果CD不为字符串</p><p>PQ = AB + CD -1;</p><p>PQ = 2 *ceil(PQ / 2);</p><p>elseif nargin == 2 %如果CD处为字符串</p><p>m = max(AB);</p><p>P = 2^nextpow2(2*m); %取2的整数次幂</p><p>PQ = [P, P];</p><p>elseif nargin == 3</p><p>m = max([AB CD]);</p><p>P = 2^nextpow2(2*m);</p><p>PQ = [P, P];</p><p>else</p><p>error(‘wrong number of inputs.’)</p><p>end</p><pre><code>- lpfilter函数</code></pre><p>function [ H, D ] = lpfilter( type,M,N,D0,n )</p><p>%LPFILTER creates the transfer function of a lowpass filter.</p><p>%   Detailed explanation goes here</p><p>%use function dftuv to set up the meshgrid arrays needed for computing</p><p>%the required distances.</p><p>[U, V] = dftuv(M,N);</p><p>%compute the distances D(U,V)</p><p>D = sqrt(U.^2 + V.^2);</p><p>%begin filter computations</p><p>switch type</p><pre><code>case &#39;ideal&#39;    H = double(D &lt;= D0);case &#39;btw&#39;    if nargin == 4        n = 1;    end    H = 1./(1+(D./D0).^(2*n));case &#39;gaussian&#39;    H = exp(-(D.^2)./(2*(D0^2)));otherwise    error(&#39;Unkown filter type&#39;);</code></pre><p>end</p><pre><code>- dftuv函数</code></pre><p>function [ U,V ] = dftuv( M, N )</p><p>%DFTUV 实现频域滤波器的网格函数</p><p>%   Detailed explanation goes here</p><p>u = 0:(M - 1);</p><p>v = 0:(N - 1);</p><p>idx = find(u &gt; M/2); %找大于M/2的数据</p><p>u(idx) = u(idx) - M; %将大于M/2的数据减去M</p><p>idy = find(v &gt; N/2);</p><p>v(idy) = v(idy) - N;</p><p>[V, U] = meshgrid(v, u);</p><pre><code>### 总结：1. 图像平滑之后，变得更柔和，但也会更模糊    2. 会出现的问题:图像的边缘部分往往也处于高频，会被滤除</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day04</title>
      <link href="/2019/07/18/day04/"/>
      <url>/2019/07/18/day04/</url>
      
        <content type="html"><![CDATA[<h2 id="频域滤波"><a href="#频域滤波" class="headerlink" title="频域滤波"></a>频域滤波</h2><ol><li>对图像平滑的低通滤波</li><li>对图像锐化的高通滤波</li><li>去除周期的选择性滤波</li></ol><h2 id="二维傅里叶变换"><a href="#二维傅里叶变换" class="headerlink" title="二维傅里叶变换"></a>二维傅里叶变换</h2><ul><li><p>二维傅里叶变换:<br>$$ F(u,v)=\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x,y)e^{-j2\pi(ux + vy)}\,\mathrm{d}x \mathrm{d}y $$</p></li><li><p>二维傅里叶逆变换：<br>$$ f(x,y) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(u,v)e^{j2\pi(ux + vy)}\,dxdy $$</p></li></ul><h2 id="二维离散傅里叶变换"><a href="#二维离散傅里叶变换" class="headerlink" title="二维离散傅里叶变换"></a>二维离散傅里叶变换</h2><p>f(x,y)代表一幅大小为M×N的图像，其中x=0,1,……,M-1,y=0,1,…..,N-1,DFT如下</p><p>$$ F(u,v)=\int_{x=0}^{M-1} \int_{y=0}^{N-1} f(x,y)e^{-j2\pi(\frac{ux}{M}+\frac{vy}{N})}\,\mathrm{d}x \mathrm{d}y $$</p><p>IDFT：</p><p>$$ f(x,y)=\frac{1}{MN}\int_{x=0}^{M-1} \int_{y=0}^{N-1} F(u,v)e^{j2\pi(\frac{ux}{M}+\frac{vy}{N})}\,\mathrm{d}x \mathrm{d}y $$</p><p>这里的F(u,v)被称为展开的傅里叶级数</p><p>频域原点出的变换的值F(0,0)称为傅里叶变换的直流(dc)分量，F(0,0)等于f(0,0)平均值的MN倍。要注意的是在MATLAB中索引是从1开始的而不是从0开始的</p><h2 id="MATLAB实现对图像的Fourier变换和逆变换"><a href="#MATLAB实现对图像的Fourier变换和逆变换" class="headerlink" title="MATLAB实现对图像的Fourier变换和逆变换"></a>MATLAB实现对图像的Fourier变换和逆变换</h2><ul><li>Fourier变换，f为原图像<pre><code>&gt;&gt; F = fft2(f);</code></pre></li><li>Fourier谱<pre><code>&gt;&gt; S = abs(F);</code></pre>该函数计算的是数组中每个元素的幅值( $ \sqrt{r^2+i^2} $ )<br>可以在这里观察到4个角的亮点，这就是周期特性的结果，不便观察</li><li>将交换的原点移动到频域矩形的中心<pre><code>&gt;&gt; Fc = fftshift(F)</code></pre>频谱范围大，不边观察</li><li>取模，缩放<pre><code>S2 = log(1 + abs(Fc));</code></pre></li><li>Fourier逆变换<pre><code>&gt;&gt; f = ifft2(F);</code></pre>下面是完整代码<pre><code>img=imread(&#39;moon.jpg&#39;);subplot(2,2,1);  imshow(img);  title(&#39;原图&#39;);</code></pre></li></ul><p>f=rgb2gray(img);    %对于RGB图像必须做的一步，也可以用im2double函数<br>F=fft2(f);          %Fourier变换<br>F1=log(abs(F)+1);   %取模,缩放<br>subplot(2,2,2);<br>    imshow(F1,[]);<br>    title(‘傅里叶变换频谱图’);</p><p>Fs=fftshift(F);      %将频谱图中零频率成分移动至频谱图中心<br>S=log(abs(Fs)+1);    %取模并进行缩放<br>subplot(2,2,3);<br>    imshow(S,[]);<br>    title(‘频移后的频谱图’);</p><p>fr=real(ifft2(ifftshift(Fs)));  %频率域反变换到空间域，并取实部<br>ret=im2uint8(mat2gray(fr));    %更改图像类型<br>subplot(2,2,4);<br>    imshow(ret);<br>    title(‘逆傅里叶变换’);</p><pre><code>结果![](https://i.loli.net/2019/07/18/5d3043778b4e114553.jpg)如果使用`&gt;&gt; f = im2double(img)`进行处理，则会出现以下结果![](https://i.loli.net/2019/07/18/5d304377bcc9554917.jpg)-分析    1. 图像Fourier变换之后立即imshow会报错![](https://i.loli.net/2019/07/18/5d3043779bef722309.jpg)这是因为经过fourier变换之后的图像矩阵为复数矩阵，包含实部和虚部，此时进行`abs(f)`取复数矩阵的模，再显示。2. `rgb2gray()`和`im2double()`的使用这一点要特别注意，对于RGB图像，`imread()`是已三维矩阵的形式来存储的，要先进行类型转换，否则会出现空白    3. `rgb2gray()`转换为灰度图像,得到的图像呈灰色基调，见‘结果’4. `im2double()`转换成双精度图像，得到的图像呈白色基调，见‘结果’其他图像处理结果![](https://i.loli.net/2019/07/18/5d304377bd0c676784.jpg)![](https://i.loli.net/2019/07/18/5d304377b0b2610307.jpg)可以看到Fourier逆变换处理之后的图片为原图的灰度图片。## 对图像Fourier变换的意义分析对于一个图像，其频率是表征图像中灰度变化剧烈程度的指标，是灰度在平面空间的梯度。设f为一个能量有限的模拟信号，其傅里叶变换代表f的频谱。从纯粹的数学意义上来看，Fourier变换是将一个函数转换成一系列的周期函数来进行处理的。从物理角度来看，Fourier变换是将图像从空间域转换到频率域，逆变换是将图像从频率域转换到空间域。也就是说，Fourier变换是将图像的灰度分布函数变换成图像的频率分布函数。==这里要注意是灰度分布函数==,下面还会说到。Fourie逆变换是将图像的频率分布函数转换成灰度分布函数(原始图像的灰度分布函数),图像的概念前边说过，用一个二维矩阵来表示空间上的各点，z=f(x,y)，但空间是三维的，因此空间上的物体在另一个维度上的关系必须由梯度来表示。Fourier频谱图上的明暗点，意义是指图像上的某一点与邻域点差异的强弱，即梯度的大小。对频谱移频到原点之后，可以看出图像的频率分布是以原点为圆心，对称分布的.</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day03</title>
      <link href="/2019/07/17/day03/"/>
      <url>/2019/07/17/day03/</url>
      
        <content type="html"><![CDATA[<h2 id="标准的空间滤波器"><a href="#标准的空间滤波器" class="headerlink" title="标准的空间滤波器"></a>标准的空间滤波器</h2><h3 id="线性空间滤波器"><a href="#线性空间滤波器" class="headerlink" title="线性空间滤波器"></a>线性空间滤波器</h3><ul><li><p>可以使用fspecial实现，生成滤波器w</p><pre><code>  w = fspecial(&#39;type&#39;, parameters)</code></pre><p>  ‘type’表示滤波器的类型，’parameters’进一步定义指定的滤波器<br>  应用参数如下：<br>  <img src="https://i.loli.net/2019/07/17/5d2eba0f5055d41026.jpg" alt><br>  <img src="https://i.loli.net/2019/07/17/5d2ec9491164776894.jpg" alt></p></li><li><p>Laplace滤波器的实现</p><ul><li>原理：<br>图像f(x,y)的laplace算子：<br><img src="https://i.loli.net/2019/07/17/5d2ec90e6a75162149.jpg" alt><br>Laplace算子增强公式：<br>$$g(x,y) = f(x,y)+c[\triangledown ^2 f(x,y)]$$<br>注意：如果模板的中心系数为正，c为1;如果为负，c为0.<pre><code>fspecial(&#39;laplacian&#39;, alpha)</code></pre>可以实现更为一般的laplace模板</li></ul><ul><li><p>下面是用laplace滤波器增强图像的例子：<br>首先设置滤波器</p><pre><code>&gt;&gt; w = fspecial(&#39;laplacian&#39;, 0);</code></pre><p><img src="https://i.loli.net/2019/07/17/5d2ed6fcca83142276.jpg" alt></p><p>输入的图像为unit8类，</p><pre><code>&gt;&gt; g1 = imfilter(f, w, &#39;replicate&#39;);&gt;&gt; imshow(g1);</code></pre><p>得到结果，但存在问题，所有像素都是正的。原因：滤波器的中心参数为负值，为了解决这一问题，可以在滤波前将f转换为浮点数</p><pre><code>&gt;&gt; ff = tofloat(f);&gt;&gt; g2 = imfilter(ff, w, &#39;replicate&#39;);&gt;&gt; imshow(g2);</code></pre><p>这里tofloat为M-IPT函数，实现代码如下：</p><pre><code>function [out,revertclass] = tofloat(inputimage)%Copy the book of Gonzalesidentify = @(x) x;tosingle = @im2single;table = {&#39;uint8&#39;,tosingle,@im2uint8&#39;uint16&#39;,tosingle,@im2uint16&#39;logical&#39;,tosingle,@logical&#39;double&#39;,identify,identify&#39;single&#39;,identify,identify};classIndex = find(strcmp(class(inputimage),table(:,1)));if isempty(classIndex)error(&#39;不支持的图像类型&#39;);endout = table{classIndex,2}(inputimage);revertclass = table{classIndex,3};</code></pre><p>导入workspace即可</p><p>最后用原始图像减去laplace图像来恢复失去的灰度层次(因为中心参数为负值)</p><pre><code>&gt;&gt; g = ff - g2;imshow(g);</code></pre><p>可以看到结果比原图象要清晰<br><img src="https://i.loli.net/2019/07/17/5d2ed69eaa47174206.jpg" alt></p><h3 id="非线性空间滤波器"><a href="#非线性空间滤波器" class="headerlink" title="非线性空间滤波器"></a>非线性空间滤波器</h3></li></ul></li><li><p>函数ordfilt2计算统计排序(order-statistic filter)滤波器(也叫做rank filter,即排序滤波器)<br>语法为：</p><pre><code>g = ordfilt2(f, order, domain)</code></pre><p>用邻域集合中的第order个元素去替换f中的每个元素的值来生成图像g，domain是由0和1组成的大小为m×n的矩阵，规定了在计算中使用的邻域中像素点的位置</p></li><li><p>中值滤波器，最著名的统计排序滤波器，对应第50个百分位，对应奇数的m和n</p><pre><code>g = ordfilt2(f, (m*n + 1)/2, ones(m, n));</code></pre><ul><li>这里提供了一个专门的二维中值滤波器:<pre><code>g = medfilt2(f, [m, n], padopt)</code></pre>padopt规定了三个可能的边缘填充选项:</li></ul><ol><li>‘zeros’,默认值</li><li>‘symmetric’,f按照镜像反射方式对称地沿边缘扩展</li><li>‘indexed’，f属于double类，用1填充;否则用0填充</li></ol><ul><li><p>中值滤波增强图像:<br>首先给图像添加黑白噪点发生概率为0.2的’椒盐噪声’</p><pre><code>&gt;&gt; fn = imnoise(f, &#39;salt &amp; pepper&#39;, 0.2)</code></pre><p>对带噪图像进行中值滤波处理</p><pre><code>&gt;&gt; gm = medfilt2(fn)</code></pre><p>注意，在这里出现了错误，==A应为二维==<br><img src="https://i.loli.net/2019/07/17/5d2ed759e608448713.jpg" alt></p><p>原因:中值滤波medfilt2,输入的图像应为二维矩阵，实际输入的为imread读取的图像加上噪声，通常是三维RGB图，是三维矩阵<br>解决办法:先用rgb2gray(f)将图像转换为灰度矩阵图像</p><pre><code>&gt;&gt; fn2 = rgb2gray(fn);&gt;&gt; gm = medfilt2(fn2);&gt;&gt; imshow(gm);</code></pre><p>减弱外圈黑点</p><pre><code>&gt;&gt; gms = medfilt2(fn2, &#39;symmetric&#39;);</code></pre><p><img src="https://i.loli.net/2019/07/17/5d2ed7776b71a55041.jpg" alt></p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day02</title>
      <link href="/2019/07/16/day02/"/>
      <url>/2019/07/16/day02/</url>
      
        <content type="html"><![CDATA[<h2 id="空间滤波基础"><a href="#空间滤波基础" class="headerlink" title="空间滤波基础"></a>空间滤波基础</h2><ul><li><p>滤波的原理：     空间滤波是采用滤波处理的图像增强的方法，理论基础是空间卷积和空间相关，目的是改善图片质量</p></li><li><p>线性空间滤波</p><ul><li><p>移动滤波的模板w称为滤波器</p></li><li><p>相关 与 卷积：<br>  相关是指模板w按下图所示的方式进行图像数组的处理。在原理上，卷积是相同的处理过程，只不过在w通过之前先将它选旋转180度<br>  <img src="https://i.loli.net/2019/07/16/5d2d9d9ea213761403.jpg" alt><br>  相关与卷积操作说明<br>  <img src="https://i.loli.net/2019/07/16/5d2d9dffdbc4911045.jpg" alt><br>  需要注意的地方：    </p><ol><li>相关是滤波器位移的函数</li><li>滤波器w与一个只包含一个1其余全是0的函数相关，得到的是旋转了180度的滤波器w，将这个函数称之为<strong>离散单位冲激</strong><br>结论: 一个函数与离散单位冲激相关，在该冲激位置产生这个函数的一个翻转版本<br>一个函数与离散单位冲激相关激卷积，得到的是在该冲激处的这个函数的拷贝，这个复制的性质称为筛选<br>这种定义推广到图像如下图所示<br><img src="https://i.loli.net/2019/07/17/5d2e77c7afba429201.jpg" alt><br>为了便于表达，以公式形式总结两种形式</li></ol><ul><li>大小为m×n的滤波模板w(x,y)与函数f(x,y)的相关<br> <img src="https://i.loli.net/2019/07/17/5d2e78e52323950837.jpg" alt></li><li>大小为m×n的滤波模板w(x,y)与函数f(x,y)的卷积<br> $$w(x,y)\bigstar f(x,y)=\sum_{s=-a}^{a}\sum_{t=-b}^{b}w(s,t)f(x+s,y+t)$$</li></ul></li><li><p>Matlab的实现:<br>  工具箱使用imfilter来实现线性空间滤波，语法如下:</p><pre><code>  g = imfilter(f, w, filtering_mode, boundary_options, size_options)</code></pre><p>  默认值为相关，若想执行卷积操作，有以下两种做法：</p><pre><code>  g = imfilter(f, w, &#39;conv&#39;)</code></pre><p>  或者使用<code>rot90(w, 2)</code>来将w旋转180度</p><pre><code>  g = imfilter(f, rot90(w, 2))</code></pre><p>  f是输入图像，w为滤波模板，g为滤波结果<br>  其他参数如下<br>  <img src="https://i.loli.net/2019/07/17/5d2e84e556ad615011.jpg" alt><br>  使用matlab实现为</p><pre><code>  f = imread(&#39;filter.jpg&#39;);  F = im2double(f);  imshow(F);  title(&#39;current image&#39;);  w = ones(31);  gd = imfilter(F, w);  figure,imshow(gd, [ ]);  title(&#39;Default&#39;);  gr = imfilter(F, w, &#39;replicate&#39;);  figure,imshow(gr, [ ]);  title(&#39;replicate&#39;);  gs = imfilter(F, w, &#39;symmetric&#39;);  figure,imshow(gs, [ ]);  title(&#39;symmetric&#39;);  gc = imfilter(F, w, &#39;circular&#39;);  figure,imshow(gc, [ ]);  title(&#39;circular&#39;);  g = imfilter(f, w, &#39;replicate&#39;);  figure,imshow(g, [ ]);  title(&#39;replicate unit8&#39;);</code></pre><p>  这里开始读取的filter.jpg为uint8格式，故在处理之前先使用<code>im2double</code>将其转化为double类型以提高精度<br>  滤波结果如下<br>  <img src="https://i.loli.net/2019/07/17/5d2e8517ac67e80281.jpg" alt></p></li></ul></li><li><p>非线性空间滤波：<br>线性空间滤波基于计算乘积和，即线性操作，非线性空间滤波基于涉及邻域像素内的非线性操作，例如，使每个中心点的响应等于邻域内像素最大值的操作可以称为是非线性滤波操作      </p><ul><li>Matlab工具<ol><li>nlfilter：直接执行二维操作</li><li>coldilt：按列组织数据，更多采用</li></ol></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Day01</title>
      <link href="/2019/07/15/day01/"/>
      <url>/2019/07/15/day01/</url>
      
        <content type="html"><![CDATA[<h2 id="Digital-Image-Processing-notes"><a href="#Digital-Image-Processing-notes" class="headerlink" title="Digital Image Processing notes:"></a>Digital Image Processing notes:</h2><ul><li><p>图像处理的步骤：</p><ol><li>图像获取 包括图像预处理</li><li>图像滤波与增强 使之适用于==特定应用==</li><li>图像复原 倾向于以图像退化的数学或概率模型为基础</li><li>彩色图像处理</li><li>压缩 减少图像存储量或降低传输图像带宽 </li><li>形态学处理</li><li>图像分割</li><li>目标识别<h3 id="数字图像基础"><a href="#数字图像基础" class="headerlink" title="数字图像基础"></a>数字图像基础</h3></li></ol></li><li><p>灰度概念<br>  灰度是表明图像明暗的数值，即黑白图像中点的颜色深度，范围一般是0-255,白色为255,黑色为0,归一化处理之后[0,1],0代表黑色，1代表白色。</p></li><li><p>图像取样与量化</p><ul><li>对坐标值数字化称为取样，对幅度值数字化称为量化</li></ul></li><li><p>数字的图像表示<br>  将连续图像取样表示为一个二维阵列f(x,y)</p><ol><li>函数图表示：用x和y两个坐标轴来表示空间位置，第三个坐标为f(灰度)值，即f(x,y,z)，</li><li>一般的表示：显示的是f(x,y)在监视器或照片上的情况，每个点的灰度与该点处的f值成正比，例如归一化[0,1],三个等间隔点分别为0,0.5,1</li><li>矩阵： 将f(x,y)的值打印成矩阵<br>注意坐标为右手笛卡尔系</li></ol></li><li><p>对比度： 最高和最低的灰度级的差</p></li><li><p>典型灰度级：</p><pre class=" language-math"><code class="language-math">  2^k</code></pre><p>  称为一副’k bit图像’</p></li><li><p>图像内插</p><ul><li>最邻近内插</li><li>双线性内插</li><li>双三次内插</li></ul></li><li><p>图像处理的算术操作</p><ul><li>图片相加  平均 -&gt; 降噪</li><li>图片相减  增强图像差别</li><li>图片想乘除  校正阴影</li></ul></li><li><p>灰度变换</p><ul><li>s = T(r)</li><li>Matlab中的灰度变换函数<br>  imadjust(f,[LOW_IN,HIGH_IN],[LOW_OUT,HIGH_OUT],grmma)</li></ul></li><li><p>直方图的处理和函数绘图</p><ul><li>生成图像的直方图<pre><code>  &gt;&gt; h = imhist(f)</code></pre></li><li>也可以用条形图来表示<pre><code>  &gt;&gt; h = imhist(f,25);  &gt;&gt; horz = linespace(0,255,25);  &gt;&gt; bar(horz,h)  &gt;&gt; axis(0 255 0 60000);  &gt;&gt; set(gca, &#39;xtick&#39;, 0:50:255)  &gt;&gt; set(gca, &#39;ytick&#39;, 0:20000:60000)</code></pre></li><li>杆状图<br>stem(horz, z , ‘LineSpec’, ‘fill’)</li><li>plot函数<br>plot(horz, z, ‘LineSpec’)</li><li>当处理函数句柄时<br>fplot(fhandle, limits, ‘LineSpec’)</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习第一周</title>
      <link href="/2019/07/14/shi-xi-di-yi-zhou/"/>
      <url>/2019/07/14/shi-xi-di-yi-zhou/</url>
      
        <content type="html"><![CDATA[<h3 id="先P一下第一周要学到的技术栈："><a href="#先P一下第一周要学到的技术栈：" class="headerlink" title="先P一下第一周要学到的技术栈："></a>先P一下第一周要学到的技术栈：</h3><ol><li>图形变换</li><li>空间滤波</li><li>卷积、傅里叶变换</li><li>边缘滤波</li><li>二维离散及其反变换</li><li>各种滤波器的原理</li><li>MatLab代码实现</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>My plan</title>
      <link href="/2019/07/05/my-plan/"/>
      <url>/2019/07/05/my-plan/</url>
      
        <content type="html"><![CDATA[<h1 id="写一下近期要做的事情："><a href="#写一下近期要做的事情：" class="headerlink" title="写一下近期要做的事情："></a>写一下近期要做的事情：</h1><ul><li><p>整理一下之前做过的项目</p></li><li><p>写一下manjaro+i3wm配置相关的教程，其中包括：</p></li></ul><p><img src="https://github.com/liuyaanng/.config/raw/master/config.png" alt="config"></p><ul><li><p><strong>配置vim</strong></p></li><li><p>从零开始的narkdown教程</p></li><li><p>Python单排系列</p></li><li><p>人工智能笔记</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
